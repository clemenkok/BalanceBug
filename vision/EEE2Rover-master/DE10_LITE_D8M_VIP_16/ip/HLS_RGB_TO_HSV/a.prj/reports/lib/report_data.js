var areaJSON='{"columns":["", "ALUTs", "FFs", "RAMs", "DSPs", "Details"], "debug_enabled":"true", "type":"module", "total_percent":[15.9449, 10.7301, 6.282, 6.59341, 5.55556], "total":[3974, 3141, 12, 8], "name":"System", "max_resources":[37036, 50000, 182, 144], "children":[{"name":"rgb_to_hsv", "compute_units":1, "type":"function", "total_percent":[15.9449, 10.7301, 6.282, 6.59341, 5.55556], "total_kernel_resources":[3974, 3141, 12, 7.5], "details":[{"type":"text", "text":"Number of compute units: 1"}], "children":[{"name":"Component call", "type":"resource", "data":[0, 0, 0, 0], "details":[{"type":"text", "text":"Stream implemented 32 bits wide with a buffer size of 0 elements."}]}, {"name":"Component return", "type":"resource", "data":[0, 0, 0, 0], "details":[{"type":"text", "text":"Stream implemented 32 bits wide with a buffer size of 0 elements."}]}, {"name":"rgb_to_hsv.B1.start", "type":"basicblock", "children":[{"name":"State", "type":"resource", "data":[2600, 2553, 5, 0], "details":[{"type":"text", "text":"Resources for live values and control logic. To reduce this area:", "details":[{"type":"text", "text":"reduce size of local variables"}, {"type":"text", "text":"reduce scope of local variables, localizing them as much as possible"}, {"type":"text", "text":"reduce number of nested loops"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[2600, 2553, 5, 0]}]}, {"name":"Cluster logic", "type":"resource", "data":[8, 58, 2, 0], "details":[{"type":"text", "text":"Logic required to efficiently support sets of operations that do not stall. This area cannot be affected directly."}]}, {"name":"Computation", "type":"resource", "children":[{"name":"No Source Line", "type":"resource", "data":[69, 12, 0, 0], "debug":[[{"filename":"", "line":0}]], "children":[{"name":"And", "type":"resource", "count":1, "data":[1, 1, 0, 0]}, {"name":"Channel Read", "type":"resource", "count":1, "data":[1, 0, 0, 0]}, {"name":"Integer Compare", "type":"resource", "count":3, "data":[33, 3, 0, 0]}, {"name":"Non-Blocking Channel Write", "type":"resource", "count":1, "data":[3, 0, 0, 0]}, {"name":"Select", "type":"resource", "count":3, "data":[31, 8, 0, 0]}]}, {"name":"rgb_to_hsv.c:18 > ac_int.h:1854 > \\nac_int.h:980", "type":"resource", "data":[22, 2, 0, 0], "debug":[[{"filename":"rgb_to_hsv.c", "line":18}, {"filename":"C:/intelFPGA_lite/18.1/hls/include\\\\HLS/ac_int.h", "line":1854}, {"filename":"C:/intelFPGA_lite/18.1/hls/include\\\\HLS/ac_int.h", "line":980}]], "children":[{"name":"Integer Compare", "type":"resource", "count":2, "data":[22, 2, 0, 0]}], "replace_name":"true"}, {"name":"rgb_to_hsv.c:20 > ac_int.h:1854 > \\nac_int.h:980", "type":"resource", "data":[11, 1, 0, 0], "debug":[[{"filename":"rgb_to_hsv.c", "line":20}, {"filename":"C:/intelFPGA_lite/18.1/hls/include\\\\HLS/ac_int.h", "line":1854}, {"filename":"C:/intelFPGA_lite/18.1/hls/include\\\\HLS/ac_int.h", "line":980}]], "children":[{"name":"Integer Compare", "type":"resource", "count":1, "data":[11, 1, 0, 0]}], "replace_name":"true"}, {"name":"rgb_to_hsv.c:23", "type":"resource", "data":[26.3333, 5.33333, 0, 0], "debug":[[{"filename":"rgb_to_hsv.c", "line":23}]], "children":[{"name":"Select", "type":"resource", "count":6, "data":[26.3333, 5.33333, 0, 0]}], "replace_name":"true"}, {"name":"rgb_to_hsv.c:29 > ac_int.h:1854 > \\nac_int.h:980", "type":"resource", "data":[11, 1, 0, 0], "debug":[[{"filename":"rgb_to_hsv.c", "line":29}, {"filename":"C:/intelFPGA_lite/18.1/hls/include\\\\HLS/ac_int.h", "line":1854}, {"filename":"C:/intelFPGA_lite/18.1/hls/include\\\\HLS/ac_int.h", "line":980}]], "children":[{"name":"Integer Compare", "type":"resource", "count":1, "data":[11, 1, 0, 0]}], "replace_name":"true"}, {"name":"rgb_to_hsv.c:34", "type":"resource", "data":[26.3333, 5.33333, 0, 0], "debug":[[{"filename":"rgb_to_hsv.c", "line":34}]], "children":[{"name":"Select", "type":"resource", "count":6, "data":[26.3333, 5.33333, 0, 0]}], "replace_name":"true"}, {"name":"rgb_to_hsv.c:40 > ac_int.h:1854 > \\nac_int.h:980", "type":"resource", "data":[22, 2, 0, 0], "debug":[[{"filename":"rgb_to_hsv.c", "line":40}, {"filename":"C:/intelFPGA_lite/18.1/hls/include\\\\HLS/ac_int.h", "line":1854}, {"filename":"C:/intelFPGA_lite/18.1/hls/include\\\\HLS/ac_int.h", "line":980}]], "children":[{"name":"Integer Compare", "type":"resource", "count":2, "data":[22, 2, 0, 0]}], "replace_name":"true"}, {"name":"rgb_to_hsv.c:45", "type":"resource", "data":[19.3333, 5.33333, 0, 0], "debug":[[{"filename":"rgb_to_hsv.c", "line":45}]], "children":[{"name":"Select", "type":"resource", "count":4, "data":[19.3333, 5.33333, 0, 0]}], "replace_name":"true"}, {"name":"rgb_to_hsv.c:56", "type":"resource", "data":[12, 1, 0, 0], "debug":[[{"filename":"rgb_to_hsv.c", "line":56}]], "children":[{"name":"8-bit Integer Subtract", "type":"resource", "count":1, "data":[9, 0, 0, 0]}, {"name":"Integer Compare", "type":"resource", "count":1, "data":[3, 1, 0, 0]}], "replace_name":"true"}, {"name":"rgb_to_hsv.c:68", "type":"resource", "data":[1, 1, 0, 0], "debug":[[{"filename":"rgb_to_hsv.c", "line":68}]], "children":[{"name":"And", "type":"resource", "count":1, "data":[1, 1, 0, 0]}], "replace_name":"true"}, {"name":"rgb_to_hsv.c:68 > ac_int.h:2223 > \\nac_int.h:1838 > ac_int.h:973", "type":"resource", "data":[6.5, 0.5, 0, 0], "debug":[[{"filename":"rgb_to_hsv.c", "line":68}, {"filename":"C:/intelFPGA_lite/18.1/hls/include\\\\HLS/ac_int.h", "line":2223}, {"filename":"C:/intelFPGA_lite/18.1/hls/include\\\\HLS/ac_int.h", "line":1838}, {"filename":"C:/intelFPGA_lite/18.1/hls/include\\\\HLS/ac_int.h", "line":973}]], "children":[{"name":"And", "type":"resource", "count":1, "data":[0.5, 0.5, 0, 0]}, {"name":"Integer Compare", "type":"resource", "count":2, "data":[6, 0, 0, 0]}], "replace_name":"true"}, {"name":"rgb_to_hsv.c:69", "type":"resource", "data":[2, 2, 0, 0], "debug":[[{"filename":"rgb_to_hsv.c", "line":69}]], "children":[{"name":"And", "type":"resource", "count":2, "data":[2, 2, 0, 0]}], "replace_name":"true"}, {"name":"rgb_to_hsv.c:69 > ac_int.h:2223 > \\nac_int.h:1838 > ac_int.h:973", "type":"resource", "data":[3, 0, 0, 0], "debug":[[{"filename":"rgb_to_hsv.c", "line":69}, {"filename":"C:/intelFPGA_lite/18.1/hls/include\\\\HLS/ac_int.h", "line":2223}, {"filename":"C:/intelFPGA_lite/18.1/hls/include\\\\HLS/ac_int.h", "line":1838}, {"filename":"C:/intelFPGA_lite/18.1/hls/include\\\\HLS/ac_int.h", "line":973}]], "children":[{"name":"Integer Compare", "type":"resource", "count":1, "data":[3, 0, 0, 0]}], "replace_name":"true"}, {"name":"rgb_to_hsv.c:70", "type":"resource", "data":[2, 2, 0, 0], "debug":[[{"filename":"rgb_to_hsv.c", "line":70}]], "children":[{"name":"And", "type":"resource", "count":3, "data":[2, 2, 0, 0]}], "replace_name":"true"}, {"name":"rgb_to_hsv.c:70 > ac_int.h:2223 > \\nac_int.h:1838 > ac_int.h:973", "type":"resource", "data":[3, 0, 0, 0], "debug":[[{"filename":"rgb_to_hsv.c", "line":70}, {"filename":"C:/intelFPGA_lite/18.1/hls/include\\\\HLS/ac_int.h", "line":2223}, {"filename":"C:/intelFPGA_lite/18.1/hls/include\\\\HLS/ac_int.h", "line":1838}, {"filename":"C:/intelFPGA_lite/18.1/hls/include\\\\HLS/ac_int.h", "line":973}]], "children":[{"name":"Integer Compare", "type":"resource", "count":1, "data":[3, 0, 0, 0]}], "replace_name":"true"}, {"name":"rgb_to_hsv.c:71", "type":"resource", "data":[2.5, 2.5, 0, 0], "debug":[[{"filename":"rgb_to_hsv.c", "line":71}]], "children":[{"name":"And", "type":"resource", "count":6, "data":[2.5, 2.5, 0, 0]}], "replace_name":"true"}, {"name":"rgb_to_hsv.c:71 > ac_int.h:2223 > \\nac_int.h:1838 > ac_int.h:973", "type":"resource", "data":[3, 0, 0, 0], "debug":[[{"filename":"rgb_to_hsv.c", "line":71}, {"filename":"C:/intelFPGA_lite/18.1/hls/include\\\\HLS/ac_int.h", "line":2223}, {"filename":"C:/intelFPGA_lite/18.1/hls/include\\\\HLS/ac_int.h", "line":1838}, {"filename":"C:/intelFPGA_lite/18.1/hls/include\\\\HLS/ac_int.h", "line":973}]], "children":[{"name":"Integer Compare", "type":"resource", "count":1, "data":[3, 0, 0, 0]}], "replace_name":"true"}, {"name":"rgb_to_hsv.c:72", "type":"resource", "data":[81, 1, 0, 0], "debug":[[{"filename":"rgb_to_hsv.c", "line":72}]], "children":[{"name":"And", "type":"resource", "count":1, "data":[1, 1, 0, 0]}, {"name":"Select", "type":"resource", "count":12, "data":[80, 0, 0, 0]}], "replace_name":"true"}, {"name":"rgb_to_hsv.c:72 > ac_int.h:2223 > \\nac_int.h:1838 > ac_int.h:973", "type":"resource", "data":[3, 0, 0, 0], "debug":[[{"filename":"rgb_to_hsv.c", "line":72}, {"filename":"C:/intelFPGA_lite/18.1/hls/include\\\\HLS/ac_int.h", "line":2223}, {"filename":"C:/intelFPGA_lite/18.1/hls/include\\\\HLS/ac_int.h", "line":1838}, {"filename":"C:/intelFPGA_lite/18.1/hls/include\\\\HLS/ac_int.h", "line":973}]], "children":[{"name":"Integer Compare", "type":"resource", "count":1, "data":[3, 0, 0, 0]}], "replace_name":"true"}, {"name":"rgb_to_hsv.c:99", "type":"resource", "data":[9, 0, 0, 0], "debug":[[{"filename":"rgb_to_hsv.c", "line":99}]], "children":[{"name":"8-bit Integer Subtract", "type":"resource", "count":1, "data":[9, 0, 0, 0]}], "replace_name":"true"}, {"name":"rgb_to_hsv.c:102", "type":"resource", "data":[966, 486, 5, 7.5], "debug":[[{"filename":"rgb_to_hsv.c", "line":102}]], "children":[{"name":"32-bit Integer Add", "type":"resource", "count":1, "data":[33, 0, 0, 0]}, {"name":"32-bit Integer Divide", "type":"resource", "count":1, "data":[933, 486, 5, 7.5]}], "replace_name":"true"}, {"name":"rgb_to_hsv.c:102 > ac_int.h:1490 > \\nac_int.h:1089 > ac_int.h:593", "type":"resource", "data":[7, 0, 0, 0], "debug":[[{"filename":"rgb_to_hsv.c", "line":102}, {"filename":"C:/intelFPGA_lite/18.1/hls/include\\\\HLS/ac_int.h", "line":1490}, {"filename":"C:/intelFPGA_lite/18.1/hls/include\\\\HLS/ac_int.h", "line":1089}, {"filename":"C:/intelFPGA_lite/18.1/hls/include\\\\HLS/ac_int.h", "line":593}]], "children":[{"name":"Select", "type":"resource", "count":1, "data":[7, 0, 0, 0]}], "replace_name":"true"}, {"name":"rgb_to_hsv.c:104 > ac_int.h:2226 > \\nac_int.h:1579 > ac_int.h:790", "type":"resource", "data":[25, 0, 0, 0], "debug":[[{"filename":"rgb_to_hsv.c", "line":104}, {"filename":"C:/intelFPGA_lite/18.1/hls/include\\\\HLS/ac_int.h", "line":2226}, {"filename":"C:/intelFPGA_lite/18.1/hls/include\\\\HLS/ac_int.h", "line":1579}, {"filename":"C:/intelFPGA_lite/18.1/hls/include\\\\HLS/ac_int.h", "line":790}]], "children":[{"name":"17-bit Integer Subtract", "type":"resource", "count":1, "data":[18, 0, 0, 0]}, {"name":"Select", "type":"resource", "count":1, "data":[7, 0, 0, 0]}], "replace_name":"true"}, {"name":"rgb_to_hsv.c:106 > ac_int.h:2226 > \\nac_int.h:1573 > ac_int.h:785", "type":"resource", "data":[33, 0, 0, 0], "debug":[[{"filename":"rgb_to_hsv.c", "line":106}, {"filename":"C:/intelFPGA_lite/18.1/hls/include\\\\HLS/ac_int.h", "line":2226}, {"filename":"C:/intelFPGA_lite/18.1/hls/include\\\\HLS/ac_int.h", "line":1573}, {"filename":"C:/intelFPGA_lite/18.1/hls/include\\\\HLS/ac_int.h", "line":785}]], "children":[{"name":"32-bit Integer Add", "type":"resource", "count":1, "data":[33, 0, 0, 0]}], "replace_name":"true"}]}]}]}]}';
var area_srcJSON='{"max_resources":[37036,50000,182,144],"name":"System","children":[{"total_kernel_resources":[3974,3141,12,7.5],"name":"rgb_to_hsv","data":[3973.9999,3140.99999,12,7.5],"children":[{"detail":[{"text":"Feedback + Cluster logic","type":"text"}],"name":"Data control overhead","type":"resource","data":[8,58,2,0]},{"name":"Component call","type":"resource","data":[0,0,0,0],"details":[{"text":"Stream implemented 32 bits wide with a buffer size of 0 elements.","type":"text"}]},{"name":"Component return","type":"resource","data":[0,0,0,0],"details":[{"text":"Stream implemented 32 bits wide with a buffer size of 0 elements.","type":"text"}]},{"name":"No Source Line","data":[2669,2565,5,0],"type":"resource","children":[{"count":1,"name":"State","debug":[[{"filename":"","line":0}]],"type":"resource","data":[2600,2553,5,0]},{"count":1,"debug":[[{"filename":"","line":0}]],"name":"And","data":[1,1,0,0],"type":"resource"},{"count":1,"debug":[[{"filename":"","line":0}]],"name":"Channel Read","data":[1,0,0,0],"type":"resource"},{"count":3,"debug":[[{"filename":"","line":0}]],"name":"Integer Compare","data":[33,3,0,0],"type":"resource"},{"count":1,"debug":[[{"filename":"","line":0}]],"name":"Non-Blocking Channel Write","data":[3,0,0,0],"type":"resource"},{"count":3,"debug":[[{"filename":"","line":0}]],"name":"Select","data":[31,8,0,0],"type":"resource"}]},{"name":"rgb_to_hsv.c:18","debug":[[{"filename":"rgb_to_hsv.c","line":18}]],"replace_name":"true","type":"resource","data":[22,2,0,0],"children":[{"replace_name":true,"debug":[[{"filename":"rgb_to_hsv.c","line":18},{"filename":"C:/intelFPGA_lite/18.1/hls/include\\\\HLS/ac_int.h","line":1854},{"filename":"C:/intelFPGA_lite/18.1/hls/include\\\\HLS/ac_int.h","line":980}]],"name":"rgb_to_hsv.c:18 > ac_int.h:1854 > \\nac_int.h:980","type":"resource","data":[22,2,0,0],"children":[{"count":2,"name":"Integer Compare","debug":[[{"filename":"rgb_to_hsv.c","line":18}]],"type":"resource","data":[22,2,0,0]}]}]},{"name":"rgb_to_hsv.c:20","debug":[[{"filename":"rgb_to_hsv.c","line":20}]],"replace_name":"true","type":"resource","data":[11,1,0,0],"children":[{"replace_name":true,"debug":[[{"filename":"rgb_to_hsv.c","line":20},{"filename":"C:/intelFPGA_lite/18.1/hls/include\\\\HLS/ac_int.h","line":1854},{"filename":"C:/intelFPGA_lite/18.1/hls/include\\\\HLS/ac_int.h","line":980}]],"name":"rgb_to_hsv.c:20 > ac_int.h:1854 > \\nac_int.h:980","type":"resource","data":[11,1,0,0],"children":[{"count":1,"name":"Integer Compare","debug":[[{"filename":"rgb_to_hsv.c","line":20}]],"type":"resource","data":[11,1,0,0]}]}]},{"name":"rgb_to_hsv.c:23","debug":[[{"filename":"rgb_to_hsv.c","line":23}]],"replace_name":"true","type":"resource","data":[26.3333,5.33333,0,0],"children":[{"count":6,"name":"Select","debug":[[{"filename":"rgb_to_hsv.c","line":23}]],"type":"resource","data":[26.3333,5.33333,0,0]}]},{"name":"rgb_to_hsv.c:29","debug":[[{"filename":"rgb_to_hsv.c","line":29}]],"replace_name":"true","type":"resource","data":[11,1,0,0],"children":[{"replace_name":true,"debug":[[{"filename":"rgb_to_hsv.c","line":29},{"filename":"C:/intelFPGA_lite/18.1/hls/include\\\\HLS/ac_int.h","line":1854},{"filename":"C:/intelFPGA_lite/18.1/hls/include\\\\HLS/ac_int.h","line":980}]],"name":"rgb_to_hsv.c:29 > ac_int.h:1854 > \\nac_int.h:980","type":"resource","data":[11,1,0,0],"children":[{"count":1,"name":"Integer Compare","debug":[[{"filename":"rgb_to_hsv.c","line":29}]],"type":"resource","data":[11,1,0,0]}]}]},{"name":"rgb_to_hsv.c:34","debug":[[{"filename":"rgb_to_hsv.c","line":34}]],"replace_name":"true","type":"resource","data":[26.3333,5.33333,0,0],"children":[{"count":6,"name":"Select","debug":[[{"filename":"rgb_to_hsv.c","line":34}]],"type":"resource","data":[26.3333,5.33333,0,0]}]},{"name":"rgb_to_hsv.c:40","debug":[[{"filename":"rgb_to_hsv.c","line":40}]],"replace_name":"true","type":"resource","data":[22,2,0,0],"children":[{"replace_name":true,"debug":[[{"filename":"rgb_to_hsv.c","line":40},{"filename":"C:/intelFPGA_lite/18.1/hls/include\\\\HLS/ac_int.h","line":1854},{"filename":"C:/intelFPGA_lite/18.1/hls/include\\\\HLS/ac_int.h","line":980}]],"name":"rgb_to_hsv.c:40 > ac_int.h:1854 > \\nac_int.h:980","type":"resource","data":[22,2,0,0],"children":[{"count":2,"name":"Integer Compare","debug":[[{"filename":"rgb_to_hsv.c","line":40}]],"type":"resource","data":[22,2,0,0]}]}]},{"name":"rgb_to_hsv.c:45","debug":[[{"filename":"rgb_to_hsv.c","line":45}]],"replace_name":"true","type":"resource","data":[19.3333,5.33333,0,0],"children":[{"count":4,"name":"Select","debug":[[{"filename":"rgb_to_hsv.c","line":45}]],"type":"resource","data":[19.3333,5.33333,0,0]}]},{"name":"rgb_to_hsv.c:56","debug":[[{"filename":"rgb_to_hsv.c","line":56}]],"replace_name":"true","type":"resource","data":[12,1,0,0],"children":[{"count":1,"name":"8-bit Integer Subtract","debug":[[{"filename":"rgb_to_hsv.c","line":56}]],"type":"resource","data":[9,0,0,0]},{"count":1,"name":"Integer Compare","debug":[[{"filename":"rgb_to_hsv.c","line":56}]],"type":"resource","data":[3,1,0,0]}]},{"name":"rgb_to_hsv.c:68","debug":[[{"filename":"rgb_to_hsv.c","line":68}]],"replace_name":"true","type":"resource","data":[7.5,1.5,0,0],"children":[{"count":1,"name":"And","debug":[[{"filename":"rgb_to_hsv.c","line":68}]],"type":"resource","data":[1,1,0,0]},{"name":"rgb_to_hsv.c:68 > ac_int.h:2223 > \\nac_int.h:1838 > ac_int.h:973","debug":[[{"filename":"rgb_to_hsv.c","line":68},{"filename":"C:/intelFPGA_lite/18.1/hls/include\\\\HLS/ac_int.h","line":2223},{"filename":"C:/intelFPGA_lite/18.1/hls/include\\\\HLS/ac_int.h","line":1838},{"filename":"C:/intelFPGA_lite/18.1/hls/include\\\\HLS/ac_int.h","line":973}]],"replace_name":true,"children":[{"count":1,"name":"And","debug":[[{"filename":"rgb_to_hsv.c","line":68}]],"type":"resource","data":[0.5,0.5,0,0]},{"count":2,"name":"Integer Compare","debug":[[{"filename":"rgb_to_hsv.c","line":68}]],"type":"resource","data":[6,0,0,0]}],"data":[6.5,0.5,0,0],"type":"resource"}]},{"name":"rgb_to_hsv.c:69","debug":[[{"filename":"rgb_to_hsv.c","line":69}]],"replace_name":"true","type":"resource","data":[5,2,0,0],"children":[{"count":2,"name":"And","debug":[[{"filename":"rgb_to_hsv.c","line":69}]],"type":"resource","data":[2,2,0,0]},{"name":"rgb_to_hsv.c:69 > ac_int.h:2223 > \\nac_int.h:1838 > ac_int.h:973","debug":[[{"filename":"rgb_to_hsv.c","line":69},{"filename":"C:/intelFPGA_lite/18.1/hls/include\\\\HLS/ac_int.h","line":2223},{"filename":"C:/intelFPGA_lite/18.1/hls/include\\\\HLS/ac_int.h","line":1838},{"filename":"C:/intelFPGA_lite/18.1/hls/include\\\\HLS/ac_int.h","line":973}]],"replace_name":true,"children":[{"count":1,"name":"Integer Compare","debug":[[{"filename":"rgb_to_hsv.c","line":69}]],"type":"resource","data":[3,0,0,0]}],"data":[3,0,0,0],"type":"resource"}]},{"name":"rgb_to_hsv.c:70","debug":[[{"filename":"rgb_to_hsv.c","line":70}]],"replace_name":"true","type":"resource","data":[5,2,0,0],"children":[{"count":3,"name":"And","debug":[[{"filename":"rgb_to_hsv.c","line":70}]],"type":"resource","data":[2,2,0,0]},{"name":"rgb_to_hsv.c:70 > ac_int.h:2223 > \\nac_int.h:1838 > ac_int.h:973","debug":[[{"filename":"rgb_to_hsv.c","line":70},{"filename":"C:/intelFPGA_lite/18.1/hls/include\\\\HLS/ac_int.h","line":2223},{"filename":"C:/intelFPGA_lite/18.1/hls/include\\\\HLS/ac_int.h","line":1838},{"filename":"C:/intelFPGA_lite/18.1/hls/include\\\\HLS/ac_int.h","line":973}]],"replace_name":true,"children":[{"count":1,"name":"Integer Compare","debug":[[{"filename":"rgb_to_hsv.c","line":70}]],"type":"resource","data":[3,0,0,0]}],"data":[3,0,0,0],"type":"resource"}]},{"name":"rgb_to_hsv.c:71","debug":[[{"filename":"rgb_to_hsv.c","line":71}]],"replace_name":"true","type":"resource","data":[5.5,2.5,0,0],"children":[{"count":6,"name":"And","debug":[[{"filename":"rgb_to_hsv.c","line":71}]],"type":"resource","data":[2.5,2.5,0,0]},{"name":"rgb_to_hsv.c:71 > ac_int.h:2223 > \\nac_int.h:1838 > ac_int.h:973","debug":[[{"filename":"rgb_to_hsv.c","line":71},{"filename":"C:/intelFPGA_lite/18.1/hls/include\\\\HLS/ac_int.h","line":2223},{"filename":"C:/intelFPGA_lite/18.1/hls/include\\\\HLS/ac_int.h","line":1838},{"filename":"C:/intelFPGA_lite/18.1/hls/include\\\\HLS/ac_int.h","line":973}]],"replace_name":true,"children":[{"count":1,"name":"Integer Compare","debug":[[{"filename":"rgb_to_hsv.c","line":71}]],"type":"resource","data":[3,0,0,0]}],"data":[3,0,0,0],"type":"resource"}]},{"name":"rgb_to_hsv.c:72","debug":[[{"filename":"rgb_to_hsv.c","line":72}]],"replace_name":"true","type":"resource","data":[84,1,0,0],"children":[{"count":1,"name":"And","debug":[[{"filename":"rgb_to_hsv.c","line":72}]],"type":"resource","data":[1,1,0,0]},{"count":12,"name":"Select","debug":[[{"filename":"rgb_to_hsv.c","line":72}]],"type":"resource","data":[80,0,0,0]},{"name":"rgb_to_hsv.c:72 > ac_int.h:2223 > \\nac_int.h:1838 > ac_int.h:973","debug":[[{"filename":"rgb_to_hsv.c","line":72},{"filename":"C:/intelFPGA_lite/18.1/hls/include\\\\HLS/ac_int.h","line":2223},{"filename":"C:/intelFPGA_lite/18.1/hls/include\\\\HLS/ac_int.h","line":1838},{"filename":"C:/intelFPGA_lite/18.1/hls/include\\\\HLS/ac_int.h","line":973}]],"replace_name":true,"children":[{"count":1,"name":"Integer Compare","debug":[[{"filename":"rgb_to_hsv.c","line":72}]],"type":"resource","data":[3,0,0,0]}],"data":[3,0,0,0],"type":"resource"}]},{"name":"rgb_to_hsv.c:99","debug":[[{"filename":"rgb_to_hsv.c","line":99}]],"replace_name":"true","type":"resource","data":[9,0,0,0],"children":[{"count":1,"name":"8-bit Integer Subtract","debug":[[{"filename":"rgb_to_hsv.c","line":99}]],"type":"resource","data":[9,0,0,0]}]},{"name":"rgb_to_hsv.c:102","debug":[[{"filename":"rgb_to_hsv.c","line":102}]],"replace_name":"true","type":"resource","data":[973,486,5,7.5],"children":[{"count":1,"name":"32-bit Integer Add","debug":[[{"filename":"rgb_to_hsv.c","line":102}]],"type":"resource","data":[33,0,0,0]},{"count":1,"name":"32-bit Integer Divide","debug":[[{"filename":"rgb_to_hsv.c","line":102}]],"type":"resource","data":[933,486,5,7.5]},{"name":"rgb_to_hsv.c:102 > ac_int.h:1490 > \\nac_int.h:1089 > ac_int.h:593","debug":[[{"filename":"rgb_to_hsv.c","line":102},{"filename":"C:/intelFPGA_lite/18.1/hls/include\\\\HLS/ac_int.h","line":1490},{"filename":"C:/intelFPGA_lite/18.1/hls/include\\\\HLS/ac_int.h","line":1089},{"filename":"C:/intelFPGA_lite/18.1/hls/include\\\\HLS/ac_int.h","line":593}]],"replace_name":true,"children":[{"count":1,"name":"Select","debug":[[{"filename":"rgb_to_hsv.c","line":102}]],"type":"resource","data":[7,0,0,0]}],"data":[7,0,0,0],"type":"resource"}]},{"name":"rgb_to_hsv.c:104","debug":[[{"filename":"rgb_to_hsv.c","line":104}]],"replace_name":"true","type":"resource","data":[25,0,0,0],"children":[{"replace_name":true,"debug":[[{"filename":"rgb_to_hsv.c","line":104},{"filename":"C:/intelFPGA_lite/18.1/hls/include\\\\HLS/ac_int.h","line":2226},{"filename":"C:/intelFPGA_lite/18.1/hls/include\\\\HLS/ac_int.h","line":1579},{"filename":"C:/intelFPGA_lite/18.1/hls/include\\\\HLS/ac_int.h","line":790}]],"name":"rgb_to_hsv.c:104 > ac_int.h:2226 > \\nac_int.h:1579 > ac_int.h:790","type":"resource","data":[25,0,0,0],"children":[{"count":1,"name":"17-bit Integer Subtract","debug":[[{"filename":"rgb_to_hsv.c","line":104}]],"type":"resource","data":[18,0,0,0]},{"count":1,"name":"Select","debug":[[{"filename":"rgb_to_hsv.c","line":104}]],"type":"resource","data":[7,0,0,0]}]}]},{"name":"rgb_to_hsv.c:106","debug":[[{"filename":"rgb_to_hsv.c","line":106}]],"replace_name":"true","type":"resource","data":[33,0,0,0],"children":[{"replace_name":true,"debug":[[{"filename":"rgb_to_hsv.c","line":106},{"filename":"C:/intelFPGA_lite/18.1/hls/include\\\\HLS/ac_int.h","line":2226},{"filename":"C:/intelFPGA_lite/18.1/hls/include\\\\HLS/ac_int.h","line":1573},{"filename":"C:/intelFPGA_lite/18.1/hls/include\\\\HLS/ac_int.h","line":785}]],"name":"rgb_to_hsv.c:106 > ac_int.h:2226 > \\nac_int.h:1573 > ac_int.h:785","type":"resource","data":[33,0,0,0],"children":[{"count":1,"name":"32-bit Integer Add","debug":[[{"filename":"rgb_to_hsv.c","line":106}]],"type":"resource","data":[33,0,0,0]}]}]}],"total_percent":[15.9449,10.7301,6.282,6.59341,5.55556],"type":"function","details":[{"text":"Number of compute units: 1","type":"text"}],"compute_units":1}],"data":[3973.9999,3140.99999,12,7.5],"total_percent":[15.9449,10.7301,6.282,6.59341,5.55556],"total":[3974,3141,12,8],"debug_enabled":"true","columns":["","ALUTs","FFs","RAMs","DSPs","Details"],"type":"module"}';
var mavJSON='{"nodes":[{"type":"component", "id":2, "name":"rgb_to_hsv", "children":[{"type":"bb", "id":3, "name":"rgb_to_hsv.B0.runOnce", "details":[{"type":"table", "Latency":"2"}]}, {"type":"bb", "id":4, "name":"rgb_to_hsv.B1.start", "children":[{"type":"inst", "id":5, "name":"Channel Read", "debug":[[{"filename":"", "line":0}]], "details":[{"type":"table", "Width":"32 bits", "Depth":"0", "Stall-free":"No", "Start Cycle":"1", "Latency":"0", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Channels", "link":"https://www.altera.com/documentation/mwh1391807516407.html#qah1476410829821"}]}]}]}, {"type":"inst", "id":7, "name":"Non-Blocking Channel Write", "debug":[[{"filename":"", "line":0}]], "details":[{"type":"table", "Width":"32 bits", "Depth":"0", "Stall-free":"No", "Start Cycle":"55", "Latency":"0", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Channels", "link":"https://www.altera.com/documentation/mwh1391807516407.html#qah1476410829821"}]}]}]}, {"type":"inst", "id":9, "name":"loop", "details":[{"type":"table", "Start Cycle":"0", "Latency":"1", "Loops To":"10"}]}, {"type":"inst", "id":10, "name":"loop end", "details":[{"type":"table", "Start Cycle":"1", "Latency":"1"}]}], "details":[{"type":"table", "Latency":"1", "II":"1", "Subloops":"No", "Pipelined":"Yes", "Fmax Bottlenecks":"No", "Loop Info":""}]}]}, {"type":"stream", "id":6, "name":"do", "debug":[[{"filename":"rgb_to_hsv.c", "line":13}]], "details":[{"type":"table", "Width":"32 bits", "Depth":"0", "Bits per symbol":"32 bits", "Uses Packets":"No", "Uses Valid":"Yes"}]}, {"type":"stream", "id":8, "name":"return1", "debug":[[{"filename":"rgb_to_hsv.c", "line":13}]], "details":[{"type":"table", "Width":"32 bits", "Depth":"0", "Bits per symbol":"32 bits", "Uses Packets":"No", "Uses Ready":"No"}]}, {"type":"interface", "id":13, "name":"blue", "debug":[[{"filename":"rgb_to_hsv.c", "line":13}]], "details":[{"type":"table", "Stable":"No", "Width":"8 bits", "Component":"rgb_to_hsv"}]}, {"type":"interface", "id":12, "name":"green", "debug":[[{"filename":"rgb_to_hsv.c", "line":13}]], "details":[{"type":"table", "Stable":"No", "Width":"8 bits", "Component":"rgb_to_hsv"}]}, {"type":"interface", "id":11, "name":"red", "debug":[[{"filename":"rgb_to_hsv.c", "line":13}]], "details":[{"type":"table", "Stable":"No", "Width":"8 bits", "Component":"rgb_to_hsv"}]}, {"type":"interface", "id":14, "name":"s", "debug":[[{"filename":"rgb_to_hsv.c", "line":13}]], "details":[{"type":"table", "Stable":"No", "Width":"8 bits", "Component":"rgb_to_hsv"}]}], "links":[{"from":6, "to":5}, {"from":7, "to":8}, {"from":11, "to":5}, {"from":12, "to":5}, {"from":13, "to":5}, {"from":14, "to":5}, {"from":10, "to":9}, {"from":3, "to":9}, {"from":5, "to":10}, {"from":7, "to":10}, {"from":9, "to":5}, {"from":5, "to":7}]}';
var lmvJSON='{"nodes":[{"type":"interface", "id":13, "name":"blue", "debug":[[{"filename":"rgb_to_hsv.c", "line":13}]], "details":[{"type":"table", "Stable":"No", "Width":"8 bits", "Component":"rgb_to_hsv"}]}, {"type":"interface", "id":12, "name":"green", "debug":[[{"filename":"rgb_to_hsv.c", "line":13}]], "details":[{"type":"table", "Stable":"No", "Width":"8 bits", "Component":"rgb_to_hsv"}]}, {"type":"interface", "id":11, "name":"red", "debug":[[{"filename":"rgb_to_hsv.c", "line":13}]], "details":[{"type":"table", "Stable":"No", "Width":"8 bits", "Component":"rgb_to_hsv"}]}, {"type":"interface", "id":14, "name":"s", "debug":[[{"filename":"rgb_to_hsv.c", "line":13}]], "details":[{"type":"table", "Stable":"No", "Width":"8 bits", "Component":"rgb_to_hsv"}]}], "links":[]}';
var loopsJSON='{"columns":["", "Pipelined", "II", "Bottleneck", "Details"], "children":[{"name":"Component: rgb_to_hsv", "data":["", "", ""], "debug":[[{"filename":"rgb_to_hsv.c", "line":13}]], "details":[{"type":"brief", "text":"Task function"}, {"type":"text", "text":"Task function"}], "children":[{"name":"rgb_to_hsv.B1.start", "data":["Yes", "~1", "n/a"], "debug":[[{"filename":"Component invocation", "line":0}]], "details":[{"type":"brief", "text":"II is an approximation."}, {"type":"text", "text":"Run simulation to verify component\'s dynamic II. Use the %L report to view results. II is an approximation due to the following stallable instruction:", "links":[{"view":"Verification statistics"}], "details":[{"type":"text", "text":"Stream Read Operation (%L)", "links":[{"filename":"Unknown location", "line":"0"}]}]}], "children":[]}]}]}';
var summaryJSON='{"estimatedResources":{"name":"Estimated Resource Usage", "columns":["Component Name", "ALUTs ", "FFs  ", "RAMs ", "DSPs "], "children":[{"name":"rgb_to_hsv", "data":[3974, 3141, 12, 7.5], "debug":[[{"filename":"rgb_to_hsv.c", "line":13}]]}, {"name":"Total", "classes":["summary-highlight", "nohover"], "data":[3974, 3141, 12, 7], "data_percent":[10.7301, 6.282, 6.59341, 5.55556]}, {"name":"Available", "classes":["summary-highlight", "nohover"], "data":[37036, 50000, 182, 144]}]}, "compileWarnings":{"name":"Compile Warnings", "children":[]}}';
var infoJSON='{"name":"Info","rows":[{"name":"Project Name","data":["./a"],"classes":["info-table"]},{"name":"Target Family, Device","data":["MAX 10, 10M50DAF672I7G"]},{"name":"i++ Version","data":["18.1.0 Build 625"]},{"name":"Quartus Version","data":["18.1.0 Build 625"]},{"name":"Command","data":["i++ rgb_to_hsv.c -march=Max10 --simulator none --fpga-only -v"]},{"name":"Reports Generated At", "data":["Tue Jun  6 22:19:02 2023"]}]}';
var warningsJSON='{"rows":[]}';
var quartusJSON='{"quartusFitClockSummary":{"name":"Quartus Fit Summary","children":[{"name":"Run Quartus compile to populate this section. See details for more information.","details":[{"type":"text", "text":"This section contains a summary of the area and fmax data generated by compiling the components through Quartus.  To generate the data, run a Quartus compile on the project created for this design. To run the Quartus compile:\\n  1) Change to the quartus directory (./a.prj/quartus)\\n  2) quartus_sh --flow compile quartus_compile\\n"}]}]}}';
var fileJSON=[{"path":"C:/intelFPGA_lite/18.1/hls/include/HLS/ac_int.h", "name":"ac_int.h", "has_active_debug_locs":true, "absName":"c:/intelFPGA_lite/18.1/hls/include/HLS/ac_int.h", "content":"/**************************************************************************\012 *                                                                        *\012 *  Algorithmic C (tm) Datatypes                                          *\012 *                                                                        *\012 *  Software Version: 3.7                                                 *\012 *                                                                        *\012 *  Release Date    : Wed Jun  1 13:21:52 PDT 2016                        *\012 *  Release Type    : Production Release                                  *\012 *  Release Build   : 3.7.0                                               *\012 *                                                                        *\012 *  Copyright 2004-2016, Mentor Graphics Corporation,                     *\012 *                                                                        *\012 *  All Rights Reserved.                                                  *\012 *                                                                        *\012 **************************************************************************\012 *  Licensed under the Apache License, Version 2.0 (the \"License\");       *\012 *  you may not use this file except in compliance with the License.      *\012 *  You may obtain a copy of the License at                               *\012 *                                                                        *\012 *      http://www.apache.org/licenses/LICENSE-2.0                        *\012 *                                                                        *\012 *  Unless required by applicable law or agreed to in writing, software   *\012 *  distributed under the License is distributed on an \"AS IS\" BASIS,     *\012 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or       *\012 *  implied.                                                              *\012 *  See the License for the specific language governing permissions and   *\012 *  limitations under the License.                                        *\012 **************************************************************************\012 *                                                                        *\012 *  This file was modified by the Intel High Level Design team to         *\012 *  generate efficient hardware for the Intel High Level Synthesis        *\012 *  compiler. The API remains the same as defined by Mentor Graphics      *\012 *  in the documentation for ac_int.h                                     *\012 *                                                                        *\012 *************************************************************************/\012\012/*\012//  Source:          ac_int.h\012//  Description:     fast arbitrary-length bit-accurate integer types:\012//                     - unsigned integer of length W:  ac_int<W,false>\012//                     - signed integer of length W:  ac_int<W,true>\012//  Original Author: Andres Takach, Ph.D.\012//  Modified by:     Vince Bridgers, Thor Thayer, Ajaykumar Kannan\012//\012//  Notes:\012//   - Compiler support: Works with the Intel i++ compiler. For g++, use the\012//                       original ac_int.h header file.\012//\012//   - Most frequent migration issues:\012//      - need to cast to common type when using question mark operator:\012//          (a < 0) ? -a : a;  // a is ac_int<W,true>\012//        change to:\012//          (a < 0) ? -a : (ac_int<W+1,true>) a;\012//        or\012//          (a < 0) ? (ac_int<W+1,false>) -a : (ac_int<W+1,false>) a;\012//\012//      - left shift is not arithmetic (\"a<<n\" has same bitwidth as \"a\")\012//          ac_int<W+1,false> b = a << 1;  // a is ac_int<W,false>\012//        is not equivalent to b=2*a. In order to get 2*a behavior change to:\012//          ac_int<W+1,false> b = (ac_int<W+1,false>)a << 1;\012//\012//      - only static length read/write slices are supported:\012//         - read:  x.slc<4>(k) => returns ac_int for 4-bit slice x(4+k-1 DOWNTO k)\012//         - write: x.set_slc(k,y) = writes bits of y to x starting at index k\012*/\012\012#ifndef __ALTR_AC_INT_H\012#define __ALTR_AC_INT_H\012\012#ifndef __INTELFPGA_COMPILER__\012#include \"ref/ac_int.h\"\012#else\012\012#define AC_VERSION 3\012#define AC_VERSION_MINOR 7\012\012#ifndef __cplusplus\012#error C++ is required to include this header file\012#endif\012\012// for safety\012#if (defined(W) || defined(I) || defined(S) || defined(W2) || defined(I2) || defined(S2))\012#error One or more of the following is defined: W, I, S, W2, I2, S2. Definition conflicts with their usage as template parameters.\012#error DO NOT use defines before including third party header files.\012#endif\012\012#if (defined(true) || defined(false))\012#error One or more of the following is defined: true, false. They are keywords in C++ of type bool. Defining them as 1 and 0, may result in subtle compilation problems.\012#error DO NOT use defines before including third party header files.\012#endif\012\012#ifndef __ASSERT_H__\012#define __ASSERT_H__\012#include <assert.h>\012#endif\012#include <limits>\012#ifndef AC_USER_DEFINED_ASSERT\012#if defined (__linux__)\012#include <iostream>\012#else\012#include <stdio.h>\012#endif // linux\012#else\012#if defined (__linux__)\012#include <ostream>\012#endif // linux\012#endif\012#include <algorithm>\012#include <HLS/math.h>\012#include <string>\012#include <vector>\012\012#ifdef __AC_NAMESPACE\012namespace __AC_NAMESPACE {\012#endif\012\012#define AC_MAX(a,b) ((a) > (b) ? (a) : (b))\012#define AC_MIN(a,b) ((a) < (b) ? (a) : (b))\012#define AC_ABS(a) ((a) < 0 ? (-a) : (a))\012\012#if defined(_MSC_VER)\012typedef unsigned __int64 Ulong;\012typedef signed   __int64 Slong;\012#else\012typedef unsigned long long Ulong;\012typedef signed   long long Slong;\012#endif\012\012#define _STR_CONCAT_(a,b) a##b\012#define _STR_CONCAT(a,b) _STR_CONCAT_(a,b)\012#define ACINT_STATIC_ASSERT(X) \\\012  ;typedef int _STR_CONCAT(static_assert_line_, __LINE__)[(bool)(X) ? 1 : -1];\012\012enum ac_base_mode { AC_BIN=2, AC_OCT=8, AC_DEC=10, AC_HEX=16 };\012enum ac_special_val {AC_VAL_DC, AC_VAL_0, AC_VAL_MIN, AC_VAL_MAX, AC_VAL_QUANTUM};\012\012template <int W, bool S> class ac_int;\012\012namespace ac_private {\012\012  enum {long_w = std::numeric_limits<unsigned long>::digits};\012\012  // PRIVATE FUNCTIONS in namespace: for implementing ac_int/ac_fixed\012\012  inline double mgc_floor(double d) { return floor(d); }\012\012  #define AC_ASSERT(cond, msg) ac_private::ac_assert(cond, __FILE__, __LINE__, msg)\012  inline void ac_assert(bool condition, const char *file=0, int line=0, const char *msg=0) {\012  #ifdef HLS_X86\012    #ifndef AC_USER_DEFINED_ASSERT\012    if(!condition) {\012#if defined (__linux__)\012      std::cerr << \"Assert\";\012      if(file)\012        std::cerr << \" in file \" << file << \":\" << line;\012      if(msg)\012        std::cerr << \" \" << msg;\012      std::cerr << std::endl;\012#else\012      fprintf(stderr, \"Assert\");\012      if (file)\012        fprintf(stderr, \" in file %s:%d\", file, line);\012      if (msg)\012        fprintf(stderr, \" %s\", msg);\012      fprintf(stderr, \"\\n\");\012#endif // linux\012      assert(0);\012    }\012    #else\012    AC_USER_DEFINED_ASSERT(condition, file, line, msg);\012    #endif\012  #endif\012  }\012\012  // helper structs for statically computing log2 like functions (nbits, log2_floor, log2_ceil)\012  //   using recursive templates\012  template<unsigned char N>\012  struct s_N {\012    template<unsigned X>\012    struct s_X {\012      enum {\012        X2 = X >> N,\012        N_div_2 = N >> 1,\012        nbits = X ? (X2 ? N + (int) s_N<N_div_2>::template s_X<X2>::nbits : (int) s_N<N_div_2>::template s_X<X>::nbits) : 0\012      };\012    };\012  };\012  template<> struct s_N<0> {\012    template<unsigned X>\012    struct s_X {\012      enum {nbits = !!X };\012    };\012  };\012\012  template<int N>\012  inline double ldexpr32(double d) {\012    double d2 = d;\012    if(N < 0)\012      for(int i=0; i < -N; i++)\012        d2 /= (Ulong) 1 << 32;\012    else\012      for(int i=0; i < N; i++)\012        d2 *= (Ulong) 1 << 32;\012    return d2;\012  }\012  template<> inline double ldexpr32<0>(double d) { return d; }\012  template<> inline double ldexpr32<1>(double d) { return d * ((Ulong) 1 << 32); }\012  template<> inline double ldexpr32<-1>(double d) { return d / ((Ulong) 1 << 32); }\012  template<> inline double ldexpr32<2>(double d) { return (d * ((Ulong) 1 << 32)) * ((Ulong) 1 << 32); }\012  template<> inline double ldexpr32<-2>(double d) { return (d / ((Ulong) 1 << 32)) / ((Ulong) 1 << 32); }\012\012  template<int N>\012  inline double ldexpr(double d) {\012    return ldexpr32<N/32>( N < 0 ? d/( (unsigned) 1 << (-N & 31)) : d * ( (unsigned) 1 << (N & 31)));\012  }\012\012  template<int N>\012  inline double ldexpr1(double d) {\012    return  N < 0 ? d/( (unsigned) 1 << (-N)) : d * ( (unsigned) 1 << (N));\012  }\012\012  // Xn-1, Xn-2, Xn-3, Xn-4, ...X(I+W-1)..XI.., X2, X1, X0\012  template<int W, int I, int N>\012  inline ap_uint<W> bit_slc(ap_uint<N> value) {\012    ACINT_STATIC_ASSERT(N >= W);\012    const int shift_v = AC_MIN(I, N-1);\012    ap_uint<N> op = (value >> (shift_v ));\012    ap_uint<W> r = op; \012    return r;\012  }\012\012  template<int W, int I, int N>\012  inline ap_int<W> bit_slc(ap_int<N> value) {\012    ap_uint<N> v = value;\012    return (ap_uint<W>)(bit_slc<W, I, N>(v));\012  }\012\012  template<int N>\012  inline bool ap_less_zero(ap_uint<N> value){\012    return false;\012  }\012\012  template<int N>\012  inline bool ap_less_zero(ap_int<N> value){\012    return value < 0;\012  }\012\012  // if bits [0, B-1] all 0s\012  template<int B, int N>\012  inline bool ap_equal_zeros_to(ap_uint<N> value) {\012    ap_uint<B> v = bit_slc<B, 0, N>(value);\012    return v == 0;\012  }\012\012  template<int B, int N>\012  inline bool ap_equal_zeros_to(ap_int<N> value) {\012    ap_uint<N> v = value;\012    return ap_equal_zeros_to<B, N>(v);\012  }\012\012  // if bits [0, B-1] all 0s\012  template<int B, int N>\012  inline bool ap_equal_ones_to(ap_uint<N> value) {\012    ACINT_STATIC_ASSERT(N >= B);\012    if(!B) return true;\012    const int B1 = AC_MAX(B, 1);\012    ap_uint<B1> v = bit_slc<B1, 0, N>(value);\012    return (~v) == 0;\012  }\012\012  template<int B, int N>\012  inline bool ap_equal_ones_to(ap_int<N> value) {\012    ap_uint<N> v = value;\012    return ap_equal_ones_to<B, N>(v);\012  }\012\012  // if bits [B, N-1] are all ones\012  template<int B, int N>\012  inline bool ap_equal_zeros_from(ap_uint<N> value) {\012    const int L = AC_MAX(N - B, 1);\012    ap_uint<L> v = bit_slc<L, B, N>(value);\012    return v == 0;\012  }\012\012  template<int B, int N>\012  inline bool ap_equal_zeros_from(ap_int<N> value) {\012    ap_uint<N> v = value;\012    return ap_equal_zeros_from<B, N>(v);\012  }\012\012  template<int B, int N>\012  inline bool ap_equal_ones_from(ap_uint<N> value) {\012    const int L = AC_MAX(N - B, 1);\012    ap_uint<L> v = bit_slc<L, B, N>(value);\012    return (~v) == 0;\012  }\012\012  template<int B, int N>\012  inline bool ap_equal_ones_from(ap_int<N> value) {\012    ap_uint<N> v = value;\012    return ap_equal_ones_from<B, N>(v);\012  }\012\012  // Build an ap_int from double d, value is d * 2 ^ N\012  // Notice: in ref, it's d * 2 ^ (32 * N)\012  template<int N, bool S>\012  inline void ap_conv_from_fraction(double d, ap_int<N> & r, bool *qb, bool *rbits, bool *o, int *io) {\012    bool b = d < 0;\012    double d2 = b ? -d : d; \012    double dfloor = mgc_floor(d2);\012    *o = dfloor != 0.0;  \012    d2 = d2 - dfloor;\012    const int shift_amount = N  + 1;\012    const int container_length = (shift_amount + 31)/32 * 32 + 1;\012    ap_int<N + 1> tb;\012    ap_uint<container_length> k1;\012    const Ulong u64_1 = 1;\012    //for performance purpose, manually unroll the loop when shift_amount <= 64\012    if(shift_amount <= 32){\012      d2 *= u64_1 << shift_amount;\012      k1 = (unsigned int)floor(d2);\012      tb = b ? ~k1 : k1;\012      d2 -= k1;\012    }\012    else if(shift_amount <= 64){\012      d2 *= u64_1 << 32;\012      unsigned int temp = (unsigned int)floor(d2);\012      k1 = temp;\012      d2 -= temp;\012      const int shift_next = AC_MAX(shift_amount - 32, 0);\012      d2 *= u64_1 << shift_next;\012      temp = (unsigned int)floor(d2);\012      k1 <<= shift_next;\012      k1 |= temp;\012      d2 -= temp;\012      tb = b? ~k1 : k1;\012    }\012    else {\012      k1 = 0;\012      int to_shift = shift_amount;\012      unsigned int temp;\012      while(to_shift >= 32){\012        to_shift -= 32;\012        d2 *= u64_1 << 32;\012        temp = (unsigned int)floor(d2);\012        k1 <<= 32;\012        k1 |= temp;\012        d2 -= temp;\012      }\012      const int shift_next = AC_MAX(to_shift % 32, 0);\012      d2 *= u64_1 << shift_next;\012      temp = (unsigned int)floor(d2);\012      k1 <<= shift_next;\012      k1 |= temp;\012      d2 -= temp;\012      tb = b? ~k1 : k1;\012    }\012\012    r = tb;\012    d2 *= 2;\012    bool k = (int(d2)) != 0; //math\012    d2 -= k ? 1.0 : 0.0;\012    *rbits = d2 != 0.0;\012    *qb = (b && *rbits) ^ k;\012    if(b && !*rbits && !*qb){\012      r +=1;\012    }\012    *io = 0;\012    bool cond1 = !ap_equal_zeros_from<N>(k1);\012    if(!S){\012      if(b) *io = -1;\012      else if(cond1) *io = 1;   \012    } else{\012      //             |    | N - 1 bits digi_bits\012      //             |Sbit|\012      // cond1: not 0|X   |.........: inner overflow\012      // cond2      0|1   |000000000: not inner overflow, *io = -2\012      // cond3:     0|1   |not all 0: inner overflow\012      if(b){\012        bool sign_bit = bit_slc<1, N-1>(k1);\012        bool digi_bits_zero = ap_equal_zeros_to<N-1>(k1);\012        if(cond1) *io = -1; // cond1\012        else if(sign_bit){\012          if(digi_bits_zero) *io = -2; // cond2\012          else *io = -1; // cond3\012        }\012      } else{\012        if(!ap_equal_zeros_from<N-1>(k1)) *io = 1;\012      }\012    }\012    *o |= b ^ (( tb < 0) && S);      \012  }\012  template<int N, bool S>\012  inline void ap_conv_from_fraction(double d, ap_uint<N> & r, bool *qb, bool *rbits, bool *o, int *io) { \012    ap_int< N > r1;\012    ap_conv_from_fraction<N, S>(d, r1, qb, rbits, o, io);\012    r = r1;\012  }\012\012  inline Ulong mult_u_u(int a, int b) {\012    return (Ulong) (unsigned) a * (Ulong) (unsigned) b;\012  }\012  inline Slong mult_u_s(int a, int b) {\012    return (Ulong) (unsigned) a * (Slong) (signed) b;\012  }\012  inline Slong mult_s_u(int a, int b) {\012    return (Slong) (signed) a * (Ulong) (unsigned) b;\012  }\012  inline Slong mult_s_s(int a, int b) {\012    return (Slong) (signed) a * (Slong) (signed) b;\012  }\012  inline void accumulate(Ulong a, Ulong &l1, Slong &l2) {\012    l1 += (Ulong) (unsigned) a;\012    l2 += a >> 32;\012  }\012  inline void accumulate(Slong a, Ulong &l1, Slong &l2) {\012    l1 += (Ulong) (unsigned) a;\012    l2 += a >> 32;\012  }\012\012  template<int N>\012  inline bool ap_uadd_carry(ap_uint<N> op, bool carry, ap_uint<N> & r) {\012    r += carry;\012    return carry && (r == 0);\012  }\012\012  template<int N>\012  inline bool ap_uadd_carry(ap_int<N> op, bool carry, ap_int<N> & r) {\012    ap_uint<N> ur = r;\012    bool ret =  ap_uadd_carry( (ap_uint<N>)(op), carry, ur);\012    r = ur;\012    return ret; \012  }\012\012  //Helper function for multiplication on x86\012  template <int N1, int N2>\012  inline ap_uint<N1 + N2> bit_multiply(ap_uint<N1> v1, ap_uint<N2> v2) {\012    ap_uint<N1 + N2 > x1 = v1;\012    ap_uint<N2 > x2 = v2;\012    \012    ap_uint<N1 + N2> r = 0;\012    while (x2 != 0) {\012      if (x2 & 1) {\012        r += x1;\012      }\012      x1 <<= 1;                 \012      x2 >>= 1;                 \012    }\012    return r;\012  }\012\012  //Helper function for pow on x86\012  template <int N, int P>\012  inline ap_uint<N * P> ap_int_pow(ap_uint<N> value) {\012    const int Nr = N * P;\012    ap_uint<Nr> base = value;\012    ap_uint<Nr> r = 1;\012    int pow = P;\012    while (pow > 0){\012      if( pow % 2 == 0){\012        pow /= 2;\012        base = bit_multiply<Nr, Nr>(base, base);\012      } else {\012        pow -= 1;\012        r = bit_multiply<Nr, Nr>(r, base);\012        pow /= 2;\012        base = bit_multiply<Nr, Nr>(base, base);\012      }\012    }\012    return r;\012  }\012\012  //Helper function for large divisions on x86\012  template <int N>\012  inline ap_uint<N> bit_division(ap_uint<N> value, ap_uint<N> divisor, ap_uint<N> & remainder) {\012    ap_uint<N> quotient = 1;\012    ap_uint<N> tempdivisor = divisor;\012    if (value == tempdivisor) {\012      remainder = 0;\012      return 1;\012    } else if (value < tempdivisor) {\012      remainder = value;\012      return 0;\012    }\012    while ((tempdivisor << 1) <= value){\012      tempdivisor = tempdivisor << 1;\012      quotient = quotient << 1;\012    }\012    quotient = quotient + bit_division(value - tempdivisor, divisor, remainder);\012    return quotient;\012  }\012\012  template <int N>\012  inline ap_uint<N> bit_division(ap_uint<N> value, ap_uint<N> divisor) {\012    ap_uint<N> r = 0;\012    return bit_division<N>(value, divisor, r);\012  }\012\012  template <int N>\012  inline std::string to_string(ap_uint<N> value, int base) {\012    std::string buf = \"\";\012\012    if (base < 2 || base > 16) return buf;\012\012    enum { kMaxDigits = 35 };\012    buf.reserve(kMaxDigits);\012\012    const int N_bits = AC_MAX(N + 1, 5);\012    ap_uint<N_bits> quotient = value;\012    int mod;\012    ap_uint<N_bits> b = base;\012    do {\012      ap_uint<N_bits> r = 0;\012      quotient = bit_division<N_bits>(quotient, b, r);\012      mod = (int)(r);\012      buf += \"0123456789abcdef\"[ mod ];\012    } while (quotient);\012\012    std::reverse(buf.begin(), buf.end());\012    return buf;\012  }\012\012  template <int N>\012  inline std::string to_string_u(ap_uint<N> value, int base) {\012    return to_string(value,base);\012  }\012\012  template <int N>\012  inline std::string to_string(ap_int<N> value, int base) {\012    ap_int<N + 1> v = value;\012    if(value >= 0){\012      ap_uint<N + 1> t = v;\012      return to_string(t, base);\012    } else {\012      ap_uint<N + 1> t = -v;\012      return \"-\" + to_string(t, base);\012    }\012  }\012\012  template<int W, bool S> struct select_type {};\012\012  // The i++ flow type selections ...\012  template<int W>\012  struct select_type<W, true> {\012    typedef ap_int<W> type;\012  };\012\012  template<int W>\012  struct select_type<W, false> {\012    typedef ap_uint<W> type;\012  };\012\012  //////////////////////////////////////////////////////////////////////////////\012  //  Integer Vector class: iv\012  //////////////////////////////////////////////////////////////////////////////\012  template<int N, bool S>\012  class iv {\012  protected:\012    typedef typename select_type<N, S>::type actype;\012    actype value;\012  public:\012    template<int N2, bool S2> friend class iv;\012    iv() {}\012    template<int N2, bool S2>\012    iv ( const iv<N2, S2> &b ) {\012      value = b.value;\012    }\012    /* Note: char and short constructors are an extension to Calypto's\012       implementation to address the i++ default behaviour of not promoting\012       to integers. (these functions are not in Calypto's ac_int.h) */\012    iv ( char t) {\012      value = t;\012    }\012    iv ( unsigned char t) {\012      value = t;\012    }\012    iv ( short t) {\012      value = t;\012    }\012    iv ( unsigned short t) {\012      value = t;\012    }\012    iv ( Slong t) {\012      value = t;\012    }\012    iv ( Ulong t) {\012      value = t;\012    }\012    iv ( int t) {\012      value = t;\012    }\012    iv ( unsigned int t) {\012      value = t;\012    }\012    iv ( long t) {\012      value = t;\012    }\012    iv ( unsigned long t) {\012      value = t;\012    }\012    iv ( double d ) {\012      value = (actype) (long long)d;\012    }\012    iv ( float d ) {\012      value = (actype) (long long)d;\012    }\012\012    // Explicit conversion functions to C built-in types -------------\012    inline Slong to_int64() const {\012      return (Slong) value;\012    }\012    inline Ulong to_uint64() const {\012      return (Ulong) value;\012    }\012    inline double to_double() const {\012      volatile Slong t = (Slong) value;\012      return (double) (t);\012    }\012\012    std::string to_string(ac_base_mode mode) const {\012      return ac_private::to_string<N>(value, mode);\012    }\012\012    //BEGIN: debug functions for X86 flow\012    template<int N2, bool S2>\012    void debug_within_range(const iv<N2, S2> &op2){\012    #ifdef HLS_X86\012    #if defined(DEBUG_AC_INT_WARNING) || defined(DEBUG_AC_INT_ERROR)\012      enum {Nx = AC_MAX(N, N2 + 1) };\012      ap_int<N2 + 1> v = op2.value;\012      if(N2 + 1 <= N) return ;\012      // S -> S, check bits [N2 + 1, .. , N-1]\012      if(S){\012        if(ap_equal_ones_from<N - 1, N2 + 1>(v)) return ;\012        if(ap_equal_zeros_from<N - 1, N2 + 1>(v)) return ;\012      }\012      // S -> U, check bits [N2 + 1, .. , N]\012      else{\012        if(ap_equal_zeros_from<N, N2 + 1>(v)) return ;\012      }\012      #if defined (__linux__)\012      std::cout << \"warning: overflow, assign value \" \\\012      << ac_private::to_string(v, 10) \\\012      << \" to type ac_int<\" << N << \", \" << (S? \"true\" : \"false\") << \">\" \\\012      << std::endl;\012      #else\012      printf(\"warning: overflow, assign value %s to type ac_int<%d, %s>\\n\",\012        ac_private::to_string(v, 10).c_str(), N, S? \"true\" : \"false\");\012      #endif\012\012      #ifdef DEBUG_AC_INT_ERROR\012      AC_ASSERT(0, \"Assert due to overflow (DEBUG_AC_INT_ERROR)\");\012      #endif\012    #endif\012    #endif \012    }\012\012    void debug_within_range(Ulong v){\012      debug_within_range(iv<64, false>(v));\012    }\012\012    void debug_within_range(Slong v){\012      debug_within_range(iv<64, true>(v));\012    }\012    //END\012\012    // o: outer overflow\012    // io: inner overflow\012    // qb: qb\012    // rbits: r\012    inline void conv_from_fraction(double d, bool *qb, bool *rbits, bool *o, int *io) {\012      ap_conv_from_fraction<N, S>(d, value, qb, rbits, o, io);\012    }\012\012    // BEGIN: utility functions for x86\012    #define MAX_BITS 512\012    template<int Nr>\012    inline void decompose_usigned(ap_uint<Nr> a, std::vector<Ulong> & vec ) const {\012      while (a > 0){\012        Ulong mask = 0XFFFFFFFF; //use a variable to avoid compiler warning\012        int shift_amount = 32;\012        if(Nr <= 32){\012          // a is small\012          vec.push_back(a);\012          a = 0;\012        } else{\012          vec.push_back(a & mask);\012          a >>= shift_amount;\012        }\012      }\012    }\012\012    template<int Nr, bool Sr>\012    inline void compose_unsigned(iv<Nr, Sr> &r, std::vector<Ulong> & vec) const {\012      r = 0;\012      int shift_value = 32;\012      for(int i = vec.size() - 1; i >= 0; i--){\012        ap_uint<Nr> t = vec[i];\012        r.value <<= shift_value;\012        r.value += t;\012      }\012    }\012\012    template<int N2, bool S2, int Nr, bool Sr>\012    inline void mult_x86(const iv<N2, S2> &op2, iv<Nr, Sr> &r) const {\012\012      ap_int<N2 + 1> ext_v1 = op2.value;\012      ap_int<N + 1> ext_v2 = value;\012\012      bool sign1 = ext_v1 >= 0;\012      bool sign2 = ext_v2 >= 0;\012\012      ap_uint<N2 + 2> a1 = sign1 ? ext_v1: -ext_v1;\012      ap_uint<N + 2> a2 = sign2 ? ext_v2: -ext_v2;\012\012      bool ret_sign = ~(sign1 ^ sign2);\012\012      std::vector<Ulong> v1;\012      std::vector<Ulong> v2;\012\012      decompose_usigned<N2 + 2>(a1, v1);\012      decompose_usigned<N + 2>(a2, v2);\012\012      int shift_amount = 32;\012      Ulong base = 1ULL << shift_amount;\012\012      std::vector<Ulong> v3(v1.size() + v2.size());\012      for(unsigned i = 0; i < v1.size(); i++){\012        Ulong carry = 0;\012        for(unsigned j = 0; j < v2.size(); j++){\012          v3[i + j] += carry + v1[i] * v2[j];\012          carry = v3[i + j] / base;\012          v3[i + j] = v3[i + j] % base;\012        }\012        v3[i + v2.size()] += carry;\012      }\012\012      compose_unsigned(r, v3);\012      if(!ret_sign){\012        r.value = -r.value;\012      }\012    }\012\012    template<int Nr, bool Sr>\012    inline void shift_l_x86(unsigned shift, iv<Nr, Sr> &r) const {\012      int shift_amount = 64;\012      while(shift >= shift_amount){\012        r.value <<= shift_amount;\012        shift -= shift_amount;\012      }\012      if(shift){\012        r.value <<= shift;\012      }\012    }\012\012    template<int Nr, bool Sr>\012    inline void shift_r_x86(unsigned shift, iv<Nr, Sr> &r) const {\012      int shift_amount = 64;\012      iv<N, S> temp(*this);\012      while(shift >= shift_amount){\012        temp.value >>= shift_amount;\012        shift -= shift_amount;\012      }\012      if(shift){\012        temp.value >>= shift;\012      }\012      r.value = temp.value;\012    }\012    // END: utility functions for x86\012\012    template<int N2, bool S2, int Nr, bool Sr>\012    inline void mult(const iv<N2, S2> &op2, iv<Nr, Sr> &r) const {\012      ACINT_STATIC_ASSERT(N2 <= 512);\012      ACINT_STATIC_ASSERT(Nr <= 512);\012      #ifdef HLS_X86\012      mult_x86(op2, r);\012      #else\012      r.value = value;\012      r.value *= op2.value;\012      #endif\012    }\012    template<int N2, bool S2, int Nr, bool Sr>\012    void add(const iv<N2, S2> &op2, iv<Nr, Sr> &r) const {\012      r.value = value;\012      r.value += op2.value;\012    }\012    template<int N2, bool S2, int Nr, bool Sr>\012    void sub(const iv<N2, S2> &op2, iv<Nr, Sr> &r) const {\012      r.value = value;\012      r.value -= op2.value;\012    }\012    template<int N2, bool S2, int Nr, bool Sr>\012    void div(const iv<N2, S2> &op2, iv<Nr, Sr> &r) const {\012      ACINT_STATIC_ASSERT(N2 <= 64);\012      ACINT_STATIC_ASSERT(Nr <= 64);\012      typedef typename select_type<N2,S2>::type adivtype;\012      typedef typename select_type<Nr,Sr>::type bdivtype;\012      adivtype a = op2.value;\012      bdivtype b = value;\012      r.value = b/a;\012    }\012    template<int N2, bool S2, int Nr, bool Sr>\012    void rem(const iv<N2, S2> &op2, iv<Nr, Sr> &r) const {\012      r.value = value;\012      r.value %= op2.value;\012    }\012    void increment() {\012      value += 1;\012    }\012    void decrement() {\012      value -= 1;\012    }\012    template<int Nr, bool Sr>\012    void neg(iv<Nr, Sr> &r) const {\012      r.value = value;\012      r.value = -r.value;\012    }\012\012    // Shift Operators\012    template<int Nr, bool Sr>\012    void shift_l(unsigned op2, iv<Nr, Sr> &r) const {\012      if (op2 >= Nr) {\012        r.value = 0;\012      } else {\012        r.value = value;\012        #ifdef HLS_X86\012        shift_l_x86(op2, r);\012        #else\012        r.value <<= op2;\012        #endif\012      }\012    }\012\012#pragma clang diagnostic push\012#pragma clang diagnostic ignored \"-Wtautological-compare\"\012// Avoid a clang compiler warning below by temporarily suppressing\012// a autological-compare warning to keep the compiler output\012// tidy for the customer.\012//\012// warning: comparison of unsigned expression < 0 is always false [-Wtautological-compare]\012//      } else if ( (op2 >= Nr) && Sr && (value < 0) ) {\012//                                        ~~~~~ ^ ~\012// Note that since this expression is evaluated at compile time, the compiler\012// will throw a warning in the case the expression is always 0.\012// So just suppress it.\012//\012    template<int Nr, bool Sr>\012    void shift_l2(signed op2, iv<Nr, Sr> &r) const {\012      signed shift = abs(op2);\012      if (shift >= Nr) {\012        shift = Nr;\012      }\012\012      if (op2 > 0) {\012        if (shift == Nr) {\012          r.value = 0;\012        } else {\012          r.value = value;\012          #ifdef HLS_X86\012          shift_l_x86(shift, r);\012          #else\012          r.value <<= shift;\012          #endif\012        }\012      } else {\012        if (shift == Nr) {\012          if (value < 0) {\012            r.value = -1;\012          } else {\012            r.value = 0;\012          }\012        } else {\012          #ifdef HLS_X86\012          shift_r_x86(shift, r);\012          #else\012          r.value = value >> shift;\012          #endif\012        }\012      }\012    }\012#pragma clang diagnostic pop\012\012    template<int Nr, int Sr, int B>\012    void const_shift_l(iv<Nr, Sr> &r) const {\012      shift_l2<Nr, Sr>(B, r);\012    }\012\012#pragma clang diagnostic push\012#pragma clang diagnostic ignored \"-Wtautological-compare\"\012    template<int Nr, bool Sr>\012    void shift_r(unsigned op2, iv<Nr, Sr> &r) const {\012      if ( (op2 >= Nr) && ((Sr && (value > 0)) || !Sr) ) {\012        r.value = 0;\012      } else if ( (op2 >= Nr) && Sr && (value < 0) ) {\012        r.value = -1;\012      } else {\012        #ifdef HLS_X86\012          shift_r_x86(op2, r);\012        #else\012          r.value = value >> op2;\012        #endif\012      }\012    }\012\012    template<int Nr, bool Sr>\012    void shift_r2(signed op2, iv<Nr, Sr> &r) const {\012      signed shift = abs(op2);\012      const int Ns = AC_MAX(Nr, N);\012      if (shift >= Ns) {\012          shift = Ns;\012      }\012      if (op2 > 0) {\012        if (shift == Ns) {\012          if (value < 0) {\012            r.value = -1;\012          } else {\012            r.value = 0;\012          }\012        } else {\012          #ifdef HLS_X86\012            shift_r_x86(shift, r);\012          #else\012            r.value = value >> shift;\012          #endif\012        }\012      } else {\012        if (shift == Ns) {\012          r.value = 0;\012        } else {\012          r.value = value;\012          #ifdef HLS_X86\012          shift_l_x86(shift, r);\012          #else\012          r.value <<= shift;\012          #endif\012        }\012      }\012    }\012#pragma clang diagnostic pop\012\012    template<int Nr, bool Sr, int B>\012    void const_shift_r(iv<Nr, Sr> &r) const {\012      iv<Nr, Sr> t;\012      shift_r2<Nr, Sr>(B, t);\012      r = t;\012    }\012\012    template<int Nr, bool Sr>\012    void bitwise_complement(iv<Nr, Sr> &r) const {\012      r.value = value;\012      r.value = ~r.value;\012    }\012    template<int N2, bool S2, int Nr, bool Sr>\012    void bitwise_and(const iv<N2, S2> &op2, iv<Nr, Sr> &r) const {\012      r.value = value;\012      r.value &= op2.value;\012    }\012    template<int N2, bool S2, int Nr, bool Sr>\012    void bitwise_or(const iv<N2, S2> &op2, iv<Nr, Sr> &r) const {\012      r.value = value;\012      r.value |= op2.value;\012    }\012    template<int N2, bool S2, int Nr, bool Sr>\012    void bitwise_xor(const iv<N2, S2> &op2, iv<Nr, Sr> &r) const {\012      r.value = value;\012      r.value ^= op2.value;\012    }\012    template<int N2, bool S2>\012    bool equal(const iv<N2, S2> &op2) const {\012      enum {Sx = AC_MAX(N, N2) };\012      ap_int<Sx+1> a = (ap_int<Sx+1>)value;\012      ap_int<Sx+1> b = (ap_int<Sx+1>)op2.value;\012      return (a == b);\012    }\012    template<int N2, bool S2>\012    bool greater_than(const iv<N2, S2> &op2) const {\012      enum {Sx = AC_MAX(N, N2) };\012      ap_int<Sx+1> a = (ap_int<Sx+1>)value;\012      ap_int<Sx+1> b = (ap_int<Sx+1>)op2.value;\012      return (a > b);\012    }\012    template<int N2, bool S2>\012    bool less_than(const iv<N2, S2> &op2) const {\012      enum {Sx = AC_MAX(N, N2) };\012      ap_int<Sx+1> a = (ap_int<Sx+1>)value;\012      ap_int<Sx+1> b = (ap_int<Sx+1>)op2.value;\012      return (a < b);\012    }\012    bool equal_zero() const {\012      actype zero = 0;\012      return (value == zero);\012    }\012\012#pragma clang diagnostic push\012#pragma clang diagnostic ignored \"-Wshift-count-overflow\"\012    template<int N2, bool S2>\012    void set_slc(unsigned lsb, int WS, const iv<N2, S2> &op2) {\012      AC_ASSERT(N2<=N, \"Bad usage: WS greater than length of slice\");\012      if(N2 == N){\012        value = op2.value;\012      }\012      else if (N2 <= N) {\012        iv<N,S> temp;\012        temp.value = (actype) op2.value;\012        #ifdef HLS_X86\012        shift_l_x86(lsb, temp);\012        #else\012        temp.value <<= lsb;\012        #endif\012        // Compute AND mask\012        iv<N,S> mask;\012        mask.value = 1;\012        #ifdef HLS_X86\012        shift_l_x86(N2, mask);\012        #else\012        mask.value <<= N2;\012        #endif\012        mask.value -= 1;\012        #ifdef HLS_X86\012        shift_l_x86(lsb, mask);\012        #else\012        mask.value <<= lsb;\012        #endif\012\012        mask.value = ~mask.value;\012        value &= mask.value;\012        value |= temp.value;\012      } else {\012        value = 0;\012      }\012    }\012#pragma clang diagnostic pop\012\012    unsigned leading_bits(bool bit) const {\012      return 0;\012    }\012\012    template <int Nr, bool Sr>\012    void reverse(iv<Nr, Sr> &r) const {\012      r.value = 0;\012      for (int i = 0; i < N; i++) {\012        r.value |= ((value >> i) & 1) << ((N - 1) -i);\012      }\012    }\012  }; // class iv, signed\012\012  /* TODO\012  template<> inline Slong iv<1>::to_int64() const { return v[0]; }\012  template<> inline Ulong iv<1>::to_uint64() const { return v[0]; }\012\012  template<> inline Slong iv<2>::to_int64() const {\012    return ((Ulong)v[1] << 32) | (Ulong) (unsigned) v[0];\012  }\012  template<> inline Ulong iv<2>::to_uint64() const {\012    return ((Ulong)v[1] << 32) | (Ulong) (unsigned) v[0];\012  }\012\012  template<> template<> inline void iv<1>::set_slc(unsigned lsb, int WS, const iv<1> &op2) {\012    v[0] ^= (v[0] ^ (op2.v[0] << lsb)) & (~(WS==32 ? 0 : ~0<<WS) << lsb);\012  }\012  template<> template<> inline void iv<2>::set_slc(unsigned lsb, int WS, const iv<1> &op2) {\012    Ulong l = to_uint64();\012    Ulong l2 = op2.to_uint64();\012    l ^= (l ^ (l2 << lsb)) & (~((~(Ulong)0)<<WS) << lsb);  // WS <= 32\012    *this = l;\012  }\012  template<> template<> inline void iv<2>::set_slc(unsigned lsb, int WS, const iv<2> &op2) {\012    Ulong l = to_uint64();\012    Ulong l2 = op2.to_uint64();\012    l ^= (l ^ (l2 << lsb)) & (~(WS==64 ? (Ulong) 0 : ~(Ulong)0<<WS) << lsb);\012    *this = l;\012  }\012  */\012\012  // add automatic conversion to Slong/Ulong depending on S and C\012  template<int N, bool S, bool C>\012  class iv_conv : public iv<N, S> {\012  protected:\012    iv_conv() {}\012    template<class T> iv_conv(const T& t) : iv<N, S>(t) {}\012  };\012\012  template<int N>\012  class iv_conv<N,false,true> : public iv<N, false> {\012  public:\012    operator Ulong () const { return iv<N, false>::to_uint64(); }\012  protected:\012    iv_conv() {}\012    template<class T> iv_conv(const T& t) : iv<N, false>(t) {}\012  };\012\012  template<int N>\012  class iv_conv<N,true,true> : public iv<N, true> {\012  public:\012    operator Slong () const { return iv<N, true>::to_int64(); }\012  protected:\012    iv_conv() {}\012    template<class T> iv_conv(const T& t) : iv<N, true>(t) {}\012  };\012\012  // Set default to promote to int as this is the case for almost all types\012  //  create exceptions using specializations\012  template<typename T>\012  struct c_prom {\012    typedef int promoted_type;\012  };\012  template<> struct c_prom<unsigned> {\012    typedef unsigned promoted_type;\012  };\012  template<> struct c_prom<long> {\012    typedef long promoted_type;\012  };\012  template<> struct c_prom<unsigned long> {\012    typedef unsigned long promoted_type;\012  };\012  template<> struct c_prom<Slong> {\012    typedef Slong promoted_type;\012  };\012  template<> struct c_prom<Ulong> {\012    typedef Ulong promoted_type;\012  };\012  template<> struct c_prom<float> {\012    typedef float promoted_type;\012  };\012  template<> struct c_prom<double> {\012    typedef double promoted_type;\012  };\012\012  template<typename T, typename T2>\012  struct c_arith {\012     // will error out for pairs of T and T2 that are not defined through specialization\012  };\012  template<typename T> struct c_arith<T,T> {\012    typedef T arith_conv;\012  };\012\012  #define C_ARITH(C_TYPE1, C_TYPE2) \\\012  template<> struct c_arith<C_TYPE1, C_TYPE2> { \\\012    typedef C_TYPE1 arith_conv; \\\012  }; \\\012  template<> struct c_arith<C_TYPE2, C_TYPE1> { \\\012    typedef C_TYPE1 arith_conv; \\\012  };\012\012  C_ARITH(double, float)\012  C_ARITH(double, int)\012  C_ARITH(double, unsigned)\012  C_ARITH(double, long)\012  C_ARITH(double, unsigned long)\012  C_ARITH(double, Slong)\012  C_ARITH(double, Ulong)\012  C_ARITH(float, int)\012  C_ARITH(float, unsigned)\012  C_ARITH(float, long)\012  C_ARITH(float, unsigned long)\012  C_ARITH(float, Slong)\012  C_ARITH(float, Ulong)\012\012  C_ARITH(Slong, int)\012  C_ARITH(Slong, unsigned)\012  C_ARITH(Ulong, int)\012  C_ARITH(Ulong, unsigned)\012\012  template<typename T>\012  struct map {\012    typedef T t;\012  };\012  template<typename T>\012  struct c_type_params {\012    // will error out for T for which this template struct is not specialized\012  };\012\012  template<typename T> inline const char *c_type_name() { return \"unknown\"; }\012  template<> inline const char *c_type_name<bool>() { return \"bool\";}\012  template<> inline const char *c_type_name<char>() { return \"char\";}\012  template<> inline const char *c_type_name<signed char>() { return \"signed char\";}\012  template<> inline const char *c_type_name<unsigned char>() { return \"unsigned char\";}\012  template<> inline const char *c_type_name<signed short>() { return \"signed short\";}\012  template<> inline const char *c_type_name<unsigned short>() { return \"unsigned short\";}\012  template<> inline const char *c_type_name<int>() { return \"int\";}\012  template<> inline const char *c_type_name<unsigned>() { return \"unsigned\";}\012  template<> inline const char *c_type_name<signed long>() { return \"signed long\";}\012  template<> inline const char *c_type_name<unsigned long>() { return \"unsigned long\";}\012  template<> inline const char *c_type_name<signed long long>() { return \"signed long long\";}\012  template<> inline const char *c_type_name<unsigned long long>() { return \"unsigned long long\";}\012  template<> inline const char *c_type_name<float>() { return \"float\";}\012  template<> inline const char *c_type_name<double>() { return \"double\";}\012\012  template<typename T> struct c_type;\012\012  template<typename T>\012  struct rt_c_type_T {\012    template<typename T2>\012    struct op1 {\012      typedef typename T::template rt_T< c_type<T2> >::mult mult;\012      typedef typename T::template rt_T< c_type<T2> >::plus plus;\012      typedef typename T::template rt_T< c_type<T2> >::minus2 minus;\012      typedef typename T::template rt_T< c_type<T2> >::minus minus2;\012      typedef typename T::template rt_T< c_type<T2> >::logic logic;\012      typedef typename T::template rt_T< c_type<T2> >::div2 div;\012      typedef typename T::template rt_T< c_type<T2> >::div div2;\012    };\012  };\012  template<typename T>\012  struct c_type {\012    typedef typename c_prom<T>::promoted_type c_prom_T;\012    struct rt_unary {\012      typedef c_prom_T neg;\012      typedef c_prom_T mag_sqr;\012      typedef c_prom_T mag;\012      template<unsigned N>\012      struct set {\012        typedef c_prom_T sum;\012      };\012    };\012    template<typename T2>\012    struct rt_T {\012      typedef typename rt_c_type_T<T2>::template op1<T>::mult mult;\012      typedef typename rt_c_type_T<T2>::template op1<T>::plus plus;\012      typedef typename rt_c_type_T<T2>::template op1<T>::minus minus;\012      typedef typename rt_c_type_T<T2>::template op1<T>::minus2 minus2;\012      typedef typename rt_c_type_T<T2>::template op1<T>::logic logic;\012      typedef typename rt_c_type_T<T2>::template op1<T>::div div;\012      typedef typename rt_c_type_T<T2>::template op1<T>::div2 div2;\012    };\012    inline static std::string type_name() {\012      std::string r = c_type_name<T>();\012      return r;\012    }\012\012  };\012  // with T == c_type\012  template<typename T>\012  struct rt_c_type_T< c_type<T> > {\012    typedef typename c_prom<T>::promoted_type c_prom_T;\012    template<typename T2>\012    struct op1 {\012      typedef typename c_prom<T2>::promoted_type c_prom_T2;\012      typedef typename c_arith< c_prom_T, c_prom_T2 >::arith_conv mult;\012      typedef typename c_arith< c_prom_T, c_prom_T2 >::arith_conv plus;\012      typedef typename c_arith< c_prom_T, c_prom_T2 >::arith_conv minus;\012      typedef typename c_arith< c_prom_T, c_prom_T2 >::arith_conv minus2;\012      typedef typename c_arith< c_prom_T, c_prom_T2 >::arith_conv logic;\012      typedef typename c_arith< c_prom_T, c_prom_T2 >::arith_conv div;\012      typedef typename c_arith< c_prom_T, c_prom_T2 >::arith_conv div2;\012    };\012  };\012\012  #define C_TYPE_MAP(C_TYPE) \\\012  template<> struct map<C_TYPE> { \\\012    typedef c_type<C_TYPE> t; \\\012  };\012\012  #define C_TYPE_PARAMS(C_TYPE, WI, SI) \\\012  template<> struct c_type_params<C_TYPE> { \\\012    enum { W = WI, I = WI, E = 0, S = SI, floating_point = 0 }; \\\012  };\012\012  #define C_TYPE_MAP_INT(C_TYPE, WI, SI) \\\012    C_TYPE_MAP(C_TYPE) \\\012    C_TYPE_PARAMS(C_TYPE, WI, SI)\012\012  #define C_TYPE_MAP_FLOAT(C_TYPE, FP, WFP, IFP, EFP) \\\012  C_TYPE_MAP(C_TYPE) \\\012  template<> struct c_type_params<C_TYPE> { \\\012    enum { W = WFP, I = IFP, E = EFP, S = true, floating_point = FP }; \\\012  };\012\012  C_TYPE_MAP_INT(bool, 1, false)\012  C_TYPE_MAP_INT(char, 8, true)\012  C_TYPE_MAP_INT(signed char, 8, true)\012  C_TYPE_MAP_INT(unsigned char, 8, false)\012  C_TYPE_MAP_INT(signed short, 16, true)\012  C_TYPE_MAP_INT(unsigned short, 16, false)\012  C_TYPE_MAP_INT(signed int, 32, true)\012  C_TYPE_MAP_INT(unsigned int, 32, false)\012  C_TYPE_MAP_INT(signed long, ac_private::long_w, true)\012  C_TYPE_MAP_INT(unsigned long, ac_private::long_w, false)\012  C_TYPE_MAP_INT(signed long long, 64, true)\012  C_TYPE_MAP_INT(unsigned long long, 64, false)\012  C_TYPE_MAP_FLOAT(float, 1, 25, 1, 8)\012  C_TYPE_MAP_FLOAT(double, 2, 54, 1, 11)\012\012  #undef C_TYPE_INT\012  #undef C_TYPE_PARAMS\012  #undef C_TYPE_FLOAT\012  #undef C_TYPE_MAP\012\012  // specializations for following struct declared/defined after definition of ac_int\012  template<typename T>\012  struct rt_ac_int_T {\012    template<int W, bool S>\012    struct op1 {\012      typedef typename T::template rt_T< ac_int<W,S> >::mult mult;\012      typedef typename T::template rt_T< ac_int<W,S> >::plus plus;\012      typedef typename T::template rt_T< ac_int<W,S> >::minus2 minus;\012      typedef typename T::template rt_T< ac_int<W,S> >::minus minus2;\012      typedef typename T::template rt_T< ac_int<W,S> >::logic logic;\012      typedef typename T::template rt_T< ac_int<W,S> >::div2 div;\012      typedef typename T::template rt_T< ac_int<W,S> >::div div2;\012    };\012  };\012}\012\012namespace ac {\012  // compiler time constant for log2 like functions\012  template<unsigned X>\012  struct nbits {\012    enum { val = ac_private::s_N<16>::s_X<X>::nbits };\012  };\012\012  template<unsigned X>\012  struct log2_floor {\012    enum { val = nbits<X>::val - 1 };\012  };\012\012  // log2 of 0 is not defined: generate compiler error\012  template<> struct log2_floor<0> {};\012\012  template<unsigned X>\012  struct log2_ceil {\012    enum { lf = log2_floor<X>::val, val = (X == (1 << lf) ? lf : lf+1) };\012  };\012\012  // log2 of 0 is not defined: generate compiler error\012  template<> struct log2_ceil<0> {};\012\012  template<int LowerBound, int UpperBound>\012  struct int_range {\012    enum { l_s = LowerBound < 0, u_s = UpperBound < 0,\012           signedness = l_s || u_s,\012           l_nbits = nbits<AC_ABS(LowerBound+l_s)+l_s>::val,\012           u_nbits = nbits<AC_ABS(UpperBound+u_s)+u_s>::val,\012           nbits = AC_MAX(l_nbits, u_nbits + (!u_s && signedness))\012         };\012    typedef ac_int<nbits, signedness> type;\012  };\012}\012\012enum ac_q_mode { AC_TRN, AC_RND, AC_TRN_ZERO, AC_RND_ZERO, AC_RND_INF, AC_RND_MIN_INF, AC_RND_CONV, AC_RND_CONV_ODD };\012enum ac_o_mode { AC_WRAP, AC_SAT, AC_SAT_ZERO, AC_SAT_SYM };\012template<int W2, int I2, bool S2, ac_q_mode Q2, ac_o_mode O2> class ac_fixed;\012\012//////////////////////////////////////////////////////////////////////////////\012//  Arbitrary-Length Integer: ac_int\012//////////////////////////////////////////////////////////////////////////////\012\012template<int W, bool S=true>\012class ac_int : public ac_private::iv_conv<W, S, W<=64>\012{\012  typedef ac_private::iv_conv<W, S, W <= 64> ConvBase;\012  typedef ac_private::iv<W, S>               Base;\012\012  inline bool is_neg() const { return S && Base::value < 0; }\012\012  enum ac_debug_op { \012    AC_DEBUG_ADD,\012    AC_DEBUG_SUB, \012    AC_DEBUG_MUL,\012    AC_DEBUG_DIV,\012    AC_DEBUG_REM,\012    AC_DEBUG_INCREMENT,\012    AC_DEBUG_DECREMENT\012  };\012\012  // returns false if number is denormal\012  template<int WE, bool SE>\012  bool normalize_private(ac_int<WE,SE> &exp, bool reserved_min_exp=false) {\012    int expt = exp;\012    int lshift = leading_sign();\012    bool fully_normalized = true;\012    ac_int<WE, SE> min_exp;\012    min_exp.template set_val<AC_VAL_MIN>();\012    int max_shift = exp - min_exp - reserved_min_exp;\012    if(lshift > max_shift) {\012      lshift = ac_int<WE,false>(max_shift);\012      expt = min_exp + reserved_min_exp;\012      fully_normalized = false;\012    } else {\012      expt -= lshift;\012    }\012    if(Base::equal_zero()) {\012      expt = 0;\012      fully_normalized = true;\012    }\012    exp = expt;\012    Base r;\012    Base::shift_l(lshift, r);\012    Base::operator=(r);\012    return fully_normalized;\012  }\012\012public:\012  static const int width = W;\012  static const int i_width = W;\012  static const bool sign = S;\012  static const ac_q_mode q_mode = AC_TRN;\012  static const ac_o_mode o_mode = AC_WRAP;\012  static const int e_width = 0;\012\012  template<int W2, bool S2>\012  struct rt {\012    enum {\012      mult_w = W+W2,\012      mult_s = S||S2,\012      plus_w = AC_MAX(W+(S2&&!S),W2+(S&&!S2))+1,\012      plus_s = S||S2,\012      minus_w = AC_MAX(W+(S2&&!S),W2+(S&&!S2))+1,\012      minus_s = true,\012      div_w = W+S2,\012      div_s = S||S2,\012      mod_w = AC_MIN(W,W2+(!S2&&S)),\012      mod_s = S,\012      logic_w = AC_MAX(W+(S2&&!S),W2+(S&&!S2)),\012      logic_s = S||S2\012    };\012    typedef ac_int<mult_w, mult_s> mult;\012    typedef ac_int<plus_w, plus_s> plus;\012    typedef ac_int<minus_w, minus_s> minus;\012    typedef ac_int<logic_w, logic_s> logic;\012    typedef ac_int<div_w, div_s> div;\012    typedef ac_int<mod_w, mod_s> mod;\012    typedef ac_int<W, S> arg1;\012  };\012\012  template<typename T>\012  struct rt_T {\012    typedef typename ac_private::map<T>::t map_T;\012    typedef typename ac_private::rt_ac_int_T<map_T>::template op1<W,S>::mult mult;\012    typedef typename ac_private::rt_ac_int_T<map_T>::template op1<W,S>::plus plus;\012    typedef typename ac_private::rt_ac_int_T<map_T>::template op1<W,S>::minus minus;\012    typedef typename ac_private::rt_ac_int_T<map_T>::template op1<W,S>::minus2 minus2;\012    typedef typename ac_private::rt_ac_int_T<map_T>::template op1<W,S>::logic logic;\012    typedef typename ac_private::rt_ac_int_T<map_T>::template op1<W,S>::div div;\012    typedef typename ac_private::rt_ac_int_T<map_T>::template op1<W,S>::div2 div2;\012    typedef ac_int<W, S> arg1;\012  };\012\012  struct rt_unary {\012    enum {\012      neg_w = W+1,\012      neg_s = true,\012      mag_sqr_w = 2*W-S,\012      mag_sqr_s = false,\012      mag_w = W+S,\012      mag_s = false,\012      leading_sign_w = ac::log2_ceil<W+!S>::val,\012      leading_sign_s = false\012    };\012    typedef ac_int<neg_w, neg_s> neg;\012    typedef ac_int<mag_sqr_w, mag_sqr_s> mag_sqr;\012    typedef ac_int<mag_w, mag_s> mag;\012    typedef ac_int<leading_sign_w, leading_sign_s> leading_sign;\012    template<unsigned N>\012    struct set {\012      enum { sum_w = W + ac::log2_ceil<N>::val, sum_s = S};\012      typedef ac_int<sum_w, sum_s> sum;\012    };\012  };\012\012  template<int W2, bool S2> friend class ac_int;\012  template<int W2, int I2, bool S2, ac_q_mode Q2, ac_o_mode O2> friend class ac_fixed;\012  ac_int() {\012  }\012  template<int W2, bool S2>\012  inline ac_int (const ac_int<W2,S2> &op) {\012    Base::debug_within_range(op);\012    Base::operator =(op);\012  }\012\012  inline ac_int( bool b ) : ConvBase(b) { }\012  inline ac_int( char b ) : ConvBase(b) {\012    Base::debug_within_range(Ulong(b));\012  }\012  inline ac_int( signed char b ) : ConvBase(b) {\012    Base::debug_within_range(Slong(b));\012  }\012  inline ac_int( unsigned char b ) : ConvBase(b) {\012    Base::debug_within_range(Ulong(b));\012  }\012  inline ac_int( signed short b ) : ConvBase(b) {\012    Base::debug_within_range(Slong(b));\012  }\012  inline ac_int( unsigned short b ) : ConvBase(b) {\012    Base::debug_within_range(Ulong(b));\012  }\012  inline ac_int( signed int b ) : ConvBase(b) {\012    Base::debug_within_range(Slong(b));\012  }\012  inline ac_int( unsigned int b ) : ConvBase(b) {\012    Base::debug_within_range(Ulong(b));\012  }\012  inline ac_int( signed long b ) : ConvBase(b) {\012    Base::debug_within_range(Slong(b));\012  }\012  inline ac_int( unsigned long b ) : ConvBase(b) {\012    Base::debug_within_range(Ulong(b));\012  }\012  inline ac_int( Slong b ) : ConvBase(b) {\012    Base::debug_within_range(b);\012  }\012  inline ac_int( Ulong b ) : ConvBase(b) {\012    Base::debug_within_range(b);\012  }\012  inline ac_int( double d ) : ConvBase(d) { }\012\012#if defined(__clang__)\012#pragma clang diagnostic push\012#pragma clang diagnostic ignored \"-Wuninitialized\"\012#endif\012  template<ac_special_val V>\012  inline ac_int &set_val() {\012    if(V == AC_VAL_DC) {\012      ac_int r;\012      Base::operator =(r);\012    }\012    else if(V == AC_VAL_0 || V == AC_VAL_MIN || V == AC_VAL_QUANTUM) {\012      Base::operator =(0);\012      if(S && V == AC_VAL_MIN) {\012        Base::value = 1;\012        Base::value <<= W - 1;\012      } else if(V == AC_VAL_QUANTUM)\012        Base::value = 1;\012    }\012    else if(AC_VAL_MAX) {\012      Base::value = 0;\012      Base::value = ~Base::value;\012      if(S){\012        ap_uint<W> t = Base::value;\012        t >>= 1;\012        Base::value = t;\012      }\012    }\012    return *this;\012  }\012#if defined(__clang__)\012#pragma clang diagnostic pop\012#endif\012\012  // Explicit conversion functions to C built-in types -------------\012  inline int to_int() const { return (int) Base::value; }\012  inline unsigned to_uint() const { return (unsigned) Base::value; }\012  inline long to_long() const { return (long) Base::value; }\012  inline unsigned long to_ulong() const { return (unsigned long) Base::value; }\012  inline Slong to_int64() const { return Base::to_int64(); }\012  inline Ulong to_uint64() const { return Base::to_uint64(); }\012  inline double to_double() const { return Base::to_double(); }\012\012  inline int length() const { return W; }\012\012  inline std::string to_string(ac_base_mode base_rep, bool sign_mag = false) const {\012    return Base::to_string(base_rep);\012  }\012\012  inline static std::string type_name() {\012    const char *tf[] = {\",false>\", \",true>\"};\012    std::string r = \"ac_int<\";\012    r += ac_int<32,true>(W).to_string(AC_DEC);\012    r += tf[S];\012    return r;\012  }\012\012  // Arithmetic : Binary ----------------------------------------------------\012  template<int W2, bool S2>\012  typename rt<W2,S2>::mult operator *( const ac_int<W2,S2> &op2) const {\012    typename rt<W2,S2>::mult r;\012    Base::mult(op2, r);\012    return r;\012  }\012  template<int W2, bool S2>\012  typename rt<W2,S2>::plus operator +( const ac_int<W2,S2> &op2) const {\012    typename rt<W2,S2>::plus r;\012    Base::add(op2, r);\012    return r;\012  }\012  template<int W2, bool S2>\012  typename rt<W2,S2>::minus operator -( const ac_int<W2,S2> &op2) const {\012    typename rt<W2,S2>::minus r;\012    Base::sub(op2, r);\012    return r;\012  }\012  template<int W2, bool S2>\012  typename rt<W2,S2>::div operator /( const ac_int<W2,S2> &op2) const {\012    typename rt<W2,S2>::div r;\012    Base::div(op2, r);\012    return r;\012  }\012  template<int W2, bool S2>\012  typename rt<W2,S2>::mod operator %( const ac_int<W2,S2> &op2) const {\012    typename rt<W2,S2>::mod r;\012    Base::rem(op2, r);\012    return r;\012  }\012  //BEGIN: X86 DEBUG\012  template<int W2, bool S2>\012  void check_overflow( const ac_int<W2, S2> &op2, ac_debug_op debug_op){\012  #ifdef HLS_X86\012  #if defined(DEBUG_AC_INT_WARNING) || defined(DEBUG_AC_INT_ERROR)\012    ac_int<W, S> temp;\012    switch (debug_op){\012      case AC_DEBUG_ADD:\012        temp = (*this) + op2;\012        break;\012      case AC_DEBUG_SUB: \012        temp = (*this) - op2;\012        break;\012      case AC_DEBUG_MUL:\012        temp = (*this) * op2;\012        break;\012      case AC_DEBUG_DIV:\012        temp = (*this) / op2;\012        break;\012      case AC_DEBUG_REM:\012        temp = (*this) % op2;\012        break;\012      \012      default:\012        break;\012\012    }\012  #endif\012  #endif\012  }\012\012  void check_overflow(ac_debug_op debug_op){\012  #ifdef HLS_X86\012  #if defined(DEBUG_AC_INT_WARNING) || defined(DEBUG_AC_INT_ERROR)\012    ac_int<W, S> temp;\012    ac_int<2, true> op2 = 1;\012    switch (debug_op){\012      case AC_DEBUG_INCREMENT :\012        temp = (*this) + op2;\012        break;\012      case AC_DEBUG_DECREMENT : \012        temp = (*this) - op2;\012        break;\012      \012      default:\012        break;\012    }\012  #endif\012  #endif\012  }\012\012\012  //END: X86 DEBUG\012\012\012  // Arithmetic assign  ------------------------------------------------------\012  template<int W2, bool S2>\012  ac_int &operator *=( const ac_int<W2,S2> &op2) {\012    check_overflow(op2, AC_DEBUG_MUL);\012    Base r;\012    Base::mult(op2, r);\012    Base::operator=(r);\012    return *this;\012  }\012  template<int W2, bool S2>\012  ac_int &operator +=( const ac_int<W2,S2> &op2) {\012    check_overflow(op2, AC_DEBUG_ADD);\012    Base r;\012    Base::add(op2, r);\012    Base::operator=(r);\012    return *this;\012  }\012  template<int W2, bool S2>\012  ac_int &operator -=( const ac_int<W2,S2> &op2) {\012    check_overflow(op2, AC_DEBUG_SUB);\012    Base r;\012    Base::sub(op2, r);\012    Base::operator=(r);\012    return *this;\012  }\012  template<int W2, bool S2>\012  ac_int &operator /=( const ac_int<W2,S2> &op2) {\012    check_overflow(op2, AC_DEBUG_DIV);\012    Base r;\012    Base::div(op2, r);\012    Base::operator=(r);\012    return *this;\012  }\012  template<int W2, bool S2>\012  ac_int &operator %=( const ac_int<W2,S2> &op2) {\012    check_overflow(op2, AC_DEBUG_REM);\012    Base r;\012    Base::mod(op2, r);\012    Base::operator=(r);\012    return *this;\012  }\012  // Arithmetic prefix increment, decrement ----------------------------------\012  ac_int &operator ++() {\012    check_overflow(AC_DEBUG_INCREMENT);\012    Base::increment();\012    return *this;\012  }\012  ac_int &operator --() {\012    check_overflow(AC_DEBUG_DECREMENT);\012    Base::decrement();\012    return *this;\012  }\012  // Arithmetic postfix increment, decrement ---------------------------------\012  const ac_int operator ++(int) {\012    check_overflow(AC_DEBUG_INCREMENT);\012    ac_int t = *this;\012    Base::increment();\012    return t;\012  }\012  const ac_int operator --(int) {\012    check_overflow(AC_DEBUG_DECREMENT);\012    ac_int t = *this;\012    Base::decrement();\012    return t;\012  }\012  // Arithmetic Unary --------------------------------------------------------\012  ac_int operator +() {\012    return *this;\012  }\012  typename rt_unary::neg operator -() const {\012    typename rt_unary::neg r;\012    Base::neg(r);\012    return r;\012  }\012  // ! ------------------------------------------------------------------------\012  bool operator ! () const {\012    return Base::equal_zero();\012  }\012\012  // Bitwise (arithmetic) unary: complement  -----------------------------\012  ac_int<W+!S, true> operator ~() const {\012    ac_int<W+!S, true> r;\012    Base::bitwise_complement(r);\012    return r;\012  }\012  // Bitwise (non-arithmetic) bit_complement  -----------------------------\012  ac_int<W, false> bit_complement() const {\012    ac_int<W, false> r;\012    Base::bitwise_complement(r);\012    return r;\012  }\012  // Bitwise (arithmetic): and, or, xor ----------------------------------\012  template<int W2, bool S2>\012  typename rt<W2,S2>::logic operator & ( const ac_int<W2,S2> &op2) const {\012    typename rt<W2,S2>::logic r;\012    Base::bitwise_and(op2, r);\012    return r;\012  }\012  template<int W2, bool S2>\012  typename rt<W2,S2>::logic operator | ( const ac_int<W2,S2> &op2) const {\012    typename rt<W2,S2>::logic r;\012    Base::bitwise_or(op2, r);\012    return r;\012  }\012  template<int W2, bool S2>\012  typename rt<W2,S2>::logic operator ^ ( const ac_int<W2,S2> &op2) const {\012    typename rt<W2,S2>::logic r;\012    Base::bitwise_xor(op2, r);\012    return r;\012  }\012  // Bitwise assign (not arithmetic): and, or, xor ----------------------------\012  template<int W2, bool S2>\012  ac_int &operator &= ( const ac_int<W2,S2> &op2 ) {\012    Base r;\012    Base::bitwise_and(op2, r);\012    Base::operator=(r);\012    return *this;\012  }\012  template<int W2, bool S2>\012  ac_int &operator |= ( const ac_int<W2,S2> &op2 ) {\012    Base r;\012    Base::bitwise_or(op2, r);\012    Base::operator=(r);\012    return *this;\012  }\012  template<int W2, bool S2>\012  ac_int &operator ^= ( const ac_int<W2,S2> &op2 ) {\012    Base r;\012    Base::bitwise_xor(op2, r);\012    Base::operator=(r);\012    return *this;\012  }\012  // Shift (result constrained by left operand) -------------------------------\012  template<int W2>\012  ac_int operator << ( const ac_int<W2,true> &op2 ) const {\012    ac_int r;\012    Base::shift_l2(op2.to_int(), r);\012    return r;\012  }\012  template<int W2>\012  ac_int operator << ( const ac_int<W2,false> &op2 ) const {\012    ac_int r;\012    Base::shift_l(op2.to_uint(), r);\012    return r;\012  }\012  template<int W2>\012  ac_int operator >> ( const ac_int<W2,true> &op2 ) const {\012    ac_int r;\012    Base::shift_r2(op2.to_int(), r);\012    return r;\012  }\012  template<int W2>\012  ac_int operator >> ( const ac_int<W2,false> &op2 ) const {\012    ac_int r;\012    Base::shift_r(op2.to_uint(), r);\012    return r;\012  }\012  // Shift assign ------------------------------------------------------------\012  template<int W2>\012  ac_int &operator <<= ( const ac_int<W2,true> &op2 ) {\012    Base r;\012    Base::shift_l2(op2.to_int(), r);\012    Base::operator=(r);\012    return *this;\012  }\012  template<int W2>\012  ac_int &operator <<= ( const ac_int<W2,false> &op2 ) {\012    Base r;\012    Base::shift_l(op2.to_uint(), r);\012    Base::operator=(r);\012    return *this;\012  }\012  template<int W2>\012  ac_int &operator >>= ( const ac_int<W2,true> &op2 ) {\012    Base r;\012    Base::shift_r2(op2.to_int(), r);\012    Base::operator=(r);\012    return *this;\012  }\012  template<int W2>\012  ac_int &operator >>= ( const ac_int<W2,false> &op2 ) {\012    Base r;\012    Base::shift_r(op2.to_uint(), r);\012    Base::operator=(r);\012    return *this;\012  }\012  // Relational ---------------------------------------------------------------\012  template<int W2, bool S2>\012  bool operator == ( const ac_int<W2,S2> &op2) const {\012    return Base::equal(op2);\012  }\012  template<int W2, bool S2>\012  bool operator != ( const ac_int<W2,S2> &op2) const {\012    return !Base::equal(op2);\012  }\012  template<int W2, bool S2>\012  bool operator < ( const ac_int<W2,S2> &op2) const {\012    return Base::less_than(op2);\012  }\012  template<int W2, bool S2>\012  bool operator >= ( const ac_int<W2,S2> &op2) const {\012    return !Base::less_than(op2);\012  }\012  template<int W2, bool S2>\012  bool operator > ( const ac_int<W2,S2> &op2) const {\012    return Base::greater_than(op2);\012  }\012  template<int W2, bool S2>\012  bool operator <= ( const ac_int<W2,S2> &op2) const {\012    return !Base::greater_than(op2);\012  }\012\012  // Bit and Slice Select -----------------------------------------------------\012  template<int WS, int WX, bool SX>\012  inline ac_int<WS,S> slc(const ac_int<WX,SX> &index) const {\012    ac_int<W, S> op = *this;\012    ac_int<WS, S> r;\012    AC_ASSERT(index >= 0, \"Attempting to read slc with negative indeces\");\012    ac_int<WX-SX, false> uindex = index;\012    Base::shift_r(uindex.to_uint(), op);\012    r = op;\012    return r;\012  }\012\012  template<int WS>\012  inline ac_int<WS,S> slc(signed index) const {\012    ac_int<W, S> op = *this;\012    ac_int<WS,S> r;\012    AC_ASSERT(index >= 0, \"Attempting to read slc with negative indeces\");\012    unsigned uindex = index & ((unsigned)~0 >> 1);\012    Base::shift_r(uindex, op);\012    r = op;\012    return r;\012  }\012  template<int WS>\012  inline ac_int<WS,S> slc(unsigned uindex) const {\012    ac_int<W,S> op = *this;\012    Base::shift_r(uindex, op);\012    ac_int<WS,S> r = op;\012    return r;\012  }\012\012  template<int W2, bool S2, int WX, bool SX>\012  inline ac_int &set_slc(const ac_int<WX,SX> lsb, const ac_int<W2,S2> &slc) {\012    AC_ASSERT(lsb.to_int() + W2 <= W && lsb.to_int() >= 0, \"Out of bounds set_slc\");\012    if (lsb.to_int() + W2 <= W && lsb.to_int() >= 0) {\012        ac_int<WX-SX, false> ulsb = lsb;\012        Base::set_slc(ulsb.to_uint(), W2, (ac_int<W2,false>) slc);\012    } else {\012        Base r = 0;\012        Base::operator=(r);\012    }\012    return *this;\012  }\012  template<int W2, bool S2>\012  inline ac_int &set_slc(signed lsb, const ac_int<W2,S2> &slc) {\012    AC_ASSERT(lsb + W2 <= W && lsb >= 0, \"Out of bounds set_slc\");\012    if (lsb + W2 <= W && lsb >= 0) {\012        unsigned ulsb = lsb & ((unsigned)~0 >> 1);\012        Base::set_slc(ulsb, W2, (ac_int<W2,false>) slc);\012    } else {\012        Base r = 0;\012        Base::operator=(r);\012    }\012    return *this;\012  }\012  template<int W2, bool S2>\012  inline ac_int &set_slc(unsigned ulsb, const ac_int<W2,S2> &slc) {\012    AC_ASSERT(ulsb + W2 <= W, \"Out of bounds set_slc\");\012    if (ulsb + W2 <= W) {\012        Base::set_slc(ulsb, W2, (ac_int<W2,false>) slc);\012    } else {\012        Base r = 0;\012        Base::operator=(r);\012    }\012    return *this;\012  }\012\012  class ac_bitref {\012    ac_int &d_bv;\012    unsigned d_index;\012  public:\012    ac_bitref( ac_int *bv, unsigned index=0 ) : d_bv(*bv), d_index(index) {\012    }\012    operator bool () const {\012      return (d_index < W) ? (d_bv.value>>(d_index) & 1) : 0;\012    }\012\012    template<int W2, bool S2>\012    operator ac_int<W2,S2> () const { return operator bool (); }\012\012    inline ac_bitref operator = ( int val ) {\012      // lsb of int (val&1) is written to bit\012      if(d_index < W) {\012        ap_int<W+1> temp1 = d_bv.value;\012        ap_int<W+1> temp2 = val;\012        temp2 <<= d_index;\012        temp1 ^= temp2;\012        temp2 = 1;\012        temp2 <<= d_index;\012        temp1 &= temp2;\012        d_bv.value ^= temp1;\012      }\012      return *this;\012    }\012    template<int W2, bool S2>\012    inline ac_bitref operator = ( const ac_int<W2,S2> &val ) {\012      return operator =(val.to_int());\012    }\012    inline ac_bitref operator = ( const ac_bitref &val ) {\012      return operator =((int) (bool) val);\012    }\012  };\012\012  ac_bitref operator [] ( unsigned int uindex) {\012    AC_ASSERT(uindex < W, \"Attempting to read bit beyond MSB\");\012    ac_bitref bvh( this, uindex );\012    return bvh;\012  }\012  ac_bitref operator [] ( int index) {\012    AC_ASSERT(index >= 0, \"Attempting to read bit with negative index\");\012    AC_ASSERT(index < W, \"Attempting to read bit beyond MSB\");\012    unsigned uindex = index & ((unsigned)~0 >> 1);\012    ac_bitref bvh( this, uindex );\012    return bvh;\012  }\012  template<int W2, bool S2>\012  ac_bitref operator [] ( const ac_int<W2,S2> &index) {\012    AC_ASSERT(index >= 0, \"Attempting to read bit with negative index\");\012    AC_ASSERT(index < W, \"Attempting to read bit beyond MSB\");\012    ac_int<W2-S2,false> uindex = index;\012    ac_bitref bvh( this, uindex.to_uint() );\012    return bvh;\012  }\012  bool operator [] ( unsigned int uindex) const {\012    AC_ASSERT(uindex < W, \"Attempting to read bit beyond MSB\");\012    return (uindex < W) ? (Base::v[uindex>>5]>>(uindex&31) & 1) : 0;\012  }\012  bool operator [] ( int index) const {\012    AC_ASSERT(index >= 0, \"Attempting to read bit with negative index\");\012    AC_ASSERT(index < W, \"Attempting to read bit beyond MSB\");\012    unsigned uindex = index & ((unsigned)~0 >> 1);\012    return (uindex < W) ? (Base::v[uindex>>5]>>(uindex&31) & 1) : 0;\012  }\012  template<int W2, bool S2>\012  bool operator [] ( const ac_int<W2,S2> &index) const {\012    AC_ASSERT(index >= 0, \"Attempting to read bit with negative index\");\012    AC_ASSERT(index < W, \"Attempting to read bit beyond MSB\");\012    ac_int<W2-S2,false> uindex = index;\012    return (uindex < W) ? (Base::v[uindex>>5]>>(uindex.to_uint()&31) & 1) : 0;\012  }\012  typename rt_unary::leading_sign leading_sign() const {\012    unsigned ls = 0;\012    return ls;\012  }\012  typename rt_unary::leading_sign leading_sign(bool &all_sign) const {\012    unsigned ls = 0;\012    return ls;\012  }\012  // returns false if number is denormal\012  template<int WE, bool SE>\012  bool normalize(ac_int<WE,SE> &exp) {\012    return false;\012  }\012  // returns false if number is denormal, minimum exponent is reserved (usually for encoding special values/errors)\012  template<int WE, bool SE>\012  bool normalize_RME(ac_int<WE,SE> &exp) {\012    return false;\012  }\012  bool and_reduce() const {\012    return false;\012  }\012  bool or_reduce() const {\012    return !Base::equal_zero();\012  }\012  bool xor_reduce() const {\012    return false;\012  }\012  ac_int reverse() const {\012    ac_int r;\012    Base::reverse(r);\012    return r;\012  }\012\012  inline void bit_fill_hex(const char *str) {\012    // Zero Pads if str is too short, throws ms bits away if str is too long\012    // Asserts if anything other than 0-9a-fA-F is encountered\012    ac_int<W,S> res = 0;\012    int i = 0;\012    while(str[i]) {\012      char c = str[i];\012      ac_int<4, false> h = 0;\012      if(c >= '0' && c <= '9')\012        h = c - '0';\012      else if(c >= 'A' && c <= 'F')\012        h = c - 'A' + 10;\012      else if(c >= 'a' && c <= 'f')\012        h = c - 'a' + 10;\012      else {\012        AC_ASSERT(!c, \"Invalid hex digit\");\012        break;\012      }\012      ac_int<4, false> s = 4;\012      res =  res << s;\012      res |= h;\012      i++;\012    }\012    *this = res;\012  }\012\012  template<int Na>\012  inline void bit_fill(const int (&ivec)[Na], bool bigendian=true) {\012    // bit_fill from integer vector\012    //   if W > N*32, missing most significant bits are zeroed\012    //   if W < N*32, additional bits in ivec are ignored (no overflow checking)\012    // Example:\012    //   ac_int<80,false> x;    int vec[] = { 0xffffa987, 0x6543210f, 0xedcba987 };\012    //   x.bit_fill(vec);   // vec[0] fill bits 79-64\012    const int M = AC_MIN((W + 31)/32,Na);\012    ac_int<M*32, false> res = 0;\012    // Do not unroll this loop, the HLS flow\012    // auto unrolls for us.\012    for(int i=0; i < M; i++){\012      res.set_slc(i*32, ac_int<32, false>(ivec[bigendian ? M-1-i : i]));\012    }\012    *this = res;\012  }\012};\012\012namespace ac {\012  template<typename T, typename T2>\012  struct rt_2T {\012    typedef typename ac_private::map<T>::t map_T;\012    typedef typename ac_private::map<T2>::t map_T2;\012    typedef typename map_T::template rt_T< map_T2 >::mult mult;\012    typedef typename map_T::template rt_T< map_T2 >::plus plus;\012    typedef typename map_T::template rt_T< map_T2 >::minus minus;\012    typedef typename map_T::template rt_T< map_T2 >::minus2 minus2;\012    typedef typename map_T::template rt_T< map_T2 >::logic logic;\012    typedef typename map_T::template rt_T< map_T2 >::div div;\012    typedef typename map_T::template rt_T< map_T2 >::div2 div2;\012  };\012}\012\012namespace ac {\012  template<typename T>\012  struct ac_int_represent {\012    enum { t_w = ac_private::c_type_params<T>::W, t_s = ac_private::c_type_params<T>::S };\012    typedef ac_int<t_w,t_s> type;\012  };\012  template<> struct ac_int_represent<float> {};\012  template<> struct ac_int_represent<double> {};\012  template<int W, bool S>\012  struct ac_int_represent< ac_int<W,S> > {\012    typedef ac_int<W,S> type;\012  };\012}\012\012namespace ac_private {\012  template<int W2, bool S2>\012  struct rt_ac_int_T< ac_int<W2,S2> > {\012    typedef ac_int<W2,S2> i2_t;\012    template<int W, bool S>\012    struct op1 {\012      typedef ac_int<W,S> i_t;\012      typedef typename i_t::template rt<W2,S2>::mult mult;\012      typedef typename i_t::template rt<W2,S2>::plus plus;\012      typedef typename i_t::template rt<W2,S2>::minus minus;\012      typedef typename i2_t::template rt<W,S>::minus minus2;\012      typedef typename i_t::template rt<W2,S2>::logic logic;\012      typedef typename i_t::template rt<W2,S2>::div div;\012      typedef typename i2_t::template rt<W,S>::div div2;\012      typedef typename i_t::template rt<W2,S2>::mod mod;\012      typedef typename i2_t::template rt<W,S>::mod mod2;\012    };\012  };\012\012  template<typename T>\012  struct rt_ac_int_T< c_type<T> > {\012    typedef typename ac::ac_int_represent<T>::type i2_t;\012    enum { W2 = i2_t::width, S2 = i2_t::sign };\012    template<int W, bool S>\012    struct op1 {\012      typedef ac_int<W,S> i_t;\012      typedef typename i_t::template rt<W2,S2>::mult mult;\012      typedef typename i_t::template rt<W2,S2>::plus plus;\012      typedef typename i_t::template rt<W2,S2>::minus minus;\012      typedef typename i2_t::template rt<W,S>::minus minus2;\012      typedef typename i_t::template rt<W2,S2>::logic logic;\012      typedef typename i_t::template rt<W2,S2>::div div;\012      typedef typename i2_t::template rt<W,S>::div div2;\012      typedef typename i_t::template rt<W2,S2>::mod mod;\012      typedef typename i2_t::template rt<W,S>::mod mod2;\012    };\012  };\012}\012\012// Stream --------------------------------------------------------------------\012#if defined (__linux__)\012template<int W, bool S>\012inline std::ostream& operator << (std::ostream &os, const ac_int<W,S> &x) {\012#ifdef HLS_X86\012  os << x.to_string(AC_DEC);\012#endif\012  return os;\012}\012#endif // linux\012\012// Macros for Binary Operators with Integers --------------------------------------------\012\012#define BIN_OP_WITH_INT(BIN_OP, C_TYPE, WI, SI, RTYPE)  \\\012  template<int W, bool S> \\\012  inline typename ac_int<WI,SI>::template rt<W,S>::RTYPE operator BIN_OP ( C_TYPE i_op, const ac_int<W,S> &op) {  \\\012    return ac_int<WI,SI>(i_op).operator BIN_OP (op);  \\\012  } \\\012  template<int W, bool S>   \\\012  inline typename ac_int<W,S>::template rt<WI,SI>::RTYPE operator BIN_OP ( const ac_int<W,S> &op, C_TYPE i_op) {  \\\012    return op.operator BIN_OP (ac_int<WI,SI>(i_op));  \\\012  }\012\012#define REL_OP_WITH_INT(REL_OP, C_TYPE, W2, S2)  \\\012  template<int W, bool S>   \\\012  inline bool operator REL_OP ( const ac_int<W,S> &op, C_TYPE op2) {  \\\012    return op.operator REL_OP (ac_int<W2,S2>(op2));  \\\012  }  \\\012  template<int W, bool S> \\\012  inline bool operator REL_OP ( C_TYPE op2, const ac_int<W,S> &op) {  \\\012    return ac_int<W2,S2>(op2).operator REL_OP (op);  \\\012  }\012\012#define ASSIGN_OP_WITH_INT(ASSIGN_OP, C_TYPE, W2, S2)  \\\012  template<int W, bool S>   \\\012  inline ac_int<W,S> &operator ASSIGN_OP ( ac_int<W,S> &op, C_TYPE op2) {  \\\012    return op.operator ASSIGN_OP (ac_int<W2,S2>(op2));  \\\012  }\012\012#define OPS_WITH_INT(C_TYPE, WI, SI) \\\012  BIN_OP_WITH_INT(*, C_TYPE, WI, SI, mult) \\\012  BIN_OP_WITH_INT(+, C_TYPE, WI, SI, plus) \\\012  BIN_OP_WITH_INT(-, C_TYPE, WI, SI, minus) \\\012  BIN_OP_WITH_INT(/, C_TYPE, WI, SI, div) \\\012  BIN_OP_WITH_INT(%, C_TYPE, WI, SI, mod) \\\012  BIN_OP_WITH_INT(>>, C_TYPE, WI, SI, arg1) \\\012  BIN_OP_WITH_INT(<<, C_TYPE, WI, SI, arg1) \\\012  BIN_OP_WITH_INT(&, C_TYPE, WI, SI, logic) \\\012  BIN_OP_WITH_INT(|, C_TYPE, WI, SI, logic) \\\012  BIN_OP_WITH_INT(^, C_TYPE, WI, SI, logic) \\\012  \\\012  REL_OP_WITH_INT(==, C_TYPE, WI, SI) \\\012  REL_OP_WITH_INT(!=, C_TYPE, WI, SI) \\\012  REL_OP_WITH_INT(>, C_TYPE, WI, SI) \\\012  REL_OP_WITH_INT(>=, C_TYPE, WI, SI) \\\012  REL_OP_WITH_INT(<, C_TYPE, WI, SI) \\\012  REL_OP_WITH_INT(<=, C_TYPE, WI, SI) \\\012  \\\012  ASSIGN_OP_WITH_INT(+=, C_TYPE, WI, SI) \\\012  ASSIGN_OP_WITH_INT(-=, C_TYPE, WI, SI) \\\012  ASSIGN_OP_WITH_INT(*=, C_TYPE, WI, SI) \\\012  ASSIGN_OP_WITH_INT(/=, C_TYPE, WI, SI) \\\012  ASSIGN_OP_WITH_INT(%=, C_TYPE, WI, SI) \\\012  ASSIGN_OP_WITH_INT(>>=, C_TYPE, WI, SI) \\\012  ASSIGN_OP_WITH_INT(<<=, C_TYPE, WI, SI) \\\012  ASSIGN_OP_WITH_INT(&=, C_TYPE, WI, SI) \\\012  ASSIGN_OP_WITH_INT(|=, C_TYPE, WI, SI) \\\012  ASSIGN_OP_WITH_INT(^=, C_TYPE, WI, SI)\012\012// ------------------------------------- End of Macros for Binary Operators with Integers\012\012namespace ac {\012  namespace ops_with_other_types {\012    //  Mixed Operators with Integers  -----------------------------------------------\012    OPS_WITH_INT(bool, 1, false)\012    OPS_WITH_INT(char, 8, true)\012    OPS_WITH_INT(signed char, 8, true)\012    OPS_WITH_INT(unsigned char, 8, false)\012    OPS_WITH_INT(short, 16, true)\012    OPS_WITH_INT(unsigned short, 16, false)\012    OPS_WITH_INT(int, 32, true)\012    OPS_WITH_INT(unsigned int, 32, false)\012    OPS_WITH_INT(long, ac_private::long_w, true)\012    OPS_WITH_INT(unsigned long, ac_private::long_w, false)\012    OPS_WITH_INT(Slong, 64, true)\012    OPS_WITH_INT(Ulong, 64, false)\012    // -----------------------------------------  End of Mixed Operators with Integers\012  }  // ops_with_other_types namespace\012\012  // Functions to fill bits\012\012  template<typename T>\012  inline T bit_fill_hex(const char *str) {\012    T res;\012    res.bit_fill_hex(str);\012    return res;\012  }\012\012  // returns bit_fill for type\012  //   example:\012  //   ac_int<80,false> x = ac::bit_fill< ac_int<80,false> > ((int [3]) {0xffffa987, 0x6543210f, 0xedcba987 });\012  template<typename T, int N>\012  inline T bit_fill(const int (&ivec)[N], bool bigendian=true) {\012    T res;\012    res.bit_fill(ivec, bigendian);\012    return res;\012  }\012\012}  // ac namespace\012\012//  Mixed Operators with Pointers  -----------------------------------------------\012\012// Addition of ac_int and  pointer\012template<typename T, int W, bool S>\012T *operator +(T *ptr, const ac_int<W,S> &op2) {\012  return ptr + op2.to_int64();\012}\012template<typename T, int W, bool S>\012T *operator +(const ac_int<W,S> &op2, T *ptr) {\012  return ptr + op2.to_int64();\012}\012// Subtraction of ac_int from pointer\012template<typename T, int W, bool S>\012T *operator -(T *ptr, const ac_int<W,S> &op2) {\012  return ptr - op2.to_int64();\012}\012// -----------------------------------------  End of Mixed Operators with Pointers\012\012using namespace ac::ops_with_other_types;\012\012namespace ac_intN {\012  ///////////////////////////////////////////////////////////////////////////////\012  //  Predefined for ease of use\012  ///////////////////////////////////////////////////////////////////////////////\012  typedef ac_int<1,          true>   int1;\012  typedef ac_int<1,          false>  uint1;\012  typedef ac_int<2,          true>   int2;\012  typedef ac_int<2,          false>  uint2;\012  typedef ac_int<3,          true>   int3;\012  typedef ac_int<3,          false>  uint3;\012  typedef ac_int<4,          true>   int4;\012  typedef ac_int<4,          false>  uint4;\012  typedef ac_int<5,          true>   int5;\012  typedef ac_int<5,          false>  uint5;\012  typedef ac_int<6,          true>   int6;\012  typedef ac_int<6,          false>  uint6;\012  typedef ac_int<7,          true>   int7;\012  typedef ac_int<7,          false>  uint7;\012  typedef ac_int<8,          true>   int8;\012  typedef ac_int<8,          false>  uint8;\012  typedef ac_int<9,          true>   int9;\012  typedef ac_int<9,          false>  uint9;\012  typedef ac_int<10,         true>   int10;\012  typedef ac_int<10,         false>  uint10;\012  typedef ac_int<11,         true>   int11;\012  typedef ac_int<11,         false>  uint11;\012  typedef ac_int<12,         true>   int12;\012  typedef ac_int<12,         false>  uint12;\012  typedef ac_int<13,         true>   int13;\012  typedef ac_int<13,         false>  uint13;\012  typedef ac_int<14,         true>   int14;\012  typedef ac_int<14,         false>  uint14;\012  typedef ac_int<15,         true>   int15;\012  typedef ac_int<15,         false>  uint15;\012  typedef ac_int<16,         true>   int16;\012  typedef ac_int<16,         false>  uint16;\012  typedef ac_int<17,         true>   int17;\012  typedef ac_int<17,         false>  uint17;\012  typedef ac_int<18,         true>   int18;\012  typedef ac_int<18,         false>  uint18;\012  typedef ac_int<19,         true>   int19;\012  typedef ac_int<19,         false>  uint19;\012  typedef ac_int<20,         true>   int20;\012  typedef ac_int<20,         false>  uint20;\012  typedef ac_int<21,         true>   int21;\012  typedef ac_int<21,         false>  uint21;\012  typedef ac_int<22,         true>   int22;\012  typedef ac_int<22,         false>  uint22;\012  typedef ac_int<23,         true>   int23;\012  typedef ac_int<23,         false>  uint23;\012  typedef ac_int<24,         true>   int24;\012  typedef ac_int<24,         false>  uint24;\012  typedef ac_int<25,         true>   int25;\012  typedef ac_int<25,         false>  uint25;\012  typedef ac_int<26,         true>   int26;\012  typedef ac_int<26,         false>  uint26;\012  typedef ac_int<27,         true>   int27;\012  typedef ac_int<27,         false>  uint27;\012  typedef ac_int<28,         true>   int28;\012  typedef ac_int<28,         false>  uint28;\012  typedef ac_int<29,         true>   int29;\012  typedef ac_int<29,         false>  uint29;\012  typedef ac_int<30,         true>   int30;\012  typedef ac_int<30,         false>  uint30;\012  typedef ac_int<31,         true>   int31;\012  typedef ac_int<31,         false>  uint31;\012  typedef ac_int<32,         true>   int32;\012  typedef ac_int<32,         false>  uint32;\012  typedef ac_int<33,         true>   int33;\012  typedef ac_int<33,         false>  uint33;\012  typedef ac_int<34,         true>   int34;\012  typedef ac_int<34,         false>  uint34;\012  typedef ac_int<35,         true>   int35;\012  typedef ac_int<35,         false>  uint35;\012  typedef ac_int<36,         true>   int36;\012  typedef ac_int<36,         false>  uint36;\012  typedef ac_int<37,         true>   int37;\012  typedef ac_int<37,         false>  uint37;\012  typedef ac_int<38,         true>   int38;\012  typedef ac_int<38,         false>  uint38;\012  typedef ac_int<39,         true>   int39;\012  typedef ac_int<39,         false>  uint39;\012  typedef ac_int<40,         true>   int40;\012  typedef ac_int<40,         false>  uint40;\012  typedef ac_int<41,         true>   int41;\012  typedef ac_int<41,         false>  uint41;\012  typedef ac_int<42,         true>   int42;\012  typedef ac_int<42,         false>  uint42;\012  typedef ac_int<43,         true>   int43;\012  typedef ac_int<43,         false>  uint43;\012  typedef ac_int<44,         true>   int44;\012  typedef ac_int<44,         false>  uint44;\012  typedef ac_int<45,         true>   int45;\012  typedef ac_int<45,         false>  uint45;\012  typedef ac_int<46,         true>   int46;\012  typedef ac_int<46,         false>  uint46;\012  typedef ac_int<47,         true>   int47;\012  typedef ac_int<47,         false>  uint47;\012  typedef ac_int<48,         true>   int48;\012  typedef ac_int<48,         false>  uint48;\012  typedef ac_int<49,         true>   int49;\012  typedef ac_int<49,         false>  uint49;\012  typedef ac_int<50,         true>   int50;\012  typedef ac_int<50,         false>  uint50;\012  typedef ac_int<51,         true>   int51;\012  typedef ac_int<51,         false>  uint51;\012  typedef ac_int<52,         true>   int52;\012  typedef ac_int<52,         false>  uint52;\012  typedef ac_int<53,         true>   int53;\012  typedef ac_int<53,         false>  uint53;\012  typedef ac_int<54,         true>   int54;\012  typedef ac_int<54,         false>  uint54;\012  typedef ac_int<55,         true>   int55;\012  typedef ac_int<55,         false>  uint55;\012  typedef ac_int<56,         true>   int56;\012  typedef ac_int<56,         false>  uint56;\012  typedef ac_int<57,         true>   int57;\012  typedef ac_int<57,         false>  uint57;\012  typedef ac_int<58,         true>   int58;\012  typedef ac_int<58,         false>  uint58;\012  typedef ac_int<59,         true>   int59;\012  typedef ac_int<59,         false>  uint59;\012  typedef ac_int<60,         true>   int60;\012  typedef ac_int<60,         false>  uint60;\012  typedef ac_int<61,         true>   int61;\012  typedef ac_int<61,         false>  uint61;\012  typedef ac_int<62,         true>   int62;\012  typedef ac_int<62,         false>  uint62;\012  typedef ac_int<63,         true>   int63;\012  typedef ac_int<63,         false>  uint63;\012}  // namespace ac_intN\012\012#ifndef AC_NOT_USING_INTN\012using namespace ac_intN;\012#endif\012\012///////////////////////////////////////////////////////////////////////////////\012\012// Global templatized functions for easy initialization to special values\012template<ac_special_val V, int W, bool S>\012inline ac_int<W,S> value(ac_int<W,S>) {\012  ac_int<W,S> r;\012  return r.template set_val<V>();\012}\012// forward declaration, otherwise GCC errors when calling init_array\012template<ac_special_val V, int W, int I, bool S, ac_q_mode Q, ac_o_mode O>\012inline ac_fixed<W,I,S,Q,O> value(ac_fixed<W,I,S,Q,O>);\012\012#define SPECIAL_VAL_FOR_INTS_DC(C_TYPE, WI, SI) \\\012template<> inline C_TYPE value<AC_VAL_DC>(C_TYPE) { C_TYPE x=0; return x; }\012\012// -- C int types -----------------------------------------------------------------\012#define SPECIAL_VAL_FOR_INTS(C_TYPE, WI, SI) \\\012template<ac_special_val val> inline C_TYPE value(C_TYPE); \\\012template<> inline C_TYPE value<AC_VAL_0>(C_TYPE) { return (C_TYPE)0; } \\\012SPECIAL_VAL_FOR_INTS_DC(C_TYPE, WI, SI) \\\012template<> inline C_TYPE value<AC_VAL_QUANTUM>(C_TYPE) { return (C_TYPE)1; } \\\012template<> inline C_TYPE value<AC_VAL_MAX>(C_TYPE) { return (C_TYPE)(SI ? ~((C_TYPE) -1 << (WI-1)) : (C_TYPE) -1); } \\\012template<> inline C_TYPE value<AC_VAL_MIN>(C_TYPE) { return (C_TYPE)(SI ? (C_TYPE) 1 << (WI-1) : 0); }\012\012SPECIAL_VAL_FOR_INTS(bool, 1, false)\012SPECIAL_VAL_FOR_INTS(char, 8, true)\012SPECIAL_VAL_FOR_INTS(signed char, 8, true)\012SPECIAL_VAL_FOR_INTS(unsigned char, 8, false)\012SPECIAL_VAL_FOR_INTS(short, 16, true)\012SPECIAL_VAL_FOR_INTS(unsigned short, 16, false)\012SPECIAL_VAL_FOR_INTS(int, 32, true)\012SPECIAL_VAL_FOR_INTS(unsigned int, 32, false)\012SPECIAL_VAL_FOR_INTS(long, ac_private::long_w, true)\012SPECIAL_VAL_FOR_INTS(unsigned long, ac_private::long_w, false)\012SPECIAL_VAL_FOR_INTS(Slong, 64, true)\012SPECIAL_VAL_FOR_INTS(Ulong, 64, false)\012\012#define INIT_ARRAY_SPECIAL_VAL_FOR_INTS(C_TYPE) \\\012  template<ac_special_val V> \\\012  inline bool init_array(C_TYPE *a, int n) { \\\012    C_TYPE t = value<V>(*a); \\\012    for(int i=0; i < n; i++) \\\012      a[i] = t; \\\012    return true; \\\012  }\012\012namespace ac {\012// PUBLIC FUNCTIONS\012// function to initialize (or uninitialize) arrays\012  template<ac_special_val V, int W, bool S>\012  inline bool init_array(ac_int<W,S> *a, int n) {\012    ac_int<W,S> t = value<V>(*a);\012    for(int i=0; i < n; i++)\012      a[i] = t;\012    return true;\012  }\012\012  INIT_ARRAY_SPECIAL_VAL_FOR_INTS(bool)\012  INIT_ARRAY_SPECIAL_VAL_FOR_INTS(char)\012  INIT_ARRAY_SPECIAL_VAL_FOR_INTS(signed char)\012  INIT_ARRAY_SPECIAL_VAL_FOR_INTS(unsigned char)\012  INIT_ARRAY_SPECIAL_VAL_FOR_INTS(signed short)\012  INIT_ARRAY_SPECIAL_VAL_FOR_INTS(unsigned short)\012  INIT_ARRAY_SPECIAL_VAL_FOR_INTS(signed int)\012  INIT_ARRAY_SPECIAL_VAL_FOR_INTS(unsigned int)\012  INIT_ARRAY_SPECIAL_VAL_FOR_INTS(signed long)\012  INIT_ARRAY_SPECIAL_VAL_FOR_INTS(unsigned long)\012  INIT_ARRAY_SPECIAL_VAL_FOR_INTS(signed long long)\012  INIT_ARRAY_SPECIAL_VAL_FOR_INTS(unsigned long long)\012}\012\012#ifdef __AC_NAMESPACE\012}\012#endif\012\012#endif // __INTELFPGA_COMPILER__\012#endif // __ALTR_AC_INT_H\012"}, {"path":"C:/intelFPGA_lite/18.1/hls/include/HLS/hls.h", "name":"hls.h", "has_active_debug_locs":false, "absName":"c:/intelFPGA_lite/18.1/hls/include/HLS/hls.h", "content":"#ifndef __HLS_H__\012#define __HLS_H__\012\012#ifndef __INTELFPGA_COMPILER__\012#ifndef component\012#define component\012#endif\012#define HLS_X86\012#endif\012\012#include \"HLS/hls_internal.h\"\012\012/* Deprecated APIs and names after intel rebranding */\012#ifdef __IHC_USE_DEPRECATED_NAMES\012#pragma message \"Warning: Enabling deprecated names - these names will not be supported in future releases.\"\012namespace ihc {}\012namespace altera = ihc;\012#define altera_hls_component_run_all ihc_hls_component_run_all\012#define altera_fence ihc_fence\012#define altera_hls_get_sim_time ihc_hls_get_sim_time\012#define altera_hls_enqueue ihc_hls_enqueue\012#define altera_hls_enqueue_noret ihc_hls_enqueue_noret\012#endif\012\012#ifdef __INTELFPGA_COMPILER__\012// Memory attributes\012#define hls_register                                  __attribute__((__register__))\012#define hls_memory                                    __attribute__((__memory__))\012#define hls_numbanks(__x)                             __attribute__((__numbanks__(__x)))\012#define hls_bankwidth(__x)                            __attribute__((__bankwidth__(__x)))\012#define hls_singlepump                                __attribute__((__singlepump__))\012#define hls_doublepump                                __attribute__((__doublepump__))\012#define hls_numports_readonly_writeonly(__rd, __wr)   __attribute__((__numports_readonly_writeonly__(__rd, __wr)))\012#define hls_bankbits(__x, ...)                        __attribute__((__bank_bits__(__x, ##__VA_ARGS__)))\012#define hls_merge(__x, __y)                           __attribute__((merge(__x, __y)))\012#define hls_init_on_reset                             __attribute__((__static_array_reset__(1)))\012#define hls_init_on_powerup                           __attribute__((__static_array_reset__(0)))\012#define hls_numreadports(__x)                         __attribute__((__numreadports__(__x)))\012#define hls_numwriteports(__x)                        __attribute__((__numwriteports__(__x)))\012\012// Memory attribute macros\012#define hls_simple_dual_port_memory hls_memory hls_singlepump hls_numports_readonly_writeonly(1,1)\012\012// Interface synthesis attributes\012#define hls_avalon_streaming_component         __attribute__((component_interface(\"avalon_streaming\")))\012#define hls_avalon_slave_component             __attribute__((component_interface(\"avalon_mm_slave\"))) __attribute__((stall_free_return))\012#define hls_always_run_component               __attribute__((component_interface(\"always_run\"))) __attribute__((stall_free_return))\012#define hls_conduit_argument                   __attribute__((argument_interface(\"wire\")))\012#define hls_avalon_slave_register_argument     __attribute__((argument_interface(\"avalon_mm_slave\")))\012#define hls_avalon_slave_memory_argument(__x)  __attribute__((local_mem_size(__x))) __attribute__((slave_memory_argument))\012#define hls_stable_argument                    __attribute__((stable_argument))\012#define hls_stall_free_return                  __attribute__((stall_free_return))\012\012// Component attributes\012#define hls_max_concurrency(__x)               __attribute__((max_concurrency(__x)))\012\012#else\012#define hls_register\012#define hls_memory\012#define hls_numbanks(__x)\012#define hls_bankwidth(__x)\012#define hls_singlepump\012#define hls_doublepump\012#define hls_numports_readonly_writeonly(__rd, __wr)\012#define hls_bankbits(__x, ...)\012#define hls_merge(__x, __y)\012#define hls_init_on_reset\012#define hls_init_on_powerup\012\012#define hls_numreadports(__x)\012#define hls_numwriteports(__x)\012\012#define hls_simple_dual_port_memory\012\012#define hls_avalon_streaming_component\012#define hls_avalon_slave_component\012#define hls_always_run_component\012#define hls_conduit_argument\012#define hls_avalon_slave_register_argument\012#define hls_avalon_slave_memory_argument(__x)\012#define hls_stable_argument\012#define hls_stall_free_return\012\012#define hls_max_concurrency(__x)\012\012#endif\012\012////////////////////////////////////////////////////////////////////////////////\012// Interfaces Declarations\012////////////////////////////////////////////////////////////////////////////////\012\012namespace ihc {\012\012  ////////////////////////////////\012 /// memory master interface  ///\012////////////////////////////////\012\012template <int n>         class dwidth:public internal::param {};\012template <int n>         class awidth:public internal::param {};\012template <int n>         class latency: public internal::param {};\012template <readwrite_t n> class readwrite_mode: public internal::param{}; // declared in hls_internal.h as enum readwrite_t {readwrite = 0, readonly = 1, writeonly = 2};\012template <int n>         class maxburst: public internal::param {};\012template <int n>         class align: public internal::param {};\012template <int n>         class aspace: public internal::param {};\012template <bool n>        class waitrequest: public internal::param{};\012\012template <typename DT, typename p1 = internal::notinit, typename p2 = internal::notinit, typename p3 = internal::notinit, typename p4 = internal::notinit, typename p5 = internal::notinit, typename p6 = internal::notinit, typename p7 = internal::notinit, typename p8 = internal::notinit>\012class mm_master\012#ifdef HLS_X86\012  : public internal::memory_base\012#endif\012{\012public:\012\012#ifdef HLS_X86\012  template<typename T> explicit mm_master(T *data, int size=0, bool use_socket=false):internal::memory_base(data,size,sizeof(DT),use_socket) {\012  }\012#else\012  template<typename T> explicit mm_master(T *data, int size=0, bool use_socket=false);\012#endif\012\012  //////////////////////////////////////////////////////////////////////////////\012  // The following operators apply to the mm_master object and are only\012  // supported in the testbench:\012  //   mm_master()\012  //   getInterfaceAtIndex()\012  //////////////////////////////////////////////////////////////////////////////\012  // The following operators apply to the base pointer and should only be used\012  // in the component:\012  //   operator[]()\012  //   operator*()\012  //   operator->()\012  //   operator T()\012  //   operator+()\012  //   operator&()\012  //   operator|()\012  //   operator^()\012  //////////////////////////////////////////////////////////////////////////////\012\012  DT &operator[](int index);\012  DT &operator*();\012  DT *operator->();\012  template<typename T> operator T();\012  DT *operator+(int index);\012  template<typename T> DT *operator&(T value);\012  template<typename T> DT *operator|(T value);\012  template<typename T> DT *operator^(T value);\012  // This function is only supported in the testbench:\012  mm_master<DT, p1, p2, p3, p4, p5, p6, p7, p8>& getInterfaceAtIndex(int index);\012\012#ifdef HLS_X86\012  // The copy constructor and assignment operator are necessary to ensure\012  // new_masters doesn't get copied.\012  mm_master(const mm_master &other) {\012    mem = other.mem;\012    size = other.size;\012    data_size = other.data_size;\012    use_socket = other.use_socket;\012  }\012  mm_master& operator=(const mm_master& other) {\012    mem = other.mem;\012    size = other.size;\012    data_size = other.data_size;\012    use_socket = other.use_socket;\012  }\012  // Clean up any derrived mm_masters when this object is destroyed.\012  ~mm_master() {\012    for(std::vector<internal::memory_base* >::iterator it = new_masters.begin(),\012        ie = new_masters.end(); it != ie; it++) {\012      delete *it;\012    }\012    new_masters.clear();\012  }\012private:\012  std::vector<internal::memory_base* > new_masters;\012#endif\012\012};\012\012  /////////////////////////////\012 /// streaming interfaces  ///\012//////////////////////////////\012\012template <int n> class buffer:public internal::param {};\012template <int n> class readyLatency:public internal::param {};\012template <int n> class bitsPerSymbol:public internal::param {};\012template <bool b> class usesPackets:public internal::param {};\012template <bool b> class usesValid:public internal::param {};\012template <bool b> class usesReady:public internal::param {};\012\012template <typename T, typename p1 = internal::notinit , typename p2 = internal::notinit, typename p3 = internal::notinit, typename p4 = internal::notinit, typename p5 = internal::notinit>\012class stream_in : public internal::stream<T,p1,p2,p3,p4,p5> {\012public:\012  stream_in();\012  T read();\012  void write(T arg);\012  T tryRead(bool &success);\012  bool tryWrite(T arg);\012\012  // for packet based stream\012  T read(bool& sop, bool& eop);\012  void write(T arg, bool sop, bool eop);\012  T tryRead(bool &success, bool& sop, bool& eop);\012  bool tryWrite(T arg, bool sop, bool eop);\012  void setStallCycles(unsigned average_stall, unsigned stall_delta=0);\012  void setValidCycles(unsigned average_valid, unsigned valid_delta=0);\012};\012\012template <typename T, typename p1 = internal::notinit , typename p2 = internal::notinit, typename p3 = internal::notinit, typename p4 = internal::notinit, typename p5 = internal::notinit>\012class stream_out : public internal::stream<T,p1,p2,p3,p4,p5> {\012\012public:\012  stream_out();\012  T read();\012  void write(T);\012  T tryRead(bool &success);\012  bool tryWrite(T arg);\012\012  // for packet based stream\012  T read(bool& sop, bool& eop);\012  void write(T arg, bool sop, bool eop);\012  T tryRead(bool &success, bool& sop, bool& eop);\012  bool tryWrite(T arg, bool sop, bool eop);\012  void setStallCycles(unsigned average_stall, unsigned stall_delta=0);\012  void setReadyCycles(unsigned average_ready, unsigned ready_delta=0);\012};\012\012}//namespace ihc\012\012////////////////////////////////////////////////////////////////////////////////\012// HLS Cosimulation Support API\012////////////////////////////////////////////////////////////////////////////////\012\012#define ihc_hls_enqueue(retptr, func, ...) \\\012  { \\\012    if (__ihc_hls_async_call_capable()){ \\\012      __ihc_enqueue_handle=(retptr); \\\012      (void) (*(func))(__VA_ARGS__); \\\012      __ihc_enqueue_handle=0; \\\012    } else { \\\012      *(retptr) = (*(func))(__VA_ARGS__); \\\012    } \\\012  }\012\012#define ihc_hls_enqueue_noret(func, ...) \\\012  { \\\012  __ihc_enqueue_handle=& __ihc_enqueue_handle; \\\012  (*(func))(__VA_ARGS__); \\\012  __ihc_enqueue_handle=0; \\\012  }\012\012#define ihc_hls_component_run_all(component_address) \\\012  __ihc_hls_component_run_all((void*) (component_address))\012\012// When running a simulation, this function will issue a reset to all components\012// in the testbench\012// Returns: 0 if reset did not occur (ie. if the component target is x86)\012//          1 if reset occured (ie. if the component target is an FPGA)\012extern \"C\" int ihc_hls_sim_reset(void);\012\012////////////////////////////////////////////////////////////////////////////////\012// HLS Component Built-Ins\012////////////////////////////////////////////////////////////////////////////////\012\012//Builtin memory fence function call\012#ifdef HLS_X86\012inline void ihc_fence() {};\012\012#else\012extern \"C\" void mem_fence(int);\012inline void ihc_fence() {\012  // fence on all types of fences from OpenCL\012  mem_fence(-1);\012}\012#endif\012\012////////////////////////////////////////////////////////////////////////////////\012// Implementions, no declarations below\012////////////////////////////////////////////////////////////////////////////////\012\012namespace ihc {\012#ifdef HLS_X86\012\012  //////////////////\012 /// mm_master  ///\012//////////////////\012\012template <typename DT, typename p1, typename p2, typename p3, typename p4, typename p5, typename p6, typename p7, typename p8>\012DT &mm_master<DT, p1, p2, p3, p4, p5, p6, p7, p8>::operator[](int index) {\012  assert(size==0 || index*data_size<size);\012  return ((DT*)mem)[index];\012}\012\012template <typename DT, typename p1, typename p2, typename p3, typename p4, typename p5, typename p6, typename p7, typename p8>\012DT &mm_master<DT, p1, p2, p3, p4, p5, p6, p7, p8>::operator*() {\012  return ((DT*)mem)[0];\012}\012\012template <typename DT, typename p1, typename p2, typename p3, typename p4, typename p5, typename p6, typename p7, typename p8>\012DT *mm_master<DT, p1, p2, p3, p4, p5, p6, p7, p8>::operator->() {\012  return (DT*)mem;\012}\012\012template <typename DT, typename p1, typename p2, typename p3, typename p4, typename p5, typename p6, typename p7, typename p8>\012template<typename T> mm_master<DT, p1, p2, p3, p4, p5, p6, p7, p8>::operator T() {\012  return (T)((unsigned long long)mem);\012}\012\012template <typename DT, typename p1, typename p2, typename p3, typename p4, typename p5, typename p6, typename p7, typename p8>\012DT *mm_master<DT, p1, p2, p3, p4, p5, p6, p7, p8>::operator+(int index) {\012  assert(size==0 || index*data_size<size);\012  return &((DT*)mem)[index];\012}\012\012// Bitwise operators\012template <typename DT, typename p1, typename p2, typename p3, typename p4, typename p5, typename p6, typename p7, typename p8>\012template<typename T> DT *mm_master<DT, p1, p2, p3, p4, p5, p6, p7, p8>::operator&(T value) {\012  return (DT*)((unsigned long long)mem & (unsigned long long)value);\012}\012\012template <typename DT, typename p1, typename p2, typename p3, typename p4, typename p5, typename p6, typename p7, typename p8>\012template<typename T> DT *mm_master<DT, p1, p2, p3, p4, p5, p6, p7, p8>::operator|(T value) {\012  return (DT*)((unsigned long long)mem | (unsigned long long)value);\012}\012\012template <typename DT, typename p1, typename p2, typename p3, typename p4, typename p5, typename p6, typename p7, typename p8>\012template<typename T> DT *mm_master<DT, p1, p2, p3, p4, p5, p6, p7, p8>::operator^(T value) {\012  return (DT*)((unsigned long long)mem ^ (unsigned long long)value);\012}\012\012// Function for creating new mm_master at an offset\012template <typename DT, typename p1, typename p2, typename p3, typename p4, typename p5, typename p6, typename p7, typename p8>\012mm_master<DT, p1, p2, p3, p4, p5, p6, p7, p8>& mm_master<DT, p1, p2, p3, p4, p5, p6, p7, p8>::getInterfaceAtIndex(int index) {\012  assert(size==0 || index*data_size<size);\012  // This new object is cleaned up when this' destructor is called.\012  mm_master<DT, p1, p2, p3, p4, p5, p6, p7, p8> *temp = new mm_master(&(((DT*)mem)[index]), size - index * sizeof(DT), use_socket);\012  new_masters.push_back(temp);\012  return *temp;\012}\012\012  ///////////////////\012 /// stream_in   ///\012///////////////////\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012stream_in<T,p1,p2,p3,p4,p5>::stream_in() {}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012T stream_in<T,p1,p2,p3,p4,p5>::tryRead(bool &success) {\012  success = !internal::stream<T,p1,p2,p3,p4,p5>::_internal_cosim_empty();\012  if (success) {\012    return read();\012  } else {\012    return T();\012  }\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012T stream_in<T,p1,p2,p3,p4,p5>::read() {\012    T elem = internal::stream<T,p1,p2,p3,p4,p5>::read();\012    return elem;\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012bool stream_in<T,p1,p2,p3,p4,p5>::tryWrite(T arg) {\012  bool success = true; /* stl::queue has no full */\012  if (success) {\012    write(arg);\012  }\012  return success;\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012void stream_in<T,p1,p2,p3,p4,p5>::write(T arg) {\012    internal::stream<T,p1,p2,p3,p4,p5>::write(arg);\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012T stream_in<T,p1,p2,p3,p4,p5>::tryRead(bool &success, bool& sop, bool& eop) {\012  success = !internal::stream<T,p1,p2,p3,p4,p5>::_internal_cosim_empty();\012  if (success) {\012    return read(sop, eop);\012  } else {\012    return T();\012  }\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012T stream_in<T,p1,p2,p3,p4,p5>::read(bool& sop, bool& eop) {\012    T elem = internal::stream<T,p1,p2,p3,p4,p5>::read(sop, eop);\012    return elem;\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012bool stream_in<T,p1,p2,p3,p4,p5>::tryWrite(T arg, bool sop, bool eop) {\012  bool success = true; /* stl::queue has no full */\012  if (success) {\012    write(arg, sop, eop);\012  }\012  return success;\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012void stream_in<T,p1,p2,p3,p4,p5>::write(T arg, bool sop, bool eop) {\012    internal::stream<T,p1,p2,p3,p4,p5>::write(arg, sop, eop);\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012void stream_in<T,p1,p2,p3,p4,p5>::setStallCycles(unsigned average_stall, unsigned stall_delta) {\012  if (stall_delta > average_stall) {\012    __ihc_hls_runtime_error_x86(\"The stall delta in setStallCycles cannot be larger than the average stall value\");\012  }\012  internal::stream<T,p1,p2,p3,p4,p5>::setStallCycles(average_stall, stall_delta);\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012void stream_in<T,p1,p2,p3,p4,p5>::setValidCycles(unsigned average_valid, unsigned valid_delta) {\012  if (average_valid == 0) {\012    __ihc_hls_runtime_error_x86(\"The valid average in setValidCycles must be at least 1\");\012  }\012  if (valid_delta > average_valid) {\012    __ihc_hls_runtime_error_x86(\"The valid delta in setValidCycles cannot be larger than the average valid value\");\012  }\012  internal::stream<T,p1,p2,p3,p4,p5>::setReadyorValidCycles(average_valid, valid_delta);\012}\012\012  ///////////////////\012 /// stream_out  ///\012///////////////////\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012stream_out<T,p1,p2,p3,p4,p5>::stream_out() {\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012T stream_out<T,p1,p2,p3,p4,p5>::tryRead(bool &success) {\012  success = !internal::stream<T,p1,p2,p3,p4,p5>::_internal_cosim_empty();\012  if (success) {\012    return read();\012  } else {\012    return T();\012  }\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012T stream_out<T,p1,p2,p3,p4,p5>::read() {\012    T elem = internal::stream<T,p1,p2,p3,p4,p5>::read();\012    return elem;\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012void stream_out<T,p1,p2,p3,p4,p5>::write(T arg) {\012    internal::stream<T,p1,p2,p3,p4,p5>::write(arg);\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012bool stream_out<T,p1,p2,p3,p4,p5>::tryWrite(T arg) {\012  bool success = true; /* stl::queue has no full */\012  if (success) {\012    write(arg);\012  }\012  return success;\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012T stream_out<T,p1,p2,p3,p4,p5>::tryRead(bool &success, bool& sop, bool& eop) {\012  success = !internal::stream<T,p1,p2,p3,p4,p5>::_internal_cosim_empty();\012  if (success) {\012    return read(sop, eop);\012  } else {\012    return T();\012  }\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012T stream_out<T,p1,p2,p3,p4,p5>::read(bool& sop, bool& eop) {\012    T elem = internal::stream<T,p1,p2,p3,p4,p5>::read(sop, eop);\012    return elem;\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012void stream_out<T,p1,p2,p3,p4,p5>::write(T arg, bool sop, bool eop) {\012    internal::stream<T,p1,p2,p3,p4,p5>::write(arg, sop, eop);\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012bool stream_out<T,p1,p2,p3,p4,p5>::tryWrite(T arg, bool sop, bool eop) {\012  bool success = true; /* stl::queue has no full */\012  if (success) {\012    write(arg, sop, eop);\012  }\012  return success;\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012void stream_out<T,p1,p2,p3,p4,p5>::setStallCycles(unsigned average_stall, unsigned stall_delta) {\012  if (stall_delta > average_stall) {\012    __ihc_hls_runtime_error_x86(\"The stall delta in setStallCycles cannot be larger than the average stall value\");\012  }\012  internal::stream<T,p1,p2,p3,p4,p5>::setStallCycles(average_stall, stall_delta);\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012void stream_out<T,p1,p2,p3,p4,p5>::setReadyCycles(unsigned average_ready, unsigned ready_delta) {\012  if (average_ready == 0) {\012    __ihc_hls_runtime_error_x86(\"The ready average in setReadCycles must be at least 1\");\012  }\012  if (ready_delta > average_ready) {\012    __ihc_hls_runtime_error_x86(\"The ready delta in setReadyCycles cannot be larger than the average ready value\");\012  }\012  internal::stream<T,p1,p2,p3,p4,p5>::setReadyorValidCycles(average_ready, ready_delta);\012}\012#else //fpga path. Ignore the class just return a consistant pointer/reference\012\012  //////////////////\012 /// mm_master  ///\012//////////////////\012\012template <typename DT, typename p1, typename p2, typename p3, typename p4, typename p5, typename p6, typename p7, typename p8>\012DT &mm_master<DT, p1, p2, p3, p4, p5, p6, p7, p8>::operator[](int index) {\012  return ((DT*)this)[index];\012}\012\012template <typename DT, typename p1, typename p2, typename p3, typename p4, typename p5, typename p6, typename p7, typename p8>\012DT &mm_master<DT, p1, p2, p3, p4, p5, p6, p7, p8>::operator*(){\012  return *((DT*)this);\012}\012\012template <typename DT, typename p1, typename p2, typename p3, typename p4, typename p5, typename p6, typename p7, typename p8>\012DT *mm_master<DT, p1, p2, p3, p4, p5, p6, p7, p8>::operator->() {\012  return (DT*)this;\012}\012\012template <typename DT, typename p1, typename p2, typename p3, typename p4, typename p5, typename p6, typename p7, typename p8>\012DT *mm_master<DT, p1, p2, p3, p4, p5, p6, p7, p8>::operator+(int index) {\012  return ((DT*)this)+index;\012}\012\012template <typename DT, typename p1, typename p2, typename p3, typename p4, typename p5, typename p6, typename p7, typename p8>\012template<typename T> mm_master<DT, p1, p2, p3, p4, p5, p6, p7, p8>::operator T() {\012  return (T)((unsigned long long)this);\012}\012\012// Bitwise operators\012template <typename DT, typename p1, typename p2, typename p3, typename p4, typename p5, typename p6, typename p7, typename p8>\012template<typename T> DT *mm_master<DT, p1, p2, p3, p4, p5, p6, p7, p8>::operator&(T value) {\012  return (DT*)((unsigned long long)this & (unsigned long long)value);\012}\012\012template <typename DT, typename p1, typename p2, typename p3, typename p4, typename p5, typename p6, typename p7, typename p8>\012template<typename T> DT *mm_master<DT, p1, p2, p3, p4, p5, p6, p7, p8>::operator|(T value) {\012  return (DT*)((unsigned long long)this | (unsigned long long)value);\012}\012\012template <typename DT, typename p1, typename p2, typename p3, typename p4, typename p5, typename p6, typename p7, typename p8>\012template<typename T> DT *mm_master<DT, p1, p2, p3, p4, p5, p6, p7, p8>::operator^(T value) {\012  return (DT*)((unsigned long long)this ^ (unsigned long long)value);\012}\012\012#endif\012} // namespace ihc\012\012#endif\012\012"}, {"path":"C:/intelFPGA_lite/18.1/hls/include/HLS/hls_internal.h", "name":"hls_internal.h", "has_active_debug_locs":false, "absName":"c:/intelFPGA_lite/18.1/hls/include/HLS/hls_internal.h", "content":"#ifndef __HLS_INTERNAL_H__\012#define __HLS_INTERNAL_H__\012\012#ifdef HLS_X86\012#include <queue>\012#include <string.h> //memcpy\012#include <assert.h>\012#endif\012#include <stdio.h>\012#include <stdlib.h>\012\012#if defined(__clang__) //our llvm defines _MSC_VER so check this first\012  #define WINDOWSWEAK\012  #define LINUXWEAK __attribute__((weak))\012#elif defined(_MSC_VER)\012  #define WINDOWSWEAK __declspec(selectany)\012  #define LINUXWEAK\012#else\012  #define WINDOWSWEAK\012  #define LINUXWEAK __attribute__((weak))\012#endif\012\012WINDOWSWEAK void *__ihc_enqueue_handle LINUXWEAK;\012\012extern \"C\" unsigned long long ihc_hls_get_sim_time(void);\012extern \"C\" int __ihc_hls_get_clock_period_ps(void);\012extern \"C\" int __ihc_hls_component_start_sim_task(const char *component_name);\012extern \"C\" int __ihc_hls_component_wait_sim_task(const char *component_name);\012extern \"C\" void __ihc_hls_stream_sink_wait_sim_task(void* obj_ptr);\012extern \"C\" void __ihc_hls_component_run_all(const void* component_address);\012\012// Cosim internal support calls\012extern \"C\" int __ihc_hls_async_call_capable(void);\012// Print error message and bail\012extern \"C\" void __ihc_hls_runtime_error(const char *msg);\012inline void __ihc_hls_runtime_error_x86(const char *msg){\012  printf(\"Error: %s\\n\",msg);\012  exit(1);\012}\012\012enum readwrite_t {readwrite = 0, readonly = 1, writeonly = 2};\012\012namespace ihc {\012// Forward declarations so I can make them friends\012template <typename DT, typename p1, typename p2, typename p3, typename p4, typename p5, typename p6, typename p7, typename p8> class mm_master;\012template <typename T, typename p1, typename p2, typename p3, typename p4, typename p5> class stream_in;\012template <typename T, typename p1, typename p2, typename p3, typename p4, typename p5> class stream_out;\012\012namespace internal {\012\012\012// Interface parameter base types used to define interfaces\012class param {};\012class notinit:public param {};\012\012class memory_base {\012private:\012#ifdef HLS_X86\012  // Attributes\012  int aspace; \012  int awidth;\012  int dwidth;\012  int latency;\012  readwrite_t readwrite_mode;\012  bool byteenabled;\012  int maxburst;\012  int align;\012  bool waitrequest;\012  \012  size_t sim_base;\012  // Extra cosim book keeping\012  size_t data_size; //size of the underlying type used by the interface\012  void *mem;\012  size_t size;\012  bool use_socket; // if true, all reads and writes will go through the IPC socket instead of shared memory\012\012  //Make sure only the listed classes can reach the destructor, and nothing derived from them\012  ~memory_base() {}; // Cannot inherit from HLS interface\012  template <typename DT, typename p1, typename p2, typename p3, typename p4, typename p5, typename p6, typename p7, typename p8> friend class ::ihc::mm_master;\012\012  //description of test data buffer accessed through this interface\012  void set_mem(void *x) {mem=x;};\012  void set_size(size_t x) {size=x;};\012  void set_data_size(size_t datasize) {data_size = datasize;}\012  \012#endif\012public:\012#ifdef HLS_X86\012  memory_base() {}\012  memory_base(void *mem, size_t size, size_t data_size, bool use_socket):data_size(data_size),mem(mem),size(size),use_socket(use_socket) {}\012  memory_base(int aspace, int awidth, int dwidth,  int latency, readwrite_t readwrite_mode, bool byteenabled, int maxburst, int align, bool waitrequest );\012\012  void set_parameters(int aspace, int awidth, int dwidth,  int latency, readwrite_t readwrite_mode, bool byteenabled, int maxburst, int align, bool waitrequest );\012  void set_base(void *ptr, size_t datasize, size_t size, bool use_socket);\012  int get_interface_aspace() {return aspace;}\012  void * get_base(){return mem;}\012  size_t get_size() {return size;}\012  int get_awidth() {return awidth;}\012  int get_dwidth() {return dwidth;}\012  int get_latency() {return latency;}\012  readwrite_t get_readwrite_mode() {return readwrite_mode;}\012  bool get_byteenabled() {return byteenabled;}\012  int get_maxburst() {return maxburst;}\012  int get_align() {return align;}\012  bool get_waitrequest() {return waitrequest;}\012  \012  size_t get_data_size() {return data_size;}\012\012  void set_sim_base(size_t addr) {sim_base = addr;}\012  size_t get_sim_base() {return sim_base;}\012  \012  void set_use_socket(bool socket) {use_socket = socket;}\012  bool uses_socket() {return use_socket;}\012#endif\012};\012\012#ifdef HLS_X86\012class stream_abstract_base {\012  bool stable; // does the data on this interface change between function calls?\012  bool implicit; // is this interface synchronous with the component's function call interface?\012  bool global; // is this an implicit interface that carries a global variable's address?\012  size_t data_size; //size of the underlying type used by the interface\012protected:\012  unsigned m_average_stall;\012  unsigned m_stall_delta;\012  unsigned m_average_RoV;\012  unsigned m_RoV_delta;\012  unsigned m_remaining_period;\012  unsigned m_period_threshold;\012public:\012stream_abstract_base():stable(false), implicit(false), global(false), m_average_stall(0), m_stall_delta(0), m_average_RoV(1), m_RoV_delta(0), m_remaining_period(1), m_period_threshold(1) { assert(1==0);}\012stream_abstract_base(size_t data_size):stable(false), implicit(false), global(false), data_size(data_size), m_average_stall(0), m_stall_delta(0), m_average_RoV(1), m_RoV_delta(0), m_remaining_period(1), m_period_threshold(1){}\012  bool is_stable() {return stable;}\012  void set_stable() {stable = true;}\012  bool is_implicit() {return implicit;}\012  bool is_global() {return global;}\012  void set_implicit() {implicit = true;}\012  void set_global() {global = true;}\012  size_t get_data_size() {return data_size;}\012  void set_data_size(size_t datasize) {data_size = datasize;}\012  unsigned get_average_stall() {return m_average_stall;}\012  unsigned get_stall_delta() {return m_stall_delta;}\012  unsigned get_average_RoV() {return m_average_RoV;}\012  unsigned get_RoV_delta() {return m_RoV_delta;}\012  virtual bool _internal_cosim_empty() = 0;\012  virtual void read_by_ptr(void *data) = 0;\012  virtual void read_by_ptr_pkt(void *data, bool* sop, bool* eop) = 0;\012  virtual void write_by_ptr(void *data) = 0;\012  virtual void write_by_ptr_pkt(void *data, bool* sop, bool* eop) = 0;\012  virtual void front_by_ptr(void *data) = 0;\012  virtual void front_by_ptr_pkt(void *data, bool* sop, bool* eop) = 0;\012  virtual size_t get_size() = 0;\012};\012#endif\012\012template<typename T, typename p1 = notinit, typename p2 = notinit, typename p3 = notinit, typename p4 = notinit, typename p5 = notinit>\012class stream \012#ifdef HLS_X86\012  :  public stream_abstract_base \012#endif\012{\012   ~stream() {} // Cannot inherit from HLS interface\012  //Make sure only the listed classes can reach the destructor, and nothing derived from them\012  template <typename T1, typename p11, typename p21, typename p31, typename p41, typename p51> friend class ihc::stream_in;\012  template <typename T1, typename p11, typename p21, typename p31, typename p41, typename p51> friend class ihc::stream_out;\012\012#ifdef HLS_X86\012  std::queue<T> q_;\012  std::queue<std::pair<bool,bool> > qp_;\012#endif\012  \012protected:\012  stream();\012  \012#ifdef HLS_X86\012  stream(const stream<T,p1,p2,p3,p4,p5>& copy_from);\012#endif\012  \012public:     \012  bool _internal_cosim_empty(); \012#ifdef HLS_X86\012  virtual T read();               \012  virtual void write(T arg);      \012  virtual T tryRead(bool &success);   \012  virtual bool tryWrite(T arg);       \012\012  // for packet based stream \012  virtual T read(bool& sop, bool& eop);\012  virtual void write(T arg, bool sop, bool eop);\012  virtual T tryRead(bool &success, bool& sop, bool& eop);\012  virtual bool tryWrite(T arg, bool sop, bool eop);     \012  virtual void setStallCycles(unsigned average_stall, unsigned stall_delta=0);\012  virtual void setReadyorValidCycles(unsigned average_RoV, unsigned RoV_delta=0);\012#else\012  T read();               \012  void write(T arg);      \012  T tryRead(bool &success); \012  bool tryWrite(T arg);       \012\012  // for packet based stream \012  T read(bool& sop, bool& eop);\012  void write(T arg, bool sop, bool eop);\012  T tryRead(bool &success, bool& sop, bool& eop);\012  bool tryWrite(T arg, bool sop, bool eop);     \012#endif\012   T _internal_cosim_front();\012   T _internal_cosim_front(bool& sop, bool& eop);\012  \012#ifdef HLS_X86\012  void read_by_ptr(void *data);\012  void read_by_ptr_pkt(void *data, bool* sop, bool* eop);\012  void write_by_ptr(void *data);\012  void write_by_ptr_pkt(void *data, bool* sop, bool*eop);\012  void front_by_ptr(void *data);\012  void front_by_ptr_pkt(void *data, bool* sop, bool* eop);\012  size_t get_size() {return q_.size();}\012\012  // control stall/valid behaviour\012  bool stall();\012  void setStallPeriod();\012  //Middle Square Weyl Sequence RNG\012   unsigned msws();\012#endif\012};\012\012template <typename T, typename p1 , typename p2, typename p3, typename p4, typename p5>\012  stream<T,p1,p2,p3,p4,p5>::stream()\012#ifdef HLS_X86\012 :stream_abstract_base(sizeof(T))\012#endif\012{\012}\012#ifdef HLS_X86\012template <typename T, typename p1 , typename p2, typename p3, typename p4, typename p5>\012  stream<T,p1,p2,p3,p4,p5>::stream(const stream<T,p1,p2,p3,p4,p5>& copy_from):stream_abstract_base(sizeof(T)),q_(copy_from.q_),qp_(copy_from.qp_)\012{\012}\012#endif\012\012  ////////////////\012 /// stream   ///\012////////////////\012\012#ifdef HLS_X86\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012bool stream<T,p1,p2,p3,p4,p5>::_internal_cosim_empty() {\012  bool empty=q_.empty();  \012  return empty;\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012T stream<T,p1,p2,p3,p4,p5>::tryRead(bool &success) {\012  success = !_internal_cosim_empty();\012  if (success) {\012    return read();\012  } else {\012    return T();\012  }\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012T stream<T,p1,p2,p3,p4,p5>::tryRead(bool &success, bool& sop, bool& eop) {\012  success = !_internal_cosim_empty();\012  if (success) {\012    return read(sop,eop);\012  } else {\012    return T();\012  }\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012T stream<T,p1,p2,p3,p4,p5>::read() {\012  T arg;      \012  \012  bool empty = _internal_cosim_empty();\012  if(empty) __ihc_hls_runtime_error_x86(\"Cannot do a blocking read from an empty stream on an x86 target\");\012\012  arg = q_.front();\012  q_.pop();\012  qp_.pop(); //unused sideband signals\012  \012  return arg;\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012T stream<T,p1,p2,p3,p4,p5>::read(bool& sop, bool& eop) {\012  T arg;\012\012  bool empty = _internal_cosim_empty();\012  if(empty) __ihc_hls_runtime_error_x86(\"Cannot do a blocking read from an empty stream on an x86 target\");\012\012  arg = q_.front();\012  q_.pop();\012  std::pair<bool,bool> p = qp_.front();\012  qp_.pop(); //unused sideband signals\012  \012  sop = p.first;\012  eop = p.second;\012\012  return arg;\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012T stream<T,p1,p2,p3,p4,p5>::_internal_cosim_front() {\012  T arg;      \012    \012  bool empty = _internal_cosim_empty();\012  if(empty) __ihc_hls_runtime_error_x86(\"Cannot do a blocking read from an empty stream on an x86 target\");\012\012  arg = q_.front();\012  \012  return arg;\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012T stream<T,p1,p2,p3,p4,p5>::_internal_cosim_front(bool& sop, bool& eop) {\012  T arg;      \012    \012  bool empty = _internal_cosim_empty();\012  if(empty) __ihc_hls_runtime_error_x86(\"Cannot do a blocking read from an empty stream on an x86 target\");\012\012  arg = q_.front();\012  std::pair<bool,bool> p = qp_.front();\012\012  sop = p.first;\012  eop = p.second;\012  \012  return arg;\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012bool stream<T,p1,p2,p3,p4,p5>::tryWrite(T arg) {\012   bool success = true; /* stl::queue has no full */\012   if (success) {\012      write(arg);\012   }\012   return success;\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012bool stream<T,p1,p2,p3,p4,p5>::tryWrite(T arg, bool sop, bool eop) {\012   bool success = true; /* stl::queue has no full */\012   if (success) {\012      write(arg, sop, eop);\012   }\012   return success;\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012void stream<T,p1,p2,p3,p4,p5>::write(T arg) {\012    q_.push(arg);\012    qp_.push(std::pair<bool,bool>(false,false)); // sideband signals\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012void stream<T,p1,p2,p3,p4,p5>::write(T arg, bool sop, bool eop) {\012    q_.push(arg);\012    qp_.push(std::pair<bool,bool>(sop, eop)); // sideband signals\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012void stream<T,p1,p2,p3,p4,p5>::read_by_ptr(void *data) {\012    T elem = read();\012    memcpy(data, &elem, sizeof(T));\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012void stream<T,p1,p2,p3,p4,p5>::read_by_ptr_pkt(void *data, bool* sop, bool* eop) {\012    T elem = read(*sop, *eop);\012    memcpy(data, &elem, sizeof(T));\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012void stream<T,p1,p2,p3,p4,p5>::front_by_ptr_pkt(void *data, bool* sop, bool* eop) {\012    T elem = _internal_cosim_front(*sop, *eop);\012    memcpy(data, &elem, sizeof(T));    \012}\012\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012void stream<T,p1,p2,p3,p4,p5>::front_by_ptr(void *data) {\012    T elem = _internal_cosim_front();\012    memcpy(data, &elem, sizeof(T));    \012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012void stream<T,p1,p2,p3,p4,p5>::write_by_ptr_pkt(void *data, bool* sop, bool* eop) {\012    T elem;\012    memcpy(&elem, data, sizeof(T));\012    write(elem, *sop, *eop);\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012void stream<T,p1,p2,p3,p4,p5>::write_by_ptr(void *data) {\012    T elem;\012    memcpy(&elem, data, sizeof(T));\012    write(elem);\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012void stream<T,p1,p2,p3,p4,p5>::setStallPeriod() {\012    if (m_stall_delta == 0) {\012        m_remaining_period = m_average_stall;\012    } else {\012        m_remaining_period = (m_average_stall - m_stall_delta) + msws()%(m_stall_delta*2+1);\012    }\012    if (m_RoV_delta == 0) {\012        m_period_threshold = m_average_RoV;\012    } else {\012        m_period_threshold = (m_average_RoV - m_RoV_delta) + msws()%(m_RoV_delta*2+1);\012    }\012    m_remaining_period +=  m_period_threshold;\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012  void stream<T,p1,p2,p3,p4,p5>::setStallCycles(unsigned average_stall, unsigned stall_delta) {\012    m_average_stall = average_stall;\012    m_stall_delta = stall_delta;\012    setStallPeriod();\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012  void stream<T,p1,p2,p3,p4,p5>::setReadyorValidCycles(unsigned average_RoV, unsigned RoV_delta) {\012    m_average_RoV = average_RoV;\012    m_RoV_delta = RoV_delta;\012    setStallPeriod();\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012bool stream<T,p1,p2,p3,p4,p5>::stall() {\012  if (m_remaining_period > 0) {\012    m_remaining_period--;\012    if (m_remaining_period < m_period_threshold) { \012      return false;\012    } else {\012      return true;\012    }\012  }\012  setStallPeriod();\012  return false;\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012unsigned stream<T,p1,p2,p3,p4,p5>::msws() {\012  static unsigned long long x = 0, w = 0;\012  const unsigned long long s = 0xb5ad4eceda1ce2a9ULL;\012  \012  x *= x; \012  x += (w += s); \012  return (unsigned) (x = (x>>32) | (x<<32));\012}\012\012#endif\012} //namespace internal\012} //namespace ihc\012\012#endif\012\012"}, {"path":"C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/iosfwd", "name":"iosfwd", "has_active_debug_locs":true, "absName":"c:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/iosfwd", "content":"// iosfwd standard header\012#pragma once\012#ifndef _IOSFWD_\012#define _IOSFWD_\012#ifndef RC_INVOKED\012#include <cstdio>\012#include <cstring>\012#include <cwchar>\012#include <xstddef>\012\012#include <crtdbg.h>\012\012 #pragma pack(push,_CRT_PACKING)\012 #pragma warning(push,3)\012\012_STD_BEGIN\012		// STREAM POSITIONING TYPES (from <streambuf>)\012\012typedef _Longlong streamoff;\012typedef _Longlong streamsize;\012\012  #define _FSEEK_OFF(str, off, way)	_fseeki64(str, off, way)\012  #define _Fpz	0	/* initializer for zero fpos_t */\012\012  #ifdef _M_CEE_PURE\012extern const streamoff _BADOFF;\012  #else /* _M_CEE_PURE */\012extern _CRTDATA2 _PGLOBAL const streamoff _BADOFF;\012  #endif /* _M_CEE_PURE */\012\012		// TEMPLATE CLASS fpos (from <streambuf>)\012template<class _Statetype>\012	class fpos\012	{	// store arbitrary file position\012	typedef fpos<_Statetype> _Myt;\012\012public:\012	__CLR_OR_THIS_CALL fpos(streamoff _Off = 0)\012		: _Myoff(_Off), _Fpos(_Fpz), _Mystate(_Stz)\012		{	// construct with stream offset\012		}\012\012	__CLR_OR_THIS_CALL fpos(_Statetype _State, fpos_t _Fileposition)\012		: _Myoff(0), _Fpos(_Fileposition), _Mystate(_State)\012		{	// construct with conversion state and C file position\012		}\012\012	_Statetype __CLR_OR_THIS_CALL state() const\012		{	// return conversion state\012		return (_Mystate);\012		}\012\012	void __CLR_OR_THIS_CALL state(_Statetype _State)\012		{	// set conversion state\012		_Mystate = _State;\012		}\012\012	fpos_t __CLR_OR_THIS_CALL seekpos() const\012		{	// return C file position\012		return (_Fpos);\012		}\012\012	__CLR_OR_THIS_CALL operator streamoff() const\012		{	// return offset\012		return ((streamoff)(_Myoff + _FPOSOFF(_Fpos)));\012		}\012\012	streamoff __CLR_OR_THIS_CALL operator-(const _Myt& _Right) const\012		{	// return difference of file positions as an offset\012		return ((streamoff)*this - (streamoff)_Right);\012		}\012\012	_Myt& __CLR_OR_THIS_CALL operator+=(streamoff _Off)\012		{	// add offset\012		_Myoff += _Off;\012		return (*this);\012		}\012\012	_Myt& __CLR_OR_THIS_CALL operator-=(streamoff _Off)\012		{	// subtract offset\012		_Myoff -= _Off;\012		return (*this);\012		}\012\012	_Myt __CLR_OR_THIS_CALL operator+(streamoff _Off) const\012		{	// return this + offset\012		_Myt _Tmp = *this;\012		return (_Tmp += _Off);\012		}\012\012	_Myt __CLR_OR_THIS_CALL operator-(streamoff _Off) const\012		{	// return this - offset\012		_Myt _Tmp = *this;\012		return (_Tmp -= _Off);\012		}\012\012	bool __CLR_OR_THIS_CALL operator==(const _Myt& _Right) const\012		{	// test for file position equality\012		return ((streamoff)*this == (streamoff)_Right);\012		}\012\012	bool __CLR_OR_THIS_CALL operator==(streamoff _Right) const\012		{	// test for file position equality with streamoff\012		return ((streamoff)*this == _Right);\012		}\012\012	bool __CLR_OR_THIS_CALL operator!=(const _Myt& _Right) const\012		{	// test for file position inequality\012		return (!(*this == _Right));\012		}\012\012private:\012	_PGLOBAL static const _Statetype _Stz;	// initial conversion state\012	streamoff _Myoff;	// stream offset\012	fpos_t _Fpos;	// C file position\012	_Statetype _Mystate;	// current conversion state\012	};\012\012	// STATIC fpos::_Stz OBJECT\012template<class _Statetype>\012	_PGLOBAL const _Statetype fpos<_Statetype>::_Stz = _Statetype();\012\012 #define _POS_TYPE_FROM_STATE(postype, state, position)	\\\012	postype(state, position)\012 #define _POS_TYPE_TO_FPOS_T(pos)	pos.seekpos()\012 #define _POS_TYPE_TO_STATE(pos)	pos.state()\012\012typedef fpos<_Mbstatet> streampos;\012\012typedef streampos wstreampos;\012\012		// TEMPLATE STRUCT _Char_traits (FROM <string>)\012template<class _Elem,\012	class _Int_type>\012	struct _Char_traits\012	{	// properties of a string or stream element\012	typedef _Elem char_type;\012	typedef _Int_type int_type;\012	typedef streampos pos_type;\012	typedef streamoff off_type;\012	typedef _Mbstatet state_type;\012\012	static int __CLRCALL_OR_CDECL compare(\012		_In_count_(_Count) const _Elem *_First1,\012		_In_count_(_Count) const _Elem *_First2, size_t _Count)\012		{	// compare [_First1, _First1 + _Count) with [_First2, ...)\012		for (; 0 < _Count; --_Count, ++_First1, ++_First2)\012			if (!eq(*_First1, *_First2))\012				return (lt(*_First1, *_First2) ? -1 : +1);\012		return (0);\012		}\012\012	static size_t __CLRCALL_OR_CDECL length(_In_z_ const _Elem *_First)\012		{	// find length of null-terminated sequence\012		size_t _Count;\012		for (_Count = 0; !eq(*_First, _Elem()); ++_First)\012			++_Count;\012		return (_Count);\012		}\012\012	static _Elem *__CLRCALL_OR_CDECL copy(\012		_Out_cap_(_Count) _Elem *_First1,\012		_In_count_(_Count) const _Elem *_First2, size_t _Count)\012		{	// copy [_First1, _First1 + _Count) to [_First2, ...)\012		_Elem *_Next = _First1;\012		for (; 0 < _Count; --_Count, ++_Next, ++_First2)\012			assign(*_Next, *_First2);\012		return (_First1);\012		}\012\012	static _Elem *__CLRCALL_OR_CDECL _Copy_s(\012		_Out_cap_(_Dest_size) _Elem *_First1, size_t _Dest_size,\012		_In_count_(_Count) const _Elem *_First2, size_t _Count)\012		{	// copy [_First1, _First1 + _Count) to [_First2, ...)\012		_SCL_SECURE_CRT_VALIDATE(_Dest_size >= _Count, NULL);\012		return (copy(_First1, _First2, _Count));\012		}\012\012	static const _Elem *__CLRCALL_OR_CDECL find(\012		_In_count_(_Count) const _Elem *_First,\012		size_t _Count, const _Elem& _Ch)\012		{	// look for _Ch in [_First, _First + _Count)\012		for (; 0 < _Count; --_Count, ++_First)\012			if (eq(*_First, _Ch))\012				return (_First);\012		return (0);\012		}\012\012	static _Elem *__CLRCALL_OR_CDECL move(\012		_Out_cap_(_Count) _Elem *_First1,\012		_In_count_(_Count) const _Elem *_First2, size_t _Count)\012		{	// copy [_First1, _First1 + _Count) to [_First2, ...)\012		_Elem *_Next = _First1;\012		if (_First2 < _Next && _Next < _First2 + _Count)\012			for (_Next += _Count, _First2 += _Count; 0 < _Count; --_Count)\012				assign(*--_Next, *--_First2);\012		else\012			for (; 0 < _Count; --_Count, ++_Next, ++_First2)\012				assign(*_Next, *_First2);\012		return (_First1);\012		}\012\012	static _Elem *__CLRCALL_OR_CDECL assign(\012		_Out_cap_(_Count) _Elem *_First,\012		size_t _Count, _Elem _Ch)\012		{	// assign _Count * _Ch to [_First, ...)\012		_Elem *_Next = _First;\012		for (; 0 < _Count; --_Count, ++_Next)\012			assign(*_Next, _Ch);\012		return (_First);\012		}\012\012	static void __CLRCALL_OR_CDECL assign(_Elem& _Left, const _Elem& _Right)\012		{	// assign an element\012		_Left = _Right;\012		}\012\012	static bool __CLRCALL_OR_CDECL eq(const _Elem& _Left, const _Elem& _Right)\012		{	// test for element equality\012		return (_Left == _Right);\012		}\012\012	static bool __CLRCALL_OR_CDECL lt(const _Elem& _Left, const _Elem& _Right)\012		{	// test if _Left precedes _Right\012		return (_Left < _Right);\012		}\012\012	static _Elem __CLRCALL_OR_CDECL to_char_type(const int_type& _Meta)\012		{	// convert metacharacter to character\012		return ((_Elem)_Meta);\012		}\012\012	static int_type __CLRCALL_OR_CDECL to_int_type(const _Elem& _Ch)\012		{	// convert character to metacharacter\012		return ((int_type)_Ch);\012		}\012\012	static bool __CLRCALL_OR_CDECL eq_int_type(const int_type& _Left,\012		const int_type& _Right)\012		{	// test for metacharacter equality\012		return (_Left == _Right);\012		}\012\012	static int_type __CLRCALL_OR_CDECL not_eof(const int_type& _Meta)\012		{	// return anything but EOF\012		return (_Meta != eof() ? (int_type)_Meta : (int_type)!eof());\012		}\012\012	static int_type __CLRCALL_OR_CDECL eof()\012		{	// return end-of-file metacharacter\012		return ((int_type)EOF);\012		}\012	};\012\012		// TEMPLATE STRUCT char_traits\012template<class _Elem>\012	struct char_traits\012		: public _Char_traits<_Elem, long>\012	{	// properties of a string or stream unknown element\012	};\012\012 #if _HAS_CHAR16_T_LANGUAGE_SUPPORT\012		// STRUCT char_traits<char16_t>\012template<>\012	struct char_traits<char16_t>\012	: public _Char_traits<char16_t, unsigned short>\012	{	// properties of a string or stream char16_t element\012	};\012\012		// STRUCT char_traits<char32_t>\012template<>\012	struct char_traits<char32_t>\012	: public _Char_traits<char32_t, unsigned long>\012	{	// properties of a string or stream char32_t element\012	};\012 #endif /* _HAS_CHAR16_T_LANGUAGE_SUPPORT */\012\012		// STRUCT char_traits<wchar_t>\012template<>\012	struct char_traits<wchar_t>\012	{	// properties of a string or stream wchar_t element\012	typedef wchar_t _Elem;\012	typedef _Elem char_type;	// for overloads\012	typedef wint_t int_type;\012	typedef streampos pos_type;\012	typedef streamoff off_type;\012	typedef _Mbstatet state_type;\012\012	static int __CLRCALL_OR_CDECL compare(const _Elem *_First1, const _Elem *_First2,\012		size_t _Count)\012		{	// compare [_First1, _First1 + _Count) with [_First2, ...)\012		return (_CSTD wmemcmp(_First1, _First2, _Count));\012		}\012\012	static size_t __CLRCALL_OR_CDECL length(const _Elem *_First)\012		{	// find length of null-terminated sequence\012		return (_CSTD wcslen(_First));\012		}\012\012	static _Elem *__CLRCALL_OR_CDECL copy(_Elem *_First1, const _Elem *_First2,\012		size_t _Count)\012		{	// copy [_First1, _First1 + _Count) to [_First2, ...)\012		return ((_Elem *)_CSTD wmemcpy(_First1, _First2, _Count));\012		}\012\012	static _Elem *__CLRCALL_OR_CDECL _Copy_s(\012		_Out_cap_(_Size_in_words) _Elem *_First1, size_t _Size_in_words,\012		_In_count_(_Count) const _Elem *_First2, size_t _Count)\012		{	// copy [_First1, _First1 + _Count) to [_First2, ...)\012		_CRT_SECURE_WMEMCPY(_First1, _Size_in_words, _First2, _Count);\012		return _First1;\012		}\012\012	static const _Elem *__CLRCALL_OR_CDECL find(const _Elem *_First, size_t _Count,\012		const _Elem& _Ch)\012		{	// look for _Ch in [_First, _First + _Count)\012		return ((const _Elem *)_CSTD wmemchr(_First, _Ch, _Count));\012		}\012\012	static _Elem *__CLRCALL_OR_CDECL move(_Elem *_First1, const _Elem *_First2,\012		size_t _Count)\012		{	// copy [_First1, _First1 + _Count) to [_First2, ...)\012		return ((_Elem *)_CSTD wmemmove(_First1, _First2, _Count));\012		}\012\012	static _Elem *__CLRCALL_OR_CDECL assign(_Elem *_First, size_t _Count, _Elem _Ch)\012		{	// assign _Count * _Ch to [_First, ...)\012		return ((_Elem *)_CSTD wmemset(_First, _Ch, _Count));\012		}\012\012	static void __CLRCALL_OR_CDECL assign(_Elem& _Left, const _Elem& _Right)\012		{	// assign an element\012		_Left = _Right;\012		}\012\012	static bool __CLRCALL_OR_CDECL eq(const _Elem& _Left, const _Elem& _Right)\012		{	// test for element equality\012		return (_Left == _Right);\012		}\012\012	static bool __CLRCALL_OR_CDECL lt(const _Elem& _Left, const _Elem& _Right)\012		{	// test if _Left precedes _Right\012		return (_Left < _Right);\012		}\012\012	static _Elem __CLRCALL_OR_CDECL to_char_type(const int_type& _Meta)\012		{	// convert metacharacter to character\012		return (_Meta);\012		}\012\012	static int_type __CLRCALL_OR_CDECL to_int_type(const _Elem& _Ch)\012		{	// convert character to metacharacter\012		return (_Ch);\012		}\012\012	static bool __CLRCALL_OR_CDECL eq_int_type(const int_type& _Left,\012		const int_type& _Right)\012		{	// test for metacharacter equality\012		return (_Left == _Right);\012		}\012\012	static int_type __CLRCALL_OR_CDECL not_eof(const int_type& _Meta)\012		{	// return anything but EOF\012		return (_Meta != eof() ? _Meta : !eof());\012		}\012\012	static int_type __CLRCALL_OR_CDECL eof()\012		{	// return end-of-file metacharacter\012		return (WEOF);\012		}\012	};\012\012 #ifdef _NATIVE_WCHAR_T_DEFINED\012		// STRUCT char_traits<unsigned short>\012template<> struct char_traits<unsigned short>\012	{	// properties of a string or stream unsigned short element\012	typedef unsigned short _Elem;\012	typedef _Elem char_type;	// for overloads\012	typedef wint_t int_type;\012	typedef streampos pos_type;\012	typedef streamoff off_type;\012	typedef _Mbstatet state_type;\012\012	static int __CLRCALL_OR_CDECL compare(const _Elem *_First1, const _Elem *_First2,\012		size_t _Count)\012		{	// compare [_First1, _First1 + _Count) with [_First2, ...)\012		return (_CSTD wmemcmp((const wchar_t *)_First1,\012			(const wchar_t *)_First2, _Count));\012		}\012\012	static size_t __CLRCALL_OR_CDECL length(const _Elem *_First)\012		{	// find length of null-terminated sequence\012		return (_CSTD wcslen((const wchar_t *)_First));\012		}\012\012	static _Elem *__CLRCALL_OR_CDECL copy(_Elem *_First1, const _Elem *_First2,\012		size_t _Count)\012		{	// copy [_First1, _First1 + _Count) to [_First2, ...)\012		return ((_Elem *)_CSTD wmemcpy((wchar_t *)_First1,\012			(const wchar_t *)_First2, _Count));\012		}\012\012	static _Elem *__CLRCALL_OR_CDECL _Copy_s(\012		_Out_cap_(_Size_in_words) _Elem *_First1, size_t _Size_in_words,\012		_In_count_(_Count) const _Elem *_First2, size_t _Count)\012		{	// copy [_First1, _First1 + _Count) to [_First2, ...)\012		_CRT_SECURE_WMEMCPY((wchar_t *)_First1, _Size_in_words, (const wchar_t *)_First2, _Count);\012		return _First1;\012		}\012\012	static const _Elem *__CLRCALL_OR_CDECL find(const _Elem *_First, size_t _Count,\012		const _Elem& _Ch)\012		{	// look for _Ch in [_First, _First + _Count)\012		return ((const _Elem *)_CSTD wmemchr((const wchar_t *)_First,\012			_Ch, _Count));\012		}\012\012	static _Elem *__CLRCALL_OR_CDECL move(_Elem *_First1, const _Elem *_First2,\012		size_t _Count)\012		{	// copy [_First1, _First1 + _Count) to [_First2, ...)\012		return ((_Elem *)_CSTD wmemmove((wchar_t *)_First1,\012			(const wchar_t *)_First2, _Count));\012		}\012\012	static _Elem *__CLRCALL_OR_CDECL assign(_Elem *_First, size_t _Count, _Elem _Ch)\012		{	// assign _Count * _Ch to [_First, ...)\012		return ((_Elem *)_CSTD wmemset((wchar_t *)_First, _Ch, _Count));\012		}\012\012	static void __CLRCALL_OR_CDECL assign(_Elem& _Left, const _Elem& _Right)\012		{	// assign an element\012		_Left = _Right;\012		}\012\012	static bool __CLRCALL_OR_CDECL eq(const _Elem& _Left, const _Elem& _Right)\012		{	// test for element equality\012		return (_Left == _Right);\012		}\012\012	static bool __CLRCALL_OR_CDECL lt(const _Elem& _Left, const _Elem& _Right)\012		{	// test if _Left precedes _Right\012		return (_Left < _Right);\012		}\012\012	static _Elem __CLRCALL_OR_CDECL to_char_type(const int_type& _Meta)\012		{	// convert metacharacter to character\012		return (_Meta);\012		}\012\012	static int_type __CLRCALL_OR_CDECL to_int_type(const _Elem& _Ch)\012		{	// convert character to metacharacter\012		return (_Ch);\012		}\012\012	static bool __CLRCALL_OR_CDECL eq_int_type(const int_type& _Left,\012		const int_type& _Right)\012		{	// test for metacharacter equality\012		return (_Left == _Right);\012		}\012\012	static int_type __CLRCALL_OR_CDECL not_eof(const int_type& _Meta)\012		{	// return anything but EOF\012		return (_Meta != eof() ? _Meta : !eof());\012		}\012\012	static int_type __CLRCALL_OR_CDECL eof()\012		{	// return end-of-file metacharacter\012		return (WEOF);\012		}\012	};\012 #endif /* _NATIVE_WCHAR_T_DEFINED */\012\012		// STRUCT char_traits<char> (FROM <string>)\012template<> struct char_traits<char>\012	{	// properties of a string or stream char element\012	typedef char _Elem;\012	typedef _Elem char_type;\012	typedef int int_type;\012	typedef streampos pos_type;\012	typedef streamoff off_type;\012	typedef _Mbstatet state_type;\012\012	static int __CLRCALL_OR_CDECL compare(const _Elem *_First1, const _Elem *_First2,\012		size_t _Count)\012		{	// compare [_First1, _First1 + _Count) with [_First2, ...)\012		return (_CSTD memcmp(_First1, _First2, _Count));\012		}\012\012	static size_t __CLRCALL_OR_CDECL length(const _Elem *_First)\012		{	// find length of null-terminated string\012		return (_CSTD strlen(_First));\012		}\012\012	static _Elem *__CLRCALL_OR_CDECL copy(_Elem *_First1, const _Elem *_First2,\012		size_t _Count)\012		{	// copy [_First1, _First1 + _Count) to [_First2, ...)\012		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));\012		}\012\012	static _Elem *__CLRCALL_OR_CDECL _Copy_s(\012		_Out_cap_(_Size_in_bytes) _Elem *_First1, size_t _Size_in_bytes,\012		_In_count_(_Count) const _Elem *_First2, size_t _Count)\012		{	// copy [_First1, _First1 + _Count) to [_First2, ...)\012		_CRT_SECURE_MEMCPY(_First1, _Size_in_bytes, _First2, _Count);\012		return _First1;\012		}\012\012	static const _Elem *__CLRCALL_OR_CDECL find(const _Elem *_First, size_t _Count,\012		const _Elem& _Ch)\012		{	// look for _Ch in [_First, _First + _Count)\012		return ((const _Elem *)_CSTD memchr(_First, _Ch, _Count));\012		}\012\012	static _Elem *__CLRCALL_OR_CDECL move(_Elem *_First1, const _Elem *_First2,\012		size_t _Count)\012		{	// copy [_First1, _First1 + _Count) to [_First2, ...)\012		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));\012		}\012\012	static _Elem *__CLRCALL_OR_CDECL assign(_Elem *_First, size_t _Count, _Elem _Ch)\012		{	// assign _Count * _Ch to [_First, ...)\012		return ((_Elem *)_CSTD memset(_First, _Ch, _Count));\012		}\012\012	static void __CLRCALL_OR_CDECL assign(_Elem& _Left, const _Elem& _Right)\012		{	// assign an element\012		_Left = _Right;\012		}\012\012	static bool __CLRCALL_OR_CDECL eq(const _Elem& _Left, const _Elem& _Right)\012		{	// test for element equality\012		return (_Left == _Right);\012		}\012\012	static bool __CLRCALL_OR_CDECL lt(const _Elem& _Left, const _Elem& _Right)\012		{	// test if _Left precedes _Right\012		return ((unsigned char)_Left < (unsigned char)_Right);\012		}\012\012	static _Elem __CLRCALL_OR_CDECL to_char_type(const int_type& _Meta)\012		{	// convert metacharacter to character\012		return ((_Elem)_Meta);\012		}\012\012	static int_type __CLRCALL_OR_CDECL to_int_type(const _Elem& _Ch)\012		{	// convert character to metacharacter\012		return ((unsigned char)_Ch);\012		}\012\012	static bool __CLRCALL_OR_CDECL eq_int_type(const int_type& _Left,\012		const int_type& _Right)\012		{	// test for metacharacter equality\012		return (_Left == _Right);\012		}\012\012	static int_type __CLRCALL_OR_CDECL not_eof(const int_type& _Meta)\012		{	// return anything but EOF\012		return (_Meta != eof() ? _Meta : !eof());\012		}\012\012	static int_type __CLRCALL_OR_CDECL eof()\012		{	// return end-of-file metacharacter\012		return (EOF);\012		}\012	};\012\012		// FORWARD REFERENCES\012template<class _Ty>\012	class allocator;\012class ios_base;\012template<class _Elem,\012	class _Traits = char_traits<_Elem> >\012	class basic_ios;\012template<class _Elem,\012	class _Traits = char_traits<_Elem> >\012	class istreambuf_iterator;\012template<class _Elem,\012	class _Traits = char_traits<_Elem> >\012	class ostreambuf_iterator;\012template<class _Elem,\012	class _Traits = char_traits<_Elem> >\012	class basic_streambuf;\012template<class _Elem,\012	class _Traits = char_traits<_Elem> >\012	class basic_istream;\012template<class _Elem,\012	class _Traits = char_traits<_Elem> >\012	class basic_ostream;\012template<class _Elem,\012	class _Traits = char_traits<_Elem> >\012	class basic_iostream;\012template<class _Elem,\012	class _Traits = char_traits<_Elem>,\012	class _Alloc = allocator<_Elem> >\012	class basic_stringbuf;\012template<class _Elem,\012	class _Traits = char_traits<_Elem>,\012	class _Alloc = allocator<_Elem> >\012	class basic_istringstream;\012template<class _Elem,\012	class _Traits = char_traits<_Elem>,\012	class _Alloc = allocator<_Elem> >\012	class basic_ostringstream;\012template<class _Elem,\012	class _Traits = char_traits<_Elem>,\012	class _Alloc = allocator<_Elem> >\012	class basic_stringstream;\012template<class _Elem,\012	class _Traits = char_traits<_Elem> >\012	class basic_filebuf;\012template<class _Elem,\012	class _Traits = char_traits<_Elem> >\012	class basic_ifstream;\012template<class _Elem,\012	class _Traits = char_traits<_Elem> >\012	class basic_ofstream;\012template<class _Elem,\012	class _Traits = char_traits<_Elem> >\012	class basic_fstream;\012\012 #if defined(_DLL_CPPLIB) && !defined(_M_CEE_PURE)\012template<class _Elem,\012	class _InIt >\012	class num_get;\012template<class _Elem,\012	class _OutIt >\012	class num_put;\012template<class _Elem>\012	class collate;\012 #endif /* defined(_DLL_CPPLIB) etc. */\012\012		// char TYPEDEFS\012typedef basic_ios<char, char_traits<char> > ios;\012typedef basic_streambuf<char, char_traits<char> > streambuf;\012typedef basic_istream<char, char_traits<char> > istream;\012typedef basic_ostream<char, char_traits<char> > ostream;\012typedef basic_iostream<char, char_traits<char> > iostream;\012typedef basic_stringbuf<char, char_traits<char>,\012	allocator<char> > stringbuf;\012typedef basic_istringstream<char, char_traits<char>,\012	allocator<char> > istringstream;\012typedef basic_ostringstream<char, char_traits<char>,\012	allocator<char> > ostringstream;\012typedef basic_stringstream<char, char_traits<char>,\012	allocator<char> > stringstream;\012typedef basic_filebuf<char, char_traits<char> > filebuf;\012typedef basic_ifstream<char, char_traits<char> > ifstream;\012typedef basic_ofstream<char, char_traits<char> > ofstream;\012typedef basic_fstream<char, char_traits<char> > fstream;\012\012		// wchat_t TYPEDEFS\012typedef basic_ios<wchar_t, char_traits<wchar_t> > wios;\012typedef basic_streambuf<wchar_t, char_traits<wchar_t> >\012	wstreambuf;\012typedef basic_istream<wchar_t, char_traits<wchar_t> > wistream;\012typedef basic_ostream<wchar_t, char_traits<wchar_t> > wostream;\012typedef basic_iostream<wchar_t, char_traits<wchar_t> > wiostream;\012typedef basic_stringbuf<wchar_t, char_traits<wchar_t>,\012	allocator<wchar_t> > wstringbuf;\012typedef basic_istringstream<wchar_t, char_traits<wchar_t>,\012	allocator<wchar_t> > wistringstream;\012typedef basic_ostringstream<wchar_t, char_traits<wchar_t>,\012	allocator<wchar_t> > wostringstream;\012typedef basic_stringstream<wchar_t, char_traits<wchar_t>,\012	allocator<wchar_t> > wstringstream;\012typedef basic_filebuf<wchar_t, char_traits<wchar_t> > wfilebuf;\012typedef basic_ifstream<wchar_t, char_traits<wchar_t> > wifstream;\012typedef basic_ofstream<wchar_t, char_traits<wchar_t> > wofstream;\012typedef basic_fstream<wchar_t, char_traits<wchar_t> > wfstream;\012\012\012 #if defined(_DLL_CPPLIB) && !defined(_M_CEE_PURE)\012typedef num_get<char, istreambuf_iterator<char, char_traits<char> > >\012	numget;\012typedef num_get<wchar_t, istreambuf_iterator<wchar_t, char_traits<wchar_t> > >\012	wnumget;\012typedef num_put<char, ostreambuf_iterator<char, char_traits<char> > >\012	numput;\012typedef num_put<wchar_t, ostreambuf_iterator<wchar_t, char_traits<wchar_t> > >\012	wnumput;\012typedef collate<char> ncollate;\012typedef collate<wchar_t> wcollate;\012 #endif /* defined(_DLL_CPPLIB) etc. */\012_STD_END\012\012 #pragma warning(pop)\012 #pragma pack(pop)\012\012#endif /* RC_INVOKED */\012#endif /* _IOSFWD_ */\012\012/*\012 * Copyright (c) 1992-2009 by P.J. Plauger.  ALL RIGHTS RESERVED.\012 * Consult your license regarding permissions and restrictions.\012V5.20:0009 */\012"}, {"path":"C:/intelFPGA_lite/18.1/hls/include/HLS/math.h", "name":"math.h", "has_active_debug_locs":false, "absName":"c:/intelFPGA_lite/18.1/hls/include/HLS/math.h", "content":"#ifndef __HLS_MATH_H__\012#define __HLS_MATH_H__\012\012/* This file is used to overlay math.h on linux and windows.\012The table below describes what is currently available on each platform\012We are currently supporting gcc 4.4.7 and MSVC 10 respectively, so that \012is the versions we are currenlty trying to mimic.\012All floating point functions that are available, has an f at the end for \012single precison floating point, so sin(double), but sinf(float)\012Y = Supported\012N = Not supported yet\012- = Not available on that platform with the supported underlying compiler, \012 ****************************************************************\012 * Function Name            Linux    Windows  Notes        *\012 * abs                          -    N        Integer math *\012 * labs                         -    N        Integer math *\012 * atof                         -    N                     *\012 * cos(float/double)            Y    Y                     *\012 * sin(float/double)            Y    Y                     *\012 * tan(float/double)            Y    Y                     *\012 * acos(float/double)           Y    Y                     *\012 * asin(float/double)           Y    Y                     *\012 * atan(float/double)           Y    Y                     *\012 * atan2(float/double)          Y    Y                     *\012 * cosh(float/double)           Y    Y                     *\012 * sinh(float/double)           Y    Y                     *\012 * tanh(float/double)           Y    Y                     *\012 * acosh(float/double)          N    -        C99/C++11    *\012 * asinh(float/double)          N    -        C99/C++11    *\012 * atanh(float/double)          N    -        C99/C++11    *\012 * exp(float/double)            Y    Y                     *\012 * frexp(float/double)          Y    Y                     *\012 * ldexp(float/double)          Y    Y                     *\012 * log(float/double)            Y    Y                     *\012 * log10(float/double)          Y    Y                     *\012 * modf(float/double)           Y    Y                     *\012 * exp2(float/double)           Y    -        C99/C++11    *\012 * exp10(float/double)          Y    -                     *\012 * expm1(float/double)          Y    -        C99/C++11    *\012 * ilogb(float/double)          Y    -        C++11        *\012 * log1p(float/double)          N    -        C99/C++11    *\012 * log2(float/double)           Y    -        C99/C++11    *\012 * logb(float/double)           N    -        C++11        *\012 * scalbn(float/double)         N    -        C99/C++11    *\012 * scalbln(float/double)        N    -        C99/C++11    *\012 * pow(float/double)            Y    Y                     *\012 * sqrt(float/double)           Y    Y                     *\012 * cbrt(float/double)           Y    -        C99/C++11    *\012 * hypot(float/double)          Y    Y        C99/C++11    *\012 * erf(float/double)            N    -        C99/C++11    *\012 * erfc(float/double)           N    -        C99/C++11    *\012 * tgamma(float/double)         N    -        C99/C++11    *\012 * lgamma(float/double)         N    -        C99/C++11    *\012 * ceil(float/double)           Y    Y                     *\012 * floor(float/double)          Y    Y                     *\012 * fmod(float/double)           Y    Y                     *\012 * trunc(float/double)          Y    -        C++11        *\012 * round(float/double)          Y    -        C++11        *\012 * lround(float/double)         N    -        C++11        *\012 * llround(float/double)        N    -        C++11        *\012 * rint(float/double)           Y    -        C99/C++11    *\012 * lrint(float/double)          N    -        C++11        *\012 * llrint(float/double)         N    -        C++11        *\012 * nearbyint(float/double)      N    -        C++11        *\012 * remainder(float/double)      N    -        C++11        *\012 * drem                         N    -        obsolete name for remanider *\012 * remquo(float/double)         N    -        C++11        *\012 * significand                  N    -        non standard *\012 * copysign(float/double)       N    -        C99/C++11    *\012 * nan(float/double)            N    -        C99/C++11    *\012 * nextafter(float/double)      N    -        C99/C++11    *\012 * nexttoward(float/double)     N    -        C99/C++11    *\012 * fdim(float/double)           Y    -        C++11        *\012 * fmin(float/double)           Y    -        C++11        *\012 * fmax(float/double)           Y    -        C++11        *\012 * fabs(float/double)           Y    Y                     *\012 * fma(float/double)            N    -        C++11        *\012 * fpclassify(float/double)     N    -        C++11        *\012 * isfinite(float/double)       Y    -        C++11        *\012 * finite                       Y    -        BSD name for isfinite    *\012 * isinf(float/double)          Y    -        C++11        *\012 * isnan(float/double)          Y    -        C++11        *\012 * isnormal(float/double)       N    -        C++11        *\012 * signbit(float/double)        N    -        C++11        *\012 * isgreater(float/double)      N    -        C++11        *\012 * isgreaterequal(float/double) N    -        C++11        *\012 * isless(float/double)         N    -        C++11        *\012 * islessequal(float/double)    N    -        C++11        *\012 * islessgreater(float/double)  N    -        C++11        *\012 * isunordered(float/double)    N    -        C++11        *\012 ****************************************************************/\012\012#include <math.h>\012\012#if defined(INTELFPGA_CL)\012#ifdef HLS_SYNTHESIS\012#define __PUREF __attribute__((const))\012\012// FPGA, remap to current internal OpenCL names\012extern \"C\" {\012\012/********** Supported trig builtins **********/\012double __PUREF __acl__cosfd(double __x);\012#define cos(__x) __acl__cosfd(__x)\012\012float __PUREF _Z8__tg_cosf(float __x);\012#define cosf(__x) _Z8__tg_cosf(__x)\012\012double __PUREF __acl__sinfd(double __x);\012#define sin(__x) __acl__sinfd(__x)\012\012float __PUREF _Z8__tg_sinf(float __x);\012#define sinf(__x) _Z8__tg_sinf(__x)\012\012double __PUREF _Z8__tg_tand(double __x);\012#define tan(__x) _Z8__tg_tand(__x)\012\012float __PUREF _Z8__tg_tanf(float __x);\012#define tanf(__x) _Z8__tg_tanf(__x)\012\012double __PUREF __acl__acosfd(double __x);\012#define acos(__x) __acl__acosfd(__x)\012\012float __PUREF _Z9__tg_acosf(float __x);\012#define acosf(__x) _Z9__tg_acosf(__x)\012\012double __PUREF __acl__asinfd(double __x);\012#define asin(__x) __acl__asinfd(__x)\012\012float __PUREF _Z9__tg_asinf(float __x);\012#define asinf(__x) _Z9__tg_asinf(__x)\012\012double __PUREF __acl__atanfd(double __x);\012#define atan(__x) __acl__atanfd(__x)\012\012float __PUREF _Z9__tg_atanf(float __x);\012#define atanf(__x) _Z9__tg_atanf(__x)\012\012double __PUREF __acl__atan2fd(double __x, double __y);\012#define atan2(__x, __y) __acl__atan2fd(__x, __y)\012\012float __PUREF __acl__atan2f(float __x, float __y);\012#define atan2f(__x, __y) __acl__atan2f(__x, __y)\012\012double __PUREF _Z9__tg_coshd(double __x);\012#define cosh(__x) _Z9__tg_coshd(__x)\012\012float __PUREF _Z10__tg_coshff(float __x);\012#define coshf(__x) _Z10__tg_coshff(__x)\012\012double __PUREF _Z9__tg_sinhd(double __x);\012#define sinh(__x) _Z9__tg_sinhd(__x)\012\012float __PUREF _Z10__tg_sinhff(float __x);\012#define sinhf(__x) _Z10__tg_sinhff(__x)\012\012double __PUREF _Z9__tg_tanhd(double __x);\012#define tanh(__x) _Z9__tg_tanhd(__x)\012\012float __PUREF _Z10__tg_tanhff(float __x);\012#define tanhf(__x) _Z10__tg_tanhff(__x)\012\012double __PUREF __acl__expfd(double __x);\012#define exp(__x) __acl__expfd(__x)\012\012float __PUREF _Z8__tg_expf(float __x);\012#define expf(__x) _Z8__tg_expf(__x)\012\012double __PUREF _Z5frexpdPi(double __x, int* __y);\012#define frexp(__x, __y)  _Z5frexpdPi(__x, __y)\012\012float __PUREF _Z5frexpfPi(float __x, int* __y);\012#define frexpf(__x, __y)  _Z5frexpfPi(__x, __y)\012\012double __PUREF __acl__ldexpfd(double __x, int __y);\012#define ldexp(__x, __y) __acl__ldexpfd(__x, __y)\012\012float __PUREF __acl__ldexpf(float __x, int __y);\012#define ldexpf(__x, __y) __acl__ldexpf(__x, __y)\012 \012double __PUREF __acl__logfd(double __x);\012#define log(__x) __acl__logfd(__x)\012\012float __PUREF _Z8__tg_logf(float __x);\012#define logf(__x) _Z8__tg_logf(__x)\012\012double __PUREF _Z10__tg_log10d(double __x);\012#define log10(__x) _Z10__tg_log10d(__x)\012\012float __PUREF _Z10__tg_log10f(float __x);\012#define log10f(__x) _Z10__tg_log10f(__x)\012\012double __PUREF _Z4modfdPd(double __x, double * __y);\012#define modf(__x, __y) _Z4modfdPd(__x, __y)\012\012float __PUREF _Z4modffPf(float __x, float* __y);\012#define modff(__x, __y)   _Z4modffPf(__x, __y)\012\012#if defined (__linux__)\012double __PUREF _Z9__tg_exp2d(double __x);\012#define exp2(__x) _Z9__tg_exp2d(__x)\012\012float __PUREF _Z10__tg_exp2ff(float __x);\012#define exp2f(__x) _Z10__tg_exp2ff(__x)\012\012double __PUREF __acl__exp10fd(double __x);\012#define exp10(__x) __acl__exp10fd(__x)\012\012float __PUREF __acl__exp10f(float __x);\012#define exp10f(__x) __acl__exp10f(__x)\012\012inline double __x_expm1 (double __x) {\012  return __acl__expfd(__x) - 1.0;\012}\012#define expm1(__x) __x_expm1(__x)\012\012float __PUREF __acl__expm1f(float);      \012#define expm1f(__x) __acl__expm1f(__x)\012\012int __PUREF _Z5ilogbd(double __x);\012#define ilogb(__x) _Z5ilogbd(__x)\012\012int __PUREF _Z5ilogbf(float __x);\012#define ilogbf(__x) _Z5ilogbf(__x)\012\012double __PUREF _ZL10__tg_log1pd(double __x);\012#define log1p(__x) _ZL10__tg_log1pd(__x)\012\012double __PUREF _Z9__tg_log2d(double __x);\012#define log2(__x) _Z9__tg_log2d(__x)\012\012float __PUREF _Z10__tg_log2ff(float __x);\012#define log2f(__x) _Z10__tg_log2ff(__x)\012\012#endif //linux\012\012double __PUREF __acl__powfd(double __x, double __y);\012#define pow(__x,__y) __acl__powfd(__x, __y)\012\012float __PUREF __acl__powf(float __x, float __y);\012#define powf(__x,__y) __acl__powf(__x, __y)\012\012double __PUREF __acl__sqrtfd(double  __x);\012#define sqrt(__x) __acl__sqrtfd(__x)\012\012float __PUREF _Z9__tg_sqrtf(float __x);\012#define sqrtf(__x) _Z9__tg_sqrtf(__x)\012\012#if defined (__linux__)\012// Only have the float version built-in.\012inline double __x_cbrt(double __x) {\012  return exp(log(__x) / 3.0);\012}\012#define cbrt(__x) __x_cbrt(__x)\012\012float __PUREF __acl__cbrtf(float);\012#define cbrtf(__x) __acl__cbrtf(__x)\012\012#endif //linux\012\012inline double __x_hypot(double __x, double __y) {\012  return sqrt(__x*__x + __y*__y);\012}\012#define hypot(__x,__y) __x_hypot(__x,__y)\012\012\012float __PUREF __acl__hypotf(float, float);\012#define hypotf(__x,__y) __acl__hypotf(__x,__y)\012\012/************ Error & Gamma Functions *********/\012double __PUREF __acl__ceilfd(double __x);\012#define ceil(__x) __acl__ceilfd(__x)\012\012float __PUREF __acl__ceilf(float __x);\012#define ceilf(__x) __acl__ceilf(__x)\012\012double __PUREF __acl__floorfd(double __x);\012#define floor(__x) __acl__floorfd(__x)\012\012float __PUREF __acl__floorf(float __x);\012#define floorf(__x) __acl__floorf(__x)\012\012double __PUREF _Z9__tg_fmoddd(double __x, double __y);\012#define fmod(__x,__y) _Z9__tg_fmoddd(__x, __y)\012\012float __PUREF _Z9__tg_fmodff(float __x, float __y);\012#define fmodf(__x,__y) _Z9__tg_fmodff(__x, __y)\012\012#if defined (__linux__)\012double __PUREF _Z10__tg_truncd(double __x);\012#define trunc(__x) _Z10__tg_truncd(__x)\012\012float __PUREF _Z10__tg_truncf(float __x);\012#define truncf(__x) _Z10__tg_truncf(__x)\012\012double __PUREF _Z5roundd(double __x);\012#define round(__x) _Z5roundd(__x)\012\012float __PUREF _Z5roundf(float __x);\012#define roundf(__x) _Z5roundf(__x)\012\012double __PUREF _Z4rintd(double __x);\012#define rint(__x) _Z4rintd(__x)\012\012float __PUREF _Z4rintf(float __x);\012#define rintf(__x) _Z4rintf(__x)\012\012double __PUREF _Z9__tg_fdimdd(double __x, double __y);\012#define fdim(__x,__y) _Z9__tg_fdimdd(__x, __y)\012\012float __PUREF _Z9__tg_fdimff(float __x, float __y);\012#define fdimf(__x,__y) _Z9__tg_fdimff(__x, __y)\012\012double __PUREF _Z4fmindd(double __x, double __y);\012#define fmin(__x,__y) _Z4fmindd(__x, __y)\012\012float __PUREF _Z4fminff(float __x, float __y);\012#define fminf(__x,__y) _Z4fminff(__x, __y)\012\012double __PUREF _Z4fmaxdd(double __x, double __y);\012#define fmax(__x,__y) _Z4fmaxdd(__x, __y)\012\012float __PUREF _Z4fmaxff(float __x, float __y);\012#define fmaxf(__x,__y) _Z4fmaxff(__x, __y)\012#endif //linux\012\012double __PUREF __acl__fabsfd(double __x);\012#define fabs(__x) __acl__fabsfd(__x)\012\012float __PUREF __acl__fabsf(float __x);\012#define fabsf(__x) __acl__fabsf(__x)\012\012#if defined (__linux__)\012/********** Classification ******************/\012long __PUREF _Z8isfinited(double __x);\012#define __finite(__x) _Z8isfinited(__x)\012\012int __PUREF _Z8isfinitef(float __x);\012#define __finitef(__x) _Z8isfinitef(__x)\012\012#define finite(__x) _Z8isfinited(__x)\012#define finitef(__x) _Z8isfinitef(__x)\012\012long __PUREF _Z5isinfd(double __x);\012#define __isinf(__x) _Z5isinfd(__x)\012\012int __PUREF _Z5isinff(float __x);\012#define __isinff(__x) _Z5isinff(__x)\012\012long __PUREF _Z5isnand(double __x);\012#define __isnan(__x) _Z5isnand(__x)\012\012int __PUREF _Z5isnanf(float __x);\012#define __isnanf(__x) _Z5isnanf(__x)\012\012#endif //linux\012}\012#endif //#ifdef HLS_SYNTHESIS\012#endif // INTELFPGA_CL\012#endif //__HLS_MATH_H__\012\012"}, {"path":"rgb_to_hsv.c", "name":"rgb_to_hsv.c", "has_active_debug_locs":true, "absName":"c:/intelFPGA_lite/18.1/hls/eebalancebug/rgb_to_hsv.c", "content":"#include <HLS/hls.h>\012#include <HLS/ac_int.h>\012#include <stdio.h>\012#include <stdint.h>\012#include \"rgb_to_hsv.h\"\012\012// 32 bits for H\012// 24 bits of H, 16 bits for S, 8 bits for V\012\012//hls_always_run_component\012component hls_always_run_component ac_int<28, false> rgb_to_hsv(\012    ac_int<8, false> red, ac_int<8, false> green, ac_int<8, false> blue, ac_int<1, false> s\012){\012    \012    // do the conversion\012    uint8_t min, max, mid;\012    \012    if (red > green && red > blue){\012        max = red;\012        if (green > blue){\012            mid = green;\012            min = blue;\012        }\012        else{\012            mid = blue;\012            min = green;\012        }\012    }\012    if (green > red && green > blue){\012        max = green;\012        if (red > blue){\012            mid = red;\012            min = blue;\012        }\012        else{\012            mid = blue;\012            min = red;\012        }\012    }\012    if (blue > red && blue > green){\012        max = blue;\012        if (red > green){\012            mid = red;\012            min = green;\012        }\012        else{\012            mid = green;\012            min = red;\012        }\012    }\012    \012    ac_int<19, false> h = 0;\012    ac_int<8, false> v = 0;\012    v = max;\012\012    if (max-min == 0){\012        h = 0;\012\012        ac_int<28, false> result;\012        result.set_slc(0, v);\012        result.set_slc(8, h);\012        result.set_slc(27, s);\012\012        return result;\012    }\012\012    uint8_t i;\012    if (max == red && min == blue) i = 0;\012    else if (max == green && min == blue) i = 1;\012    else if (max == green && min == red) i = 2;\012    else if (max == blue && min == red) i = 3;\012    else if (max == blue && min == green) i = 4;\012    else if (max == red && min == green) i = 5;\012    \012    \012    uint32_t delta = max-min;\012    //s = ((delta << 16) -1)/max;\012\012    //ac_int<1, false> s = 0;\012    \012    /*\012    uint8_t mod_result = max / 20;\012    if (mod_result == 0) s = (min < 6);\012    else if (mod_result == 1) s = (min < 12);\012    else if (mod_result == 2) s = (min < 18);\012    else if (mod_result == 3) s = (min < 24);\012    else if (mod_result == 4) s = (min < 30);\012    else if (mod_result == 5) s = (min < 36);\012    else if (mod_result == 6) s = (min < 42);\012    else if (mod_result == 7) s = (min < 48);\012    else if (mod_result == 8) s = (min < 64);\012    else if (mod_result == 9) s = (min < 70);\012    else if (mod_result == 10) s = (min < 76);\012    else if (mod_result == 11) s = (min < 82);\012    else if (mod_result == 12) s = (min < 88);\012    */\012    \012\012    uint32_t delta_mid_min = mid-min;\012    \012    ac_int<17, false> f = 0;\012    f = (delta_mid_min << 16)/delta +1;\012    if (i == 1 || i == 3 || i == 5){\012        f = 65537 - f;\012    }\012    h = 65537*i + f;\012\012    ac_int<28, false> result;\012    result.set_slc(0, v);\012    result.set_slc(8, h);\012    result.set_slc(27, s);\012\012    return result;\012}\012\012/*\012component hls_always_run_component ac_int<56, false> rgb_to_hsv(\012    ac_int<8, false> red, ac_int<8, false> green, ac_int<8, false> blue\012){\012    \012    // do the conversion\012    uint8_t min, max, mid;\012    \012    if (red > green && red > blue){\012        max = red;\012        if (green > blue){\012            mid = green;\012            min = blue;\012        }\012        else{\012            mid = blue;\012            min = green;\012        }\012    }\012    if (green > red && green > blue){\012        max = green;\012        if (red > blue){\012            mid = red;\012            min = blue;\012        }\012        else{\012            mid = blue;\012            min = red;\012        }\012    }\012    if (blue > red && blue > green){\012        max = blue;\012        if (red > green){\012            mid = red;\012            min = green;\012        }\012        else{\012            mid = green;\012            min = red;\012        }\012    }\012    \012    ac_int<19, false> h = 0;\012    ac_int<16, false> s = 0;\012    ac_int<8, false> v = 0;\012    v = max;\012\012    if (max-min == 0){\012        s = 0;\012        h = 0;\012\012        ac_int<43, false> result;\012        result.set_slc(0, v);\012        result.set_slc(8, s);\012        result.set_slc(24, h);\012\012        return result;\012    }\012\012    uint8_t i;\012    if (max == red && min == blue) i = 0;\012    else if (max == green && min == blue) i = 1;\012    else if (max == green && min == red) i = 2;\012    else if (max == blue && min == red) i = 3;\012    else if (max == blue && min == green) i = 4;\012    else if (max == red && min == green) i = 5;\012    \012    uint32_t delta = max-min;\012    s = ((delta << 16) -1)/max;\012\012    ac_int<1, false> s = 0;\012    \012    uint8_t mod_result = max / 20;\012    if (mod_result == 0) s = (min < 6);\012    else if (mod_result == 1) s = (min < 12);\012    else if (mod_result == 2) s = (min < 18);\012    else if (mod_result == 3) s = (min < 24);\012    else if (mod_result == 4) s = (min < 30);\012    else if (mod_result == 5) s = (min < 36);\012    else if (mod_result == 6) s = (min < 42);\012    else if (mod_result == 7) s = (min < 48);\012    else if (mod_result == 8) s = (min < 64);\012    else if (mod_result == 9) s = (min < 70);\012    else if (mod_result == 10) s = (min < 76);\012    else if (mod_result == 11) s = (min < 82);\012    else if (mod_result == 12) s = (min < 88);\012   \012    uint32_t delta_mid_min = mid-min;\012    \012    ac_int<17, false> f = 0;\012    f = (delta_mid_min << 16)/delta +1;\012    if (i == 1 || i == 3 || i == 5){\012        f = 65537 - f;\012    }\012    h = 65537*i + f;\012\012    ac_int<43, false> result;\012    result.set_slc(0, v);\012    result.set_slc(8, s);\012    result.set_slc(24, h);\012\012    return result;\012}\012*/\012\012/*\012component hls_always_run_component ac_int<56, false> rgb_to_h(\012    ac_int<8, false> red, ac_int<8, false> green, ac_int<8, false> blue\012){\012    \012    // do the conversion\012    uint8_t min, max, mid;\012    \012    if (red > green && red > blue){\012        max = red;\012        if (green > blue){\012            mid = green;\012            min = blue;\012        }\012        else{\012            mid = blue;\012            min = green;\012        }\012    }\012    if (green > red && green > blue){\012        max = green;\012        if (red > blue){\012            mid = red;\012            min = blue;\012        }\012        else{\012            mid = blue;\012            min = red;\012        }\012    }\012    if (blue > red && blue > green){\012        max = blue;\012        if (red > green){\012            mid = red;\012            min = green;\012        }\012        else{\012            mid = green;\012            min = red;\012        }\012    }\012\012    ac_int<19, false> h = 0;\012\012    if (max-min == 0){\012        // return h as some invalid value\012        \012        h = 524287; //this value will never be reached normally\012\012        return h;\012    }\012\012    uint8_t i;\012    if (max == red && min == blue) i = 0;\012    else if (max == green && min == blue) i = 1;\012    else if (max == green && min == red) i = 2;\012    else if (max == blue && min == red) i = 3;\012    else if (max == blue && min == green) i = 4;\012    else if (max == red && min == green) i = 5;\012\012    uint32_t delta_mid_min = mid-min;\012    \012    ac_int<17, false> f = 0;\012    f = (delta_mid_min << 16)/(max-min) +1;\012    if (i == 1 || i == 3 || i == 5){\012        f = 65537 - f;\012    }\012    h = 65537*i + f;\012\012    return h;\012}\012\012component hls_always_run_component ac_int<56, false> rgb_to_s(\012    ac_int<8, false> red, ac_int<8, false> green, ac_int<8, false> blue\012){\012    \012    // do the conversion\012    uint8_t min, max, mid;\012    \012    if (red > green && red > blue){\012        max = red;\012        if (green > blue){\012            mid = green;\012            min = blue;\012        }\012        else{\012            mid = blue;\012            min = green;\012        }\012    }\012    if (green > red && green > blue){\012        max = green;\012        if (red > blue){\012            mid = red;\012            min = blue;\012        }\012        else{\012            mid = blue;\012            min = red;\012        }\012    }\012    if (blue > red && blue > green){\012        max = blue;\012        if (red > green){\012            mid = red;\012            min = green;\012        }\012        else{\012            mid = green;\012            min = red;\012        }\012    }\012\012    ac_int<1, false> s = 0;\012    \012    uint8_t mod_result = max / 20;\012    if (mod_result == 0) s = (min < 6);\012    else if (mod_result == 1) s = (min < 12);\012    else if (mod_result == 2) s = (min < 18);\012    else if (mod_result == 3) s = (min < 24);\012    else if (mod_result == 4) s = (min < 30);\012    else if (mod_result == 5) s = (min < 36);\012    else if (mod_result == 6) s = (min < 42);\012    else if (mod_result == 7) s = (min < 48);\012    else if (mod_result == 8) s = (min < 64);\012    else if (mod_result == 9) s = (min < 70);\012    else if (mod_result == 10) s = (min < 76);\012    else if (mod_result == 11) s = (min < 82);\012    else if (mod_result == 12) s = (min < 88);\012\012    return s;\012    \012}\012\012component hls_always_run_component ac_int<56, false> rgb_to_v(\012    ac_int<8, false> red, ac_int<8, false> green, ac_int<8, false> blue\012){\012    \012    // do the conversion\012    uint8_t min, max, mid;\012    \012    if (red > green && red > blue){\012        max = red;\012        if (green > blue){\012            mid = green;\012            min = blue;\012        }\012        else{\012            mid = blue;\012            min = green;\012        }\012    }\012    if (green > red && green > blue){\012        max = green;\012        if (red > blue){\012            mid = red;\012            min = blue;\012        }\012        else{\012            mid = blue;\012            min = red;\012        }\012    }\012    if (blue > red && blue > green){\012        max = blue;\012        if (red > green){\012            mid = red;\012            min = green;\012        }\012        else{\012            mid = green;\012            min = red;\012        }\012    }\012    \012    ac_int<8, false> v = 0;\012    v = max;\012    return v;\012}\012*/\012/*\012component hls_always_run_component ac_int<25, false> rgb_to_hsv(\012    ac_int<8, false> red, ac_int<8, false> green, ac_int<8, false> blue\012){\012    \012    // do the conversion\012    uint8_t min, max, mid;\012    int16_t sred = red;\012    int16_t sgreen = green;\012    int16_t sblue = blue;\012    \012    if (red > green && red > blue){\012        max = red;\012        if (green > blue){\012            mid = green;\012            min = blue;\012        }\012        else{\012            mid = blue;\012            min = green;\012        }\012    }\012    if (green > red && green > blue){\012        max = green;\012        if (red > blue){\012            mid = red;\012            min = blue;\012        }\012        else{\012            mid = blue;\012            min = red;\012        }\012    }\012    if (blue > red && blue > green){\012        max = blue;\012        if (red > green){\012            mid = red;\012            min = green;\012        }\012        else{\012            mid = green;\012            min = red;\012        }\012    }\012    \012    ac_int<9, false> h = 0;\012    ac_int<8, false> s = 0;\012    ac_int<8, false> v = 0;\012    v = max;\012    int16_t delta = max - min;\012\012    if (v == 0){\012        s = 0;\012        h = 0;\012\012        ac_int<25, false> result;\012        result.set_slc(0, v);\012        result.set_slc(8, s);\012        result.set_slc(16, h);\012\012        return result;\012    }\012\012    if (max == red){\012        h = 60 * (((sgreen-sblue)*100/delta) % 600)/100;\012    }\012    else if (max == green){\012        h = 60 * ((sblue - sred)*100/delta +200)/100;\012    }\012    else if (max == blue){\012        h = 60 * ((sred - sgreen)*100/delta +400)/100;\012    }\012\012    s = delta*100/max;\012\012    ac_int<25, false> result;\012    result.set_slc(0, v);\012    result.set_slc(8, s);\012    result.set_slc(16, h);\012\012    return result;\012}\012*/"}, {"path":"rgb_to_hsv.h", "name":"rgb_to_hsv.h", "has_active_debug_locs":false, "absName":"c:/intelFPGA_lite/18.1/hls/eebalancebug/rgb_to_hsv.h", "content":"#include <HLS/hls.h>\012#include <HLS/ac_int.h>\012\012#ifndef RGBTOHSV_H\012#define RGBTOHSV_H\012\012component ac_int<28, false> rgb_to_hsv(\012    ac_int<8, false> red, ac_int<8, false> green, ac_int<8, false> blue, ac_int<1, false> s\012);\012\012#endif"}, {"path":"C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/xmemory", "name":"xmemory", "has_active_debug_locs":true, "absName":"c:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/xmemory", "content":"// xmemory internal header (from <memory>)\012#pragma once\012#ifndef _XMEMORY_\012#define _XMEMORY_\012#ifndef RC_INVOKED\012#include <cstdlib>\012#include <new>\012#include <xutility>\012\012 #pragma pack(push,_CRT_PACKING)\012 #pragma warning(push,3)\012\012 #define _ALLOCATOR	allocator\012\012 #pragma push_macro(\"new\")\012 #undef new\012\012 #pragma warning(disable: 4100)\012\012#ifndef _FARQ	/* specify standard memory model */\012 #define _FARQ\012 #define _PDFT	ptrdiff_t\012 #define _SIZT	size_t\012#endif /* _FARQ */\012\012_STD_BEGIN\012		// TEMPLATE FUNCTION _Allocate\012template<class _Ty> inline\012	_Ty _FARQ *_Allocate(_SIZT _Count, _Ty _FARQ *)\012	{	// allocate storage for _Count elements of type _Ty\012	void *_Ptr = 0;\012\012	if (_Count <= 0)\012		_Count = 0;\012	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)\012		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)\012		_THROW_NCEE(bad_alloc, 0);\012\012	return ((_Ty _FARQ *)_Ptr);\012	}\012\012		// TEMPLATE FUNCTION _Construct\012template<class _Ty1,\012	class _Ty2> inline\012	void _Construct(_Ty1 _FARQ *_Ptr, _Ty2&& _Val)\012	{	// construct object at _Ptr with value _Val\012	void _FARQ *_Vptr = _Ptr;\012	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));\012	}\012\012template<class _Ty1> inline\012	void _Construct(_Ty1 _FARQ *_Ptr)\012	{	// construct object at _Ptr with default value\012	void _FARQ *_Vptr = _Ptr;\012\012	::new (_Vptr) _Ty1();\012	}\012\012		// TEMPLATE FUNCTION _Destroy\012template<class _Ty> inline\012	void _Destroy(_Ty _FARQ *_Ptr)\012	{	// destroy object at _Ptr\012	_Ptr->~_Ty();\012	}\012\012template<> inline\012	void _Destroy(char _FARQ *)\012	{	// destroy a char (do nothing)\012	}\012\012template<> inline\012	void _Destroy(wchar_t _FARQ *)\012	{	// destroy a wchar_t (do nothing)\012	}\012\012 #ifdef _NATIVE_WCHAR_T_DEFINED\012template<> inline\012	void _Destroy(unsigned short _FARQ *)\012	{	// destroy a unsigned short (do nothing)\012	}\012 #endif /* _NATIVE_WCHAR_T_DEFINED */\012\012		// TEMPLATE FUNCTION _Destroy_range\012template<class _Alloc> inline\012	void _Destroy_range(typename _Alloc::pointer _First,\012		typename _Alloc::pointer _Last, _Alloc& _Al)\012	{	// destroy [_First, _Last)\012	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));\012	}\012\012template<class _Alloc> inline\012	void _Destroy_range(typename _Alloc::pointer _First,\012		typename _Alloc::pointer _Last, _Alloc& _Al,\012		_Nonscalar_ptr_iterator_tag)\012	{	// destroy [_First, _Last), arbitrary type\012	for (; _First != _Last; ++_First)\012		_Dest_val(_Al, _First);\012	}\012\012template<class _Alloc> inline\012	void _Destroy_range(typename _Alloc::pointer _First,\012		typename _Alloc::pointer _Last, _Alloc& _Al,\012		_Scalar_ptr_iterator_tag)\012	{	// destroy [_First, _Last), scalar type (do nothing)\012	}\012\012		// TEMPLATE FUNCTION addressof\012template<class _Ty> inline\012	_Ty * addressof(_Ty& _Val)\012	{	// return address of _Val\012	return ((_Ty *) &(char&)_Val);\012	}\012\012		// TEMPLATE CLASS _Allocator_base\012template<class _Ty>\012	struct _Allocator_base\012	{	// base class for generic allocators\012	typedef _Ty value_type;\012	};\012\012		// TEMPLATE CLASS _Allocator_base<const _Ty>\012template<class _Ty>\012	struct _Allocator_base<const _Ty>\012	{	// base class for generic allocators for const _Ty\012	typedef _Ty value_type;\012	};\012\012		// TEMPLATE CLASS _ALLOCATOR\012template<class _Ty>\012	class _ALLOCATOR\012		: public _Allocator_base<_Ty>\012	{	// generic allocator for objects of class _Ty\012public:\012	typedef _Allocator_base<_Ty> _Mybase;\012	typedef typename _Mybase::value_type value_type;\012\012	typedef value_type _FARQ *pointer;\012	typedef value_type _FARQ& reference;\012	typedef const value_type _FARQ *const_pointer;\012	typedef const value_type _FARQ& const_reference;\012\012	typedef _SIZT size_type;\012	typedef _PDFT difference_type;\012\012	template<class _Other>\012		struct rebind\012		{	// convert this type to _ALLOCATOR<_Other>\012		typedef _ALLOCATOR<_Other> other;\012		};\012\012	pointer address(reference _Val) const\012		{	// return address of mutable _Val\012		return ((pointer) &(char&)_Val);\012		}\012\012	const_pointer address(const_reference _Val) const\012		{	// return address of nonmutable _Val\012		return ((const_pointer) &(char&)_Val);\012		}\012\012	_ALLOCATOR() _THROW0()\012		{	// construct default allocator (do nothing)\012		}\012\012	_ALLOCATOR(const _ALLOCATOR<_Ty>&) _THROW0()\012		{	// construct by copying (do nothing)\012		}\012\012	template<class _Other>\012		_ALLOCATOR(const _ALLOCATOR<_Other>&) _THROW0()\012		{	// construct from a related allocator (do nothing)\012		}\012\012	template<class _Other>\012		_ALLOCATOR<_Ty>& operator=(const _ALLOCATOR<_Other>&)\012		{	// assign from a related allocator (do nothing)\012		return (*this);\012		}\012\012	void deallocate(pointer _Ptr, size_type)\012		{	// deallocate object at _Ptr, ignore size\012		::operator delete(_Ptr);\012		}\012\012	pointer allocate(size_type _Count)\012		{	// allocate array of _Count elements\012		return (_Allocate(_Count, (pointer)0));\012		}\012\012	pointer allocate(size_type _Count, const void _FARQ *)\012		{	// allocate array of _Count elements, ignore hint\012		return (allocate(_Count));\012		}\012\012	void construct(pointer _Ptr, const _Ty& _Val)\012		{	// construct object at _Ptr with value _Val\012		_Construct(_Ptr, _Val);\012		}\012\012	void construct(pointer _Ptr, _Ty&& _Val)\012		{	// construct object at _Ptr with value _Val\012		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Ty>(_Val));\012		}\012\012	template<class _Other>\012		void construct(pointer _Ptr, _Other&& _Val)\012		{	// construct object at _Ptr with value _Val\012		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Other>(_Val));\012		}\012\012	void destroy(pointer _Ptr)\012		{	// destroy object at _Ptr\012		_Destroy(_Ptr);\012		}\012\012	_SIZT max_size() const _THROW0()\012		{	// estimate maximum array size\012		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);\012		return (0 < _Count ? _Count : 1);\012		}\012	};\012\012		// CLASS _ALLOCATOR<void>\012template<> class _ALLOCATOR<void>\012	{	// generic _ALLOCATOR for type void\012public:\012	typedef void _Ty;\012	typedef _Ty _FARQ *pointer;\012	typedef const _Ty _FARQ *const_pointer;\012	typedef _Ty value_type;\012\012	template<class _Other>\012		struct rebind\012		{	// convert this type to an _ALLOCATOR<_Other>\012		typedef _ALLOCATOR<_Other> other;\012		};\012\012	_ALLOCATOR() _THROW0()\012		{	// construct default allocator (do nothing)\012		}\012\012	_ALLOCATOR(const _ALLOCATOR<_Ty>&) _THROW0()\012		{	// construct by copying (do nothing)\012		}\012\012	template<class _Other>\012		_ALLOCATOR(const _ALLOCATOR<_Other>&) _THROW0()\012		{	// construct from related allocator (do nothing)\012		}\012\012	template<class _Other>\012		_ALLOCATOR<_Ty>& operator=(const _ALLOCATOR<_Other>&)\012		{	// assign from a related allocator (do nothing)\012		return (*this);\012		}\012	};\012\012template<class _Ty,\012	class _Other> inline\012	bool operator==(const allocator<_Ty>&,\012		const allocator<_Other>&) _THROW0()\012	{	// test for allocator equality\012	return (true);\012	}\012\012template<class _Ty,\012	class _Other> inline\012	bool operator!=(const allocator<_Ty>& _Left,\012		const allocator<_Other>& _Right) _THROW0()\012	{	// test for allocator inequality\012	return (!(_Left == _Right));\012	}\012\012		// TEMPLATE FUNCTIONS _Cons_val AND _Dest_val\012template<class _Alloc,\012	class _Ty1,\012	class _Ty2>\012	void _Cons_val(_Alloc& _Alval, _Ty1 *_Pdest, _Ty2&& _Src)\012	{	// construct using allocator\012	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));\012	}\012\012template<class _Alloc,\012	class _Ty1>\012	void _Dest_val(_Alloc& _Alval, _Ty1 *_Pdest)\012	{	// destroy using allocator\012	_Alval.destroy(_Pdest);\012	}\012_STD_END\012\012 #pragma pop_macro(\"new\")\012\012 #pragma warning(pop)\012 #pragma pack(pop)\012\012#endif /* RC_INVOKED */\012#endif /* _XMEMORY_ */\012\012/*\012 * This file is derived from software bearing the following\012 * restrictions:\012 *\012 * Copyright (c) 1994\012 * Hewlett-Packard Company\012 *\012 * Permission to use, copy, modify, distribute and sell this\012 * software and its documentation for any purpose is hereby\012 * granted without fee, provided that the above copyright notice\012 * appear in all copies and that both that copyright notice and\012 * this permission notice appear in supporting documentation.\012 * Hewlett-Packard Company makes no representations about the\012 * suitability of this software for any purpose. It is provided\012 * \"as is\" without express or implied warranty.\012 */\012\012/*\012 * Copyright (c) 1992-2009 by P.J. Plauger.  ALL RIGHTS RESERVED.\012 * Consult your license regarding permissions and restrictions.\012V5.20:0009 */\012"}, {"path":"C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/xstring", "name":"xstring", "has_active_debug_locs":true, "absName":"c:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/xstring", "content":"// xstring internal header (from <string>)\012#pragma once\012#ifndef _XSTRING_\012#define _XSTRING_\012#ifndef RC_INVOKED\012#include <xmemory>\012\012 #pragma pack(push,_CRT_PACKING)\012 #pragma warning(push,3)\012\012_STD_BEGIN\012  #pragma warning(disable: 4251)\012\012template<class _Elem,\012	class _Traits = char_traits<_Elem>,\012	class _Ax = allocator<_Elem> >\012	class basic_string;\012\012  #define _STRING_ITER_BASE(it)			(it)._Ptr\012  #define _STRING_CONST_ITERATOR(ptr)	const_iterator(ptr, this)\012  #define _STRING_ITERATOR(ptr)			iterator(ptr, this)\012\012		// TEMPLATE CLASS _String_const_iterator\012template<class _Elem,\012	class _Traits,\012	class _Alloc>\012	class _String_const_iterator\012		: public _Iterator012<random_access_iterator_tag,\012			typename _Alloc::value_type,\012			typename _Alloc::difference_type,\012			typename _Alloc::const_pointer,\012			typename _Alloc::const_reference,\012			_Iterator_base>\012	{	// iterator for nonmutable string\012public:\012	typedef _String_const_iterator<_Elem, _Traits, _Alloc> _Myiter;\012	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;\012	typedef random_access_iterator_tag iterator_category;\012\012	typedef typename _Alloc::value_type value_type;\012	typedef typename _Alloc::difference_type difference_type;\012	typedef typename _Alloc::const_pointer pointer;\012	typedef typename _Alloc::const_reference reference;\012\012	_String_const_iterator()\012		{	// construct with null pointer\012		this->_Ptr = 0;\012		}\012\012	_String_const_iterator(pointer _Parg, const _Container_base *_Pstring)\012		{	// construct with pointer _Parg\012		this->_Adopt(_Pstring);\012		this->_Ptr = _Parg;\012		}\012\012	typedef pointer _Unchecked_type;\012\012	_Myiter& _Rechecked(_Unchecked_type _Right)\012		{	// reset from unchecked iterator\012		this->_Ptr = _Right;\012		return (*this);\012		}\012\012	_Unchecked_type _Unchecked() const\012		{	// make an unchecked iterator\012		return (_Unchecked_type(this->_Ptr));\012		}\012\012	reference operator*() const\012		{	// return designated object\012 #if _ITERATOR_DEBUG_LEVEL == 2\012		if (this->_Getcont() == 0\012			|| this->_Ptr == 0\012			|| this->_Ptr < ((_Mystr *)this->_Getcont())->_Myptr()\012			|| ((_Mystr *)this->_Getcont())->_Myptr()\012				+ ((_Mystr *)this->_Getcont())->_Mysize <= this->_Ptr)\012			{	// report error\012			_DEBUG_ERROR(\"string iterator not dereferencable\");\012			_SCL_SECURE_OUT_OF_RANGE;\012			}\012\012 #elif _ITERATOR_DEBUG_LEVEL == 1\012		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);\012		_SCL_SECURE_VALIDATE_RANGE(\012			((_Mystr *)this->_Getcont())->_Myptr() <= this->_Ptr\012			&& this->_Ptr < ((_Mystr *)this->_Getcont())->_Myptr()\012				+ ((_Mystr *)this->_Getcont())->_Mysize);\012 #endif /* _ITERATOR_DEBUG_LEVEL */\012\012		__analysis_assume(this->_Ptr != 0);\012\012		return (*this->_Ptr);\012		}\012\012	pointer operator->() const\012		{	// return pointer to class object\012		return (&**this);\012		}\012\012	_Myiter& operator++()\012		{	// preincrement\012 #if _ITERATOR_DEBUG_LEVEL == 2\012		if (this->_Getcont() == 0\012			|| this->_Ptr == 0\012			|| ((_Mystr *)this->_Getcont())->_Myptr()\012				+ ((_Mystr *)this->_Getcont())->_Mysize <= this->_Ptr)\012			{	// report error\012			_DEBUG_ERROR(\"string iterator not incrementable\");\012			_SCL_SECURE_OUT_OF_RANGE;\012			}\012\012 #elif _ITERATOR_DEBUG_LEVEL == 1\012		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);\012		_SCL_SECURE_VALIDATE_RANGE(\012			this->_Ptr < ((_Mystr *)this->_Getcont())->_Myptr()\012				+ ((_Mystr *)this->_Getcont())->_Mysize);\012 #endif /* _ITERATOR_DEBUG_LEVEL */\012\012		++this->_Ptr;\012		return (*this);\012		}\012\012	_Myiter operator++(int)\012		{	// postincrement\012		_Myiter _Tmp = *this;\012		++*this;\012		return (_Tmp);\012		}\012\012	_Myiter& operator--()\012		{	// predecrement\012 #if _ITERATOR_DEBUG_LEVEL == 2\012		if (this->_Getcont() == 0\012			|| this->_Ptr == 0\012			|| this->_Ptr <= ((_Mystr *)this->_Getcont())->_Myptr())\012			{	// report error\012			_DEBUG_ERROR(\"string iterator not decrementable\");\012			_SCL_SECURE_OUT_OF_RANGE;\012			}\012\012 #elif _ITERATOR_DEBUG_LEVEL == 1\012		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);\012		_SCL_SECURE_VALIDATE_RANGE(\012			((_Mystr *)this->_Getcont())->_Myptr() < this->_Ptr);\012 #endif /* _ITERATOR_DEBUG_LEVEL */\012\012		--this->_Ptr;\012		return (*this);\012		}\012\012	_Myiter operator--(int)\012		{	// postdecrement\012		_Myiter _Tmp = *this;\012		--*this;\012		return (_Tmp);\012		}\012\012	_Myiter& operator+=(difference_type _Off)\012		{	// increment by integer\012 #if _ITERATOR_DEBUG_LEVEL == 2\012		if (this->_Getcont() == 0\012			|| this->_Ptr == 0\012			|| this->_Ptr + _Off < ((_Mystr *)this->_Getcont())->_Myptr()\012			|| ((_Mystr *)this->_Getcont())->_Myptr()\012				+ ((_Mystr *)this->_Getcont())->_Mysize < this->_Ptr + _Off)\012			{	// report error\012			_DEBUG_ERROR(\"string iterator + offset out of range\");\012			_SCL_SECURE_OUT_OF_RANGE;\012			}\012\012 #elif _ITERATOR_DEBUG_LEVEL == 1\012		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);\012		_SCL_SECURE_VALIDATE_RANGE(\012			((_Mystr *)this->_Getcont())->_Myptr() <= this->_Ptr + _Off\012				&& this->_Ptr + _Off <= ((_Mystr *)this->_Getcont())->_Myptr()\012					+ ((_Mystr *)this->_Getcont())->_Mysize);\012 #endif /* _ITERATOR_DEBUG_LEVEL */\012\012		_Ptr += _Off;\012		return (*this);\012		}\012\012	_Myiter operator+(difference_type _Off) const\012		{	// return this + integer\012		_Myiter _Tmp = *this;\012		return (_Tmp += _Off);\012		}\012\012	_Myiter& operator-=(difference_type _Off)\012		{	// decrement by integer\012		return (*this += -_Off);\012		}\012\012	_Myiter operator-(difference_type _Off) const\012		{	// return this - integer\012		_Myiter _Tmp = *this;\012		return (_Tmp -= _Off);\012		}\012\012	difference_type operator-(const _Myiter& _Right) const\012		{	// return difference of iterators\012		_Compat(_Right);\012		return (this->_Ptr - _Right._Ptr);\012		}\012\012	reference operator[](difference_type _Off) const\012		{	// subscript\012		return (*(*this + _Off));\012		}\012\012	bool operator==(const _Myiter& _Right) const\012		{	// test for iterator equality\012		_Compat(_Right);\012		return (this->_Ptr == _Right._Ptr);\012		}\012\012	bool operator!=(const _Myiter& _Right) const\012		{	// test for iterator inequality\012		return (!(*this == _Right));\012		}\012\012	bool operator<(const _Myiter& _Right) const\012		{	// test if this < _Right\012		_Compat(_Right);\012		return (this->_Ptr < _Right._Ptr);\012		}\012\012	bool operator>(const _Myiter& _Right) const\012		{	// test if this > _Right\012		return (_Right < *this);\012		}\012\012	bool operator<=(const _Myiter& _Right) const\012		{	// test if this <= _Right\012		return (!(_Right < *this));\012		}\012\012	bool operator>=(const _Myiter& _Right) const\012		{	// test if this >= _Right\012		return (!(*this < _Right));\012		}\012\012 #if _ITERATOR_DEBUG_LEVEL == 2\012	void _Compat(const _Myiter& _Right) const\012		{	// test for compatible iterator pair\012		if (this->_Getcont() == 0\012			|| this->_Getcont() != _Right._Getcont())\012			{	// report error\012			_DEBUG_ERROR(\"string iterators incompatible\");\012			_SCL_SECURE_INVALID_ARGUMENT;\012			}\012		}\012\012 #elif _ITERATOR_DEBUG_LEVEL == 1\012	void _Compat(const _Myiter& _Right) const\012		{	// test for compatible iterator pair\012		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);\012		_SCL_SECURE_VALIDATE_RANGE(this->_Getcont() == _Right._Getcont());\012		}\012\012 #else /* _ITERATOR_DEBUG_LEVEL == 0 */\012	void _Compat(const _Myiter&) const\012		{	// test for compatible iterator pair\012		}\012 #endif /* _ITERATOR_DEBUG_LEVEL */\012\012	pointer _Ptr;	// pointer to element in string\012	};\012\012template<class _Elem,\012	class _Traits,\012	class _Alloc> inline\012	typename _String_const_iterator<_Elem, _Traits, _Alloc>::_Unchecked_type\012		_Unchecked(_String_const_iterator<_Elem, _Traits, _Alloc> _Iter)\012	{	// convert to unchecked\012	return (_Iter._Unchecked());\012	}\012\012template<class _Elem,\012	class _Traits,\012	class _Alloc> inline\012	_String_const_iterator<_Elem, _Traits, _Alloc>\012		_Rechecked(_String_const_iterator<_Elem, _Traits, _Alloc>& _Iter,\012			typename _String_const_iterator<_Elem, _Traits, _Alloc>\012				::_Unchecked_type _Right)\012	{	// convert to checked\012	return (_Iter._Rechecked(_Right));\012	}\012\012template<class _Elem,\012	class _Traits,\012	class _Alloc> inline\012	_String_const_iterator<_Elem, _Traits, _Alloc> operator+(\012		typename _String_const_iterator<_Elem, _Traits, _Alloc>\012			::difference_type _Off,\012		_String_const_iterator<_Elem, _Traits, _Alloc> _Next)\012	{	// add offset to iterator\012	return (_Next += _Off);\012	}\012\012		// TEMPLATE CLASS _String_iterator\012template<class _Elem,\012	class _Traits,\012	class _Alloc>\012	class _String_iterator\012		: public _String_const_iterator<_Elem, _Traits, _Alloc>\012	{	// iterator for mutable string\012public:\012	typedef _String_iterator<_Elem, _Traits, _Alloc> _Myiter;\012	typedef _String_const_iterator<_Elem, _Traits, _Alloc> _Mybase;\012	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;\012	typedef random_access_iterator_tag iterator_category;\012\012	typedef typename _Mystr::value_type value_type;\012	typedef typename _Mystr::difference_type difference_type;\012	typedef typename _Mystr::pointer pointer;\012	typedef typename _Mystr::reference reference;\012\012	_String_iterator()\012		{	// construct with null string pointer\012		}\012\012	_String_iterator(pointer _Parg, const _Container_base *_Pstring)\012		: _Mybase(_Parg, _Pstring)\012		{	// construct with pointer _Parg\012		}\012\012	typedef pointer _Unchecked_type;\012\012	_Myiter& _Rechecked(_Unchecked_type _Right)\012		{	// reset from unchecked iterator\012		this->_Ptr = _Right;\012		return (*this);\012		}\012\012	_Unchecked_type _Unchecked() const\012		{	// make an unchecked iterator\012		return (_Unchecked_type(this->_Ptr));\012		}\012\012	reference operator*() const\012		{	// return designated object\012		return ((reference)**(_Mybase *)this);\012		}\012\012	pointer operator->() const\012		{	// return pointer to class object\012		return (&**this);\012		}\012\012	_Myiter& operator++()\012		{	// preincrement\012		++*(_Mybase *)this;\012		return (*this);\012		}\012\012	_Myiter operator++(int)\012		{	// postincrement\012		_Myiter _Tmp = *this;\012		++*this;\012		return (_Tmp);\012		}\012\012	_Myiter& operator--()\012		{	// predecrement\012		--*(_Mybase *)this;\012		return (*this);\012		}\012\012	_Myiter operator--(int)\012		{	// postdecrement\012		_Myiter _Tmp = *this;\012		--*this;\012		return (_Tmp);\012		}\012\012	_Myiter& operator+=(difference_type _Off)\012		{	// increment by integer\012		*(_Mybase *)this += _Off;\012		return (*this);\012		}\012\012	_Myiter operator+(difference_type _Off) const\012		{	// return this + integer\012		_Myiter _Tmp = *this;\012		return (_Tmp += _Off);\012		}\012\012	_Myiter& operator-=(difference_type _Off)\012		{	// decrement by integer\012		return (*this += -_Off);\012		}\012\012	_Myiter operator-(difference_type _Off) const\012		{	// return this - integer\012		_Myiter _Tmp = *this;\012		return (_Tmp -= _Off);\012		}\012\012	difference_type operator-(const _Mybase& _Right) const\012		{	// return difference of iterators\012		return ((_Mybase)*this - _Right);\012		}\012\012	reference operator[](difference_type _Off) const\012		{	// subscript\012		return (*(*this + _Off));\012		}\012	};\012\012template<class _Elem,\012	class _Traits,\012	class _Alloc> inline\012	typename _String_iterator<_Elem, _Traits, _Alloc>::_Unchecked_type\012		_Unchecked(_String_iterator<_Elem, _Traits, _Alloc> _Iter)\012	{	// convert to unchecked\012	return (_Iter._Unchecked());\012	}\012\012template<class _Elem,\012	class _Traits,\012	class _Alloc> inline\012	_String_iterator<_Elem, _Traits, _Alloc>\012		_Rechecked(_String_iterator<_Elem, _Traits, _Alloc>& _Iter,\012			typename _String_iterator<_Elem, _Traits, _Alloc>\012				::_Unchecked_type _Right)\012	{	// convert to checked\012	return (_Iter._Rechecked(_Right));\012	}\012\012template<class _Elem,\012	class _Traits,\012	class _Alloc> inline\012	_String_iterator<_Elem, _Traits, _Alloc> operator+(\012		typename _String_iterator<_Elem, _Traits, _Alloc>\012			::difference_type _Off,\012		_String_iterator<_Elem, _Traits, _Alloc> _Next)\012	{	// add offset to iterator\012	return (_Next += _Off);\012	}\012\012		// TEMPLATE CLASS _String_val\012template<class _Elem,\012	class _Alloc>\012	class _String_val\012		: public _Container_base\012	{	// base class for basic_string to hold data\012public:\012 #if _ITERATOR_DEBUG_LEVEL == 0\012	typedef typename _Alloc::template rebind<_Elem>::other _Alty;\012\012	_String_val(_Alty _Al = _Alty())\012		: _Alval(_Al)\012		{	// construct allocator from _Al\012		}\012\012	~_String_val()\012		{	// destroy the object\012		}\012\012 #else /* _ITERATOR_DEBUG_LEVEL == 0 */\012	typedef typename _Alloc::template rebind<_Elem>::other _Alty;\012\012	_String_val(_Alty _Al = _Alty())\012		: _Alval(_Al)\012		{	// construct allocator from _Al\012		typename _Alloc::template rebind<_Container_proxy>::other\012			_Alproxy(_Alval);\012		this->_Myproxy = _Alproxy.allocate(1);\012		_Cons_val(_Alproxy, this->_Myproxy, _Container_proxy());\012		this->_Myproxy->_Mycont = this;\012		}\012\012	~_String_val()\012		{	// destroy the object\012		typename _Alloc::template rebind<_Container_proxy>::other\012			_Alproxy(_Alval);\012		this->_Orphan_all();\012		_Dest_val(_Alproxy, this->_Myproxy);\012		_Alproxy.deallocate(this->_Myproxy, 1);\012		this->_Myproxy = 0;\012		}\012 #endif /* _ITERATOR_DEBUG_LEVEL == 0 */\012\012	typedef typename _Alty::size_type size_type;\012	typedef typename _Alty::difference_type difference_type;\012	typedef typename _Alty::pointer pointer;\012	typedef typename _Alty::const_pointer const_pointer;\012	typedef typename _Alty::reference reference;\012	typedef typename _Alty::const_reference const_reference;\012	typedef typename _Alty::value_type value_type;\012\012	enum\012		{	// length of internal buffer, [1, 16]\012		_BUF_SIZE = 16 / sizeof (_Elem) < 1 ? 1\012			: 16 / sizeof (_Elem)};\012	enum\012		{	// roundup mask for allocated buffers, [0, 15]\012		_ALLOC_MASK = sizeof (_Elem) <= 1 ? 15\012			: sizeof (_Elem) <= 2 ? 7\012			: sizeof (_Elem) <= 4 ? 3\012			: sizeof (_Elem) <= 8 ? 1 : 0};\012\012	union _Bxty\012		{	// storage for small buffer or pointer to larger one\012		_Elem _Buf[_BUF_SIZE];\012		_Elem *_Ptr;\012		char _Alias[_BUF_SIZE];	// to permit aliasing\012		} _Bx;\012\012	size_type _Mysize;	// current length of string\012	size_type _Myres;	// current storage reserved for string\012	_Alty _Alval;	// allocator object for strings\012	};\012\012		// TEMPLATE CLASS basic_string\012template<class _Elem,\012	class _Traits,\012	class _Ax>\012	class basic_string\012		: public _String_val<_Elem, _Ax>\012	{	// null-terminated transparent array of elements\012public:\012	typedef basic_string<_Elem, _Traits, _Ax> _Myt;\012	typedef _String_val<_Elem, _Ax> _Mybase;\012	typedef typename _Mybase::_Alty _Alloc;\012	typedef typename _Alloc::size_type size_type;\012	typedef typename _Alloc::difference_type difference_type;\012	typedef typename _Alloc::pointer pointer;\012	typedef typename _Alloc::const_pointer const_pointer;\012	typedef typename _Alloc::reference reference;\012	typedef typename _Alloc::const_reference const_reference;\012	typedef typename _Alloc::value_type value_type;\012\012	typedef _String_iterator<_Elem, _Traits, _Alloc> iterator;\012	typedef _String_const_iterator<_Elem, _Traits, _Alloc> const_iterator;\012\012	typedef _STD reverse_iterator<iterator> reverse_iterator;\012	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;\012\012	basic_string(const _Myt& _Right)\012		: _Mybase(_Right._Alval)\012		{	// construct by copying _Right\012		_Tidy();\012		assign(_Right, 0, npos);\012		}\012\012	basic_string()\012		: _Mybase()\012		{	// construct empty string\012		_Tidy();\012		}\012\012	explicit basic_string(const _Alloc& _Al)\012		: _Mybase(_Al)\012		{	// construct empty string with allocator\012		_Tidy();\012		}\012\012	basic_string(const _Myt& _Right, size_type _Roff,\012		size_type _Count = npos)\012		: _Mybase(_Right._Alval)\012		{	// construct from _Right [_Roff, _Roff + _Count)\012		_Tidy();\012		assign(_Right, _Roff, _Count);\012		}\012\012	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,\012		const _Alloc& _Al)\012		: _Mybase(_Al)\012		{	// construct from _Right [_Roff, _Roff + _Count) with allocator\012		_Tidy();\012		assign(_Right, _Roff, _Count);\012		}\012\012	basic_string(const _Elem *_Ptr, size_type _Count)\012		: _Mybase()\012		{	// construct from [_Ptr, _Ptr + _Count)\012		_Tidy();\012		assign(_Ptr, _Count);\012		}\012\012	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)\012		: _Mybase(_Al)\012		{	// construct from [_Ptr, _Ptr + _Count) with allocator\012		_Tidy();\012		assign(_Ptr, _Count);\012		}\012\012	basic_string(const _Elem *_Ptr)\012		: _Mybase()\012		{	// construct from [_Ptr, <null>)\012		_Tidy();\012		assign(_Ptr);\012		}\012\012	basic_string(const _Elem *_Ptr, const _Alloc& _Al)\012		: _Mybase(_Al)\012		{	// construct from [_Ptr, <null>) with allocator\012		_Tidy();\012		assign(_Ptr);\012		}\012\012	basic_string(size_type _Count, _Elem _Ch)\012		: _Mybase()\012		{	// construct from _Count * _Ch\012		_Tidy();\012		assign(_Count, _Ch);\012		}\012\012	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)\012		: _Mybase(_Al)\012		{	// construct from _Count * _Ch with allocator\012		_Tidy();\012		assign(_Count, _Ch);\012		}\012\012	template<class _It>\012		basic_string(_It _First, _It _Last)\012		: _Mybase()\012		{	// construct from [_First, _Last)\012		_Tidy();\012		_Construct(_First, _Last, _Iter_cat(_First));\012		}\012\012	template<class _It>\012		basic_string(_It _First, _It _Last, const _Alloc& _Al)\012		: _Mybase(_Al)\012		{	// construct from [_First, _Last) with allocator\012		_Tidy();\012		_Construct(_First, _Last, _Iter_cat(_First));\012		}\012\012	template<class _It>\012		void _Construct(_It _Count,\012			_It _Ch, _Int_iterator_tag)\012		{	// initialize from _Count * _Ch\012		assign((size_type)_Count, (_Elem)_Ch);\012		}\012\012	template<class _It>\012		void _Construct(_It _First,\012			_It _Last, input_iterator_tag)\012		{	// initialize from [_First, _Last), input iterators\012		_TRY_BEGIN\012		for (; _First != _Last; ++_First)\012			append((size_type)1, (_Elem)*_First);\012		_CATCH_ALL\012		_Tidy(true);\012		_RERAISE;\012		_CATCH_END\012		}\012\012	template<class _It>\012		void _Construct(_It _First,\012			_It _Last, forward_iterator_tag)\012		{	// initialize from [_First, _Last), forward iterators\012		_DEBUG_RANGE(_First, _Last);\012		size_type _Count = 0;\012		_Distance(_First, _Last, _Count);\012		reserve(_Count);\012\012		_TRY_BEGIN\012		for (; _First != _Last; ++_First)\012			append((size_type)1, (_Elem)*_First);\012		_CATCH_ALL\012		_Tidy(true);\012		_RERAISE;\012		_CATCH_END\012		}\012\012	basic_string(const_pointer _First, const_pointer _Last)\012		: _Mybase()\012		{	// construct from [_First, _Last), const pointers\012		_DEBUG_RANGE(_First, _Last);\012		_Tidy();\012		if (_First != _Last)\012			assign(&*_First, _Last - _First);\012		}\012\012	basic_string(const_pointer _First, const_pointer _Last,\012		const _Alloc& _Al)\012		: _Mybase(_Al)\012		{	// construct from [_First, _Last), const pointers\012		_DEBUG_RANGE(_First, _Last);\012		_Tidy();\012		if (_First != _Last)\012			assign(&*_First, _Last - _First);\012		}\012\012	basic_string(const_iterator _First, const_iterator _Last)\012		: _Mybase()\012		{	// construct from [_First, _Last), const_iterators\012		_DEBUG_RANGE(_First, _Last);\012		_Tidy();\012		if (_First != _Last)\012			assign(&*_First, _Last - _First);\012		}\012\012	basic_string(_Myt&& _Right)\012		: _Mybase(_STD forward<_Alloc>(_Right._Alval))\012		{	// construct by moving _Right\012		_Tidy();\012		assign(_STD forward<_Myt>(_Right));\012		}\012\012	_Myt& operator=(_Myt&& _Right)\012		{	// assign by moving _Right\012		return (assign(_STD forward<_Myt>(_Right)));\012		}\012\012	_Myt& assign(_Myt&& _Right)\012		{	// assign by moving _Right\012		if (this == &_Right)\012			;\012		else if (get_allocator() != _Right.get_allocator()\012			&& this->_BUF_SIZE <= _Right._Myres)\012			*this = _Right;\012		else\012			{	// not same, clear this and steal from _Right\012			_Tidy(true);\012			if (_Right._Myres < this->_BUF_SIZE)\012				_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,\012					_Right._Mysize + 1);\012			else\012				{	// copy pointer\012				this->_Bx._Ptr = _Right._Bx._Ptr;\012				_Right._Bx._Ptr = 0;\012				}\012			this->_Mysize = _Right._Mysize;\012			this->_Myres = _Right._Myres;\012\012			_Right._Mysize = 0;\012			_Right._Myres = 0;\012			}\012		return (*this);\012		}\012\012	void swap(_Myt&& _Right)\012		{	// exchange contents with movable _Right\012		if (this != &_Right)\012			{	// swap with emptied container\012 #if 0 < _ITERATOR_DEBUG_LEVEL\012			this->_Orphan_all();\012			this->_Swap_all(_Right);\012 #endif /* 0 < _ITERATOR_DEBUG_LEVEL */\012\012			assign(_STD forward<_Myt>(_Right));\012			}\012		}\012\012	~basic_string()\012		{	// destroy the string\012		_Tidy(true);\012		}\012\012	typedef _Traits traits_type;\012	typedef _Alloc allocator_type;\012\012	_PGLOBAL static const size_type npos;	// bad/missing length/position\012\012	_Myt& operator=(const _Myt& _Right)\012		{	// assign _Right\012		return (assign(_Right));\012		}\012\012	_Myt& operator=(const _Elem *_Ptr)\012		{	// assign [_Ptr, <null>)\012		return (assign(_Ptr));\012		}\012\012	_Myt& operator=(_Elem _Ch)\012		{	// assign 1 * _Ch\012		return (assign(1, _Ch));\012		}\012\012	_Myt& operator+=(const _Myt& _Right)\012		{	// append _Right\012		return (append(_Right));\012		}\012\012	_Myt& operator+=(const _Elem *_Ptr)\012		{	// append [_Ptr, <null>)\012		return (append(_Ptr));\012		}\012\012	_Myt& operator+=(_Elem _Ch)\012		{	// append 1 * _Ch\012		return (append((size_type)1, _Ch));\012		}\012\012	_Myt& append(const _Myt& _Right)\012		{	// append _Right\012		return (append(_Right, 0, npos));\012		}\012\012	_Myt& append(const _Myt& _Right,\012		size_type _Roff, size_type _Count)\012		{	// append _Right [_Roff, _Roff + _Count)\012		if (_Right.size() < _Roff)\012			_Xran();	// _Roff off end\012		size_type _Num = _Right.size() - _Roff;\012		if (_Num < _Count)\012			_Count = _Num;	// trim _Count to size\012		if (npos - this->_Mysize <= _Count)\012			_Xlen();	// result too long\012\012		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))\012			{	// make room and append new stuff\012			_Traits::copy(_Myptr() + this->_Mysize,\012				_Right._Myptr() + _Roff, _Count);\012			_Eos(_Num);\012			}\012		return (*this);\012		}\012\012	_Myt& append(const _Elem *_Ptr, size_type _Count)\012		{	// append [_Ptr, _Ptr + _Count)\012 #if _ITERATOR_DEBUG_LEVEL == 2\012		if (_Count != 0)\012			_DEBUG_POINTER(_Ptr);\012 #endif /* _ITERATOR_DEBUG_LEVEL == 2 */\012\012		if (_Inside(_Ptr))\012			return (append(*this, _Ptr - _Myptr(), _Count));	// substring\012		if (npos - this->_Mysize <= _Count)\012			_Xlen();	// result too long\012\012		size_type _Num;\012		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))\012			{	// make room and append new stuff\012			_Traits::copy(_Myptr() + this->_Mysize, _Ptr, _Count);\012			_Eos(_Num);\012			}\012		return (*this);\012		}\012\012	_Myt& append(const _Elem *_Ptr)\012		{	// append [_Ptr, <null>)\012		_DEBUG_POINTER(_Ptr);\012		return (append(_Ptr, _Traits::length(_Ptr)));\012		}\012\012	_Myt& append(size_type _Count, _Elem _Ch)\012		{	// append _Count * _Ch\012		if (npos - this->_Mysize <= _Count)\012			_Xlen();	// result too long\012\012		size_type _Num;\012		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))\012			{	// make room and append new stuff using assign\012			_Chassign(this->_Mysize, _Count, _Ch);\012			_Eos(_Num);\012			}\012		return (*this);\012		}\012\012	template<class _It>\012		_Myt& append(_It _First, _It _Last)\012		{	// append [_First, _Last)\012		return (_Append(_First, _Last, _Iter_cat(_First)));\012		}\012\012	template<class _It>\012		_Myt& _Append(_It _Count, _It _Ch, _Int_iterator_tag)\012		{	// append _Count * _Ch\012		return (append((size_type)_Count, (_Elem)_Ch));\012		}\012\012	template<class _It>\012		_Myt& _Append(_It _First, _It _Last, input_iterator_tag)\012		{	// append [_First, _Last), input iterators\012		return (replace(end(), end(), _First, _Last));\012		}\012\012	_Myt& append(const_pointer _First, const_pointer _Last)\012		{	// append [_First, _Last), const pointers\012		return (replace(end(), end(), _First, _Last));\012		}\012\012	_Myt& append(const_iterator _First, const_iterator _Last)\012		{	// append [_First, _Last), const_iterators\012		return (replace(end(), end(), _First, _Last));\012		}\012\012	_Myt& assign(const _Myt& _Right)\012		{	// assign _Right\012		return (assign(_Right, 0, npos));\012		}\012\012	_Myt& assign(const _Myt& _Right,\012		size_type _Roff, size_type _Count)\012		{	// assign _Right [_Roff, _Roff + _Count)\012		if (_Right.size() < _Roff)\012			_Xran();	// _Roff off end\012		size_type _Num = _Right.size() - _Roff;\012		if (_Count < _Num)\012			_Num = _Count;	// trim _Num to size\012\012		if (this == &_Right)\012			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring\012		else if (_Grow(_Num))\012			{	// make room and assign new stuff\012			_Traits::copy(_Myptr(), _Right._Myptr() + _Roff, _Num);\012			_Eos(_Num);\012			}\012		return (*this);\012		}\012\012	_Myt& assign(const _Elem *_Ptr, size_type _Count)\012		{	// assign [_Ptr, _Ptr + _Count)\012 #if _ITERATOR_DEBUG_LEVEL == 2\012		if (_Count != 0)\012			_DEBUG_POINTER(_Ptr);\012 #endif /* _ITERATOR_DEBUG_LEVEL == 2 */\012\012		if (_Inside(_Ptr))\012			return (assign(*this, _Ptr - _Myptr(), _Count));	// substring\012\012		if (_Grow(_Count))\012			{	// make room and assign new stuff\012			_Traits::copy(_Myptr(), _Ptr, _Count);\012			_Eos(_Count);\012			}\012		return (*this);\012		}\012\012	_Myt& assign(const _Elem *_Ptr)\012		{	// assign [_Ptr, <null>)\012		_DEBUG_POINTER(_Ptr);\012		return (assign(_Ptr, _Traits::length(_Ptr)));\012		}\012\012	_Myt& assign(size_type _Count, _Elem _Ch)\012		{	// assign _Count * _Ch\012		if (_Count == npos)\012			_Xlen();	// result too long\012\012		if (_Grow(_Count))\012			{	// make room and assign new stuff\012			_Chassign(0, _Count, _Ch);\012			_Eos(_Count);\012			}\012		return (*this);\012		}\012\012	template<class _It>\012		_Myt& assign(_It _First, _It _Last)\012		{	// assign [First, _Last)\012		return (_Assign(_First, _Last, _Iter_cat(_First)));\012		}\012\012	template<class _It>\012		_Myt& _Assign(_It _Count, _It _Ch, _Int_iterator_tag)\012		{	// assign _Count * _Ch\012		return (assign((size_type)_Count, (_Elem)_Ch));\012		}\012\012	template<class _It>\012		_Myt& _Assign(_It _First, _It _Last, input_iterator_tag)\012		{	// assign [First, _Last), input iterators\012		return (replace(begin(), end(), _First, _Last));\012		}\012\012	_Myt& assign(const_pointer _First, const_pointer _Last)\012		{	// assign [First, _Last), const pointers\012		return (replace(begin(), end(), _First, _Last));\012		}\012\012	_Myt& assign(const_iterator _First, const_iterator _Last)\012		{	// assign [First, _Last), const_iterators\012		return (replace(begin(), end(), _First, _Last));\012		}\012\012	_Myt& insert(size_type _Off, const _Myt& _Right)\012		{	// insert _Right at _Off\012		return (insert(_Off, _Right, 0, npos));\012		}\012\012	_Myt& insert(size_type _Off,\012		const _Myt& _Right, size_type _Roff, size_type _Count)\012		{	// insert _Right [_Roff, _Roff + _Count) at _Off\012		if (this->_Mysize < _Off || _Right.size() < _Roff)\012			_Xran();	// _Off or _Roff off end\012		size_type _Num = _Right.size() - _Roff;\012		if (_Num < _Count)\012			_Count = _Num;	// trim _Count to size\012		if (npos - this->_Mysize <= _Count)\012			_Xlen();	// result too long\012\012		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))\012			{	// make room and insert new stuff\012			_Traits::move(_Myptr() + _Off + _Count,\012				_Myptr() + _Off, this->_Mysize - _Off);	// empty out hole\012			if (this == &_Right)\012				_Traits::move(_Myptr() + _Off,\012					_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),\012						_Count);	// substring\012			else\012				_Traits::copy(_Myptr() + _Off,\012					_Right._Myptr() + _Roff, _Count);	// fill hole\012			_Eos(_Num);\012			}\012		return (*this);\012		}\012\012	_Myt& insert(size_type _Off,\012		const _Elem *_Ptr, size_type _Count)\012		{	// insert [_Ptr, _Ptr + _Count) at _Off\012 #if _ITERATOR_DEBUG_LEVEL == 2\012		if (_Count != 0)\012			_DEBUG_POINTER(_Ptr);\012 #endif /* _ITERATOR_DEBUG_LEVEL == 2 */\012\012		if (_Inside(_Ptr))\012			return (insert(_Off, *this,\012				_Ptr - _Myptr(), _Count));	// substring\012		if (this->_Mysize < _Off)\012			_Xran();	// _Off off end\012		if (npos - this->_Mysize <= _Count)\012			_Xlen();	// result too long\012		size_type _Num;\012		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))\012			{	// make room and insert new stuff\012			_Traits::move(_Myptr() + _Off + _Count,\012				_Myptr() + _Off, this->_Mysize - _Off);	// empty out hole\012			_Traits::copy(_Myptr() + _Off, _Ptr, _Count);	// fill hole\012			_Eos(_Num);\012			}\012		return (*this);\012		}\012\012	_Myt& insert(size_type _Off, const _Elem *_Ptr)\012		{	// insert [_Ptr, <null>) at _Off\012		_DEBUG_POINTER(_Ptr);\012		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));\012		}\012\012	_Myt& insert(size_type _Off,\012		size_type _Count, _Elem _Ch)\012		{	// insert _Count * _Ch at _Off\012		if (this->_Mysize < _Off)\012			_Xran();	// _Off off end\012		if (npos - this->_Mysize <= _Count)\012			_Xlen();	// result too long\012		size_type _Num;\012		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))\012			{	// make room and insert new stuff\012			_Traits::move(_Myptr() + _Off + _Count,\012				_Myptr() + _Off, this->_Mysize - _Off);	// empty out hole\012			_Chassign(_Off, _Count, _Ch);	// fill hole\012			_Eos(_Num);\012			}\012		return (*this);\012		}\012\012	iterator insert(const_iterator _Where)\012		{	// insert <null> at _Where\012		return (insert(_Where, _Elem()));\012		}\012\012	iterator insert(const_iterator _Where, _Elem _Ch)\012		{	// insert _Ch at _Where\012		size_type _Off = _Pdif(_Where, begin());\012		insert(_Off, 1, _Ch);\012		return (begin() + _Off);\012		}\012\012	void insert(const_iterator _Where, size_type _Count, _Elem _Ch)\012		{	// insert _Count * _Elem at _Where\012		size_type _Off = _Pdif(_Where, begin());\012		insert(_Off, _Count, _Ch);\012		}\012\012	template<class _It>\012		void insert(const_iterator _Where, _It _First, _It _Last)\012		{	// insert [_First, _Last) at _Where\012		_Insert(_Where, _First, _Last, _Iter_cat(_First));\012		}\012\012	template<class _It>\012		void _Insert(const_iterator _Where, _It _Count, _It _Ch,\012			_Int_iterator_tag)\012		{	// insert _Count * _Ch at _Where\012		insert(_Where, (size_type)_Count, (_Elem)_Ch);\012		}\012\012	template<class _It>\012		void _Insert(const_iterator _Where, _It _First, _It _Last,\012			input_iterator_tag)\012		{	// insert [_First, _Last) at _Where, input iterators\012		replace(_Where, _Where, _First, _Last);\012		}\012\012	void insert(const_iterator _Where,\012		const_pointer _First, const_pointer _Last)\012		{	// insert [_First, _Last) at _Where, const pointers\012		replace(_Where, _Where, _First, _Last);\012		}\012\012	void insert(const_iterator _Where,\012		const_iterator _First, const_iterator _Last)\012		{	// insert [_First, _Last) at _Where, const_iterators\012		replace(_Where, _Where, _First, _Last);\012		}\012\012	_Myt& erase(size_type _Off = 0,\012		size_type _Count = npos)\012		{	// erase elements [_Off, _Off + _Count)\012		if (this->_Mysize < _Off)\012			_Xran();	// _Off off end\012		if (this->_Mysize - _Off < _Count)\012			_Count = this->_Mysize - _Off;	// trim _Count\012		if (0 < _Count)\012			{	// move elements down\012			_Traits::move(_Myptr() + _Off, _Myptr() + _Off + _Count,\012				this->_Mysize - _Off - _Count);\012			size_type _Newsize = this->_Mysize - _Count;\012			_Eos(_Newsize);\012			}\012		return (*this);\012		}\012\012	iterator erase(const_iterator _Where)\012		{	// erase element at _Where\012		size_type _Count = _Pdif(_Where, begin());\012		erase(_Count, 1);\012		return (_STRING_ITERATOR(_Myptr() + _Count));\012		}\012\012	iterator erase(const_iterator _First, const_iterator _Last)\012		{	// erase substring [_First, _Last)\012		size_type _Count = _Pdif(_First, begin());\012		erase(_Count, _Pdif(_Last, _First));\012		return (_STRING_ITERATOR(_Myptr() + _Count));\012		}\012\012	void clear()\012		{	// erase all\012		_Eos(0);\012		}\012\012	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)\012		{	// replace [_Off, _Off + _N0) with _Right\012		return (replace(_Off, _N0, _Right, 0, npos));\012		}\012\012	_Myt& replace(size_type _Off,\012		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)\012		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)\012		if (this->_Mysize < _Off || _Right.size() < _Roff)\012			_Xran();	// _Off or _Roff off end\012		if (this->_Mysize - _Off < _N0)\012			_N0 = this->_Mysize - _Off;	// trim _N0 to size\012		size_type _Num = _Right.size() - _Roff;\012		if (_Num < _Count)\012			_Count = _Num;	// trim _Count to size\012		if (npos - _Count <= this->_Mysize - _N0)\012			_Xlen();	// result too long\012\012		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail\012		size_type _Newsize = this->_Mysize + _Count - _N0;\012		if (this->_Mysize < _Newsize)\012			_Grow(_Newsize);\012\012		if (this != &_Right)\012			{	// no overlap, just move down and copy in new stuff\012			_Traits::move(_Myptr() + _Off + _Count,\012				_Myptr() + _Off + _N0, _Nm);	// empty hole\012			_Traits::copy(_Myptr() + _Off,\012				_Right._Myptr() + _Roff, _Count);	// fill hole\012			}\012		else if (_Count <= _N0)\012			{	// hole doesn't get larger, just copy in substring\012			_Traits::move(_Myptr() + _Off,\012				_Myptr() + _Roff, _Count);	// fill hole\012			_Traits::move(_Myptr() + _Off + _Count,\012				_Myptr() + _Off + _N0, _Nm);	// move tail down\012			}\012		else if (_Roff <= _Off)\012			{	// hole gets larger, substring begins before hole\012			_Traits::move(_Myptr() + _Off + _Count,\012				_Myptr() + _Off + _N0, _Nm);	// move tail down\012			_Traits::move(_Myptr() + _Off,\012				_Myptr() + _Roff, _Count);	// fill hole\012			}\012		else if (_Off + _N0 <= _Roff)\012			{	// hole gets larger, substring begins after hole\012			_Traits::move(_Myptr() + _Off + _Count,\012				_Myptr() + _Off + _N0, _Nm);	// move tail down\012			_Traits::move(_Myptr() + _Off,\012				_Myptr() + (_Roff + _Count - _N0), _Count);	// fill hole\012			}\012		else\012			{	// hole gets larger, substring begins in hole\012			_Traits::move(_Myptr() + _Off,\012				_Myptr() + _Roff, _N0);	// fill old hole\012			_Traits::move(_Myptr() + _Off + _Count,\012				_Myptr() + _Off + _N0, _Nm);	// move tail down\012			_Traits::move(_Myptr() + _Off + _N0, _Myptr() + _Roff + _Count,\012				_Count - _N0);	// fill rest of new hole\012			}\012\012		_Eos(_Newsize);\012		return (*this);\012		}\012\012	_Myt& replace(size_type _Off,\012		size_type _N0, const _Elem *_Ptr, size_type _Count)\012		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)\012 #if _ITERATOR_DEBUG_LEVEL == 2\012		if (_Count != 0)\012			_DEBUG_POINTER(_Ptr);\012 #endif /* _ITERATOR_DEBUG_LEVEL == 2 */\012\012		if (_Inside(_Ptr))\012			return (replace(_Off, _N0, *this,\012				_Ptr - _Myptr(), _Count));	// substring, replace carefully\012		if (this->_Mysize < _Off)\012			_Xran();	// _Off off end\012		if (this->_Mysize - _Off < _N0)\012			_N0 = this->_Mysize - _Off;	// trim _N0 to size\012		if (npos - _Count <= this->_Mysize - _N0)\012			_Xlen();	// result too long\012		size_type _Nm = this->_Mysize - _N0 - _Off;\012\012		if (_Count < _N0)\012			_Traits::move(_Myptr() + _Off + _Count,\012				_Myptr() + _Off + _N0, _Nm);	// smaller hole, move tail up\012		size_type _Num;\012		if ((0 < _Count || 0 < _N0)\012			&& _Grow(_Num = this->_Mysize + _Count - _N0))\012			{	// make room and rearrange\012			if (_N0 < _Count)\012				_Traits::move(_Myptr() + _Off + _Count,\012					_Myptr() + _Off + _N0, _Nm);	// move tail down\012			_Traits::copy(_Myptr() + _Off, _Ptr, _Count);	// fill hole\012			_Eos(_Num);\012			}\012		return (*this);\012		}\012\012	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)\012		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)\012		_DEBUG_POINTER(_Ptr);\012		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));\012		}\012\012	_Myt& replace(size_type _Off,\012		size_type _N0, size_type _Count, _Elem _Ch)\012		{	// replace [_Off, _Off + _N0) with _Count * _Ch\012		if (this->_Mysize < _Off)\012			_Xran();	// _Off off end\012		if (this->_Mysize - _Off < _N0)\012			_N0 = this->_Mysize - _Off;	// trim _N0 to size\012		if (npos - _Count <= this->_Mysize - _N0)\012			_Xlen();	// result too long\012		size_type _Nm = this->_Mysize - _N0 - _Off;\012\012		if (_Count < _N0)\012			_Traits::move(_Myptr() + _Off + _Count,\012				_Myptr() + _Off + _N0, _Nm);	// smaller hole, move tail up\012		size_type _Num;\012		if ((0 < _Count || 0 < _N0)\012			&& _Grow(_Num = this->_Mysize + _Count - _N0))\012			{	// make room and rearrange\012			if (_N0 < _Count)\012				_Traits::move(_Myptr() + _Off + _Count,\012					_Myptr() + _Off + _N0, _Nm);	// move tail down\012			_Chassign(_Off, _Count, _Ch);	// fill hole\012			_Eos(_Num);\012			}\012		return (*this);\012		}\012\012	_Myt& replace(const_iterator _First, const_iterator _Last,\012		const _Myt& _Right)\012		{	// replace [_First, _Last) with _Right\012		return (replace(\012			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));\012		}\012\012	_Myt& replace(const_iterator _First, const_iterator _Last,\012		const _Elem *_Ptr, size_type _Count)\012		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)\012		return (replace(\012			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));\012		}\012\012	_Myt& replace(const_iterator _First, const_iterator _Last,\012		const _Elem *_Ptr)\012		{	// replace [_First, _Last) with [_Ptr, <null>)\012		return (replace(\012			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));\012		}\012\012	_Myt& replace(const_iterator _First, const_iterator _Last,\012		size_type _Count, _Elem _Ch)\012		{	// replace [_First, _Last) with _Count * _Ch\012		return (replace(\012			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));\012		}\012\012	template<class _It>\012		_Myt& replace(const_iterator _First, const_iterator _Last,\012			_It _First2, _It _Last2)\012		{	// replace [_First, _Last) with [_First2, _Last2)\012		return (_Replace(_First, _Last,\012			_First2, _Last2, _Iter_cat(_First2)));\012		}\012\012	template<class _It>\012		_Myt& _Replace(const_iterator _First, const_iterator _Last,\012			_It _Count, _It _Ch, _Int_iterator_tag)\012		{	// replace [_First, _Last) with _Count * _Ch\012		return (replace(_First, _Last, (size_type)_Count, (_Elem)_Ch));\012		}\012\012	template<class _It>\012		_Myt& _Replace(const_iterator _First, const_iterator _Last,\012			_It _First2, _It _Last2, input_iterator_tag)\012		{	// replace [_First, _Last) with [_First2, _Last2), input iterators\012		_Myt _Right(_First2, _Last2);\012		replace(_First, _Last, _Right);\012		return (*this);\012		}\012\012	_Myt& replace(const_iterator _First, const_iterator _Last,\012		const_pointer _First2, const_pointer _Last2)\012		{	// replace [_First, _Last) with [_First2, _Last2), const pointers\012		if (_First2 == _Last2)\012			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));\012		else\012			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),\012				&*_First2, _Last2 - _First2);\012		return (*this);\012		}\012\012	_Myt& replace(const_iterator _First, const_iterator _Last,\012		const_iterator _First2, const_iterator _Last2)\012		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators\012		if (_First2 == _Last2)\012			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));\012		else\012			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),\012				&*_First2, _Last2 - _First2);\012		return (*this);\012		}\012\012	iterator begin()\012		{	// return iterator for beginning of mutable sequence\012		return (_STRING_ITERATOR(_Myptr()));\012		}\012\012	const_iterator begin() const\012		{	// return iterator for beginning of nonmutable sequence\012		return (_STRING_CONST_ITERATOR(_Myptr()));\012		}\012\012	iterator end()\012		{	// return iterator for end of mutable sequence\012		return (_STRING_ITERATOR(_Myptr() + this->_Mysize));\012		}\012\012	const_iterator end() const\012		{	// return iterator for end of nonmutable sequence\012		return (_STRING_CONST_ITERATOR(_Myptr() + this->_Mysize));\012		}\012\012	reverse_iterator rbegin()\012		{	// return iterator for beginning of reversed mutable sequence\012		return (reverse_iterator(end()));\012		}\012\012	const_reverse_iterator rbegin() const\012		{	// return iterator for beginning of reversed nonmutable sequence\012		return (const_reverse_iterator(end()));\012		}\012\012	reverse_iterator rend()\012		{	// return iterator for end of reversed mutable sequence\012		return (reverse_iterator(begin()));\012		}\012\012	const_reverse_iterator rend() const\012		{	// return iterator for end of reversed nonmutable sequence\012		return (const_reverse_iterator(begin()));\012		}\012\012 #if _HAS_CPP0X\012	const_iterator cbegin() const\012		{	// return iterator for beginning of nonmutable sequence\012		return (((const _Myt *)this)->begin());\012		}\012\012	const_iterator cend() const\012		{	// return iterator for end of nonmutable sequence\012		return (((const _Myt *)this)->end());\012		}\012\012	const_reverse_iterator crbegin() const\012		{	// return iterator for beginning of reversed nonmutable sequence\012		return (((const _Myt *)this)->rbegin());\012		}\012\012	const_reverse_iterator crend() const\012		{	// return iterator for ebd of reversed nonmutable sequence\012		return (((const _Myt *)this)->rend());\012		}\012\012	void shrink_to_fit()\012		{	// reduce capacity\012		if (size() < capacity())\012			{	// worth shrinking, do it\012			_Myt _Tmp(*this);\012			swap(_Tmp);\012			}\012		}\012 #endif /* _HAS_CPP0X */\012\012	reference at(size_type _Off)\012		{	// subscript mutable sequence with checking\012		if (this->_Mysize <= _Off)\012			_Xran();	// _Off off end\012		return (_Myptr()[_Off]);\012		}\012\012	const_reference at(size_type _Off) const\012		{	// subscript nonmutable sequence with checking\012		if (this->_Mysize <= _Off)\012			_Xran();	// _Off off end\012		return (_Myptr()[_Off]);\012		}\012\012	reference operator[](size_type _Off)\012		{	// subscript mutable sequence\012 #if _ITERATOR_DEBUG_LEVEL == 2\012\012		if (this->_Mysize <= _Off)\012\012			_DEBUG_ERROR(\"string subscript out of range\");\012\012 #elif _ITERATOR_DEBUG_LEVEL == 1\012		_SCL_SECURE_VALIDATE_RANGE(_Off < this->_Mysize);\012 #endif /* _ITERATOR_DEBUG_LEVEL == 2 */\012\012		return (_Myptr()[_Off]);\012		}\012\012	const_reference operator[](size_type _Off) const\012		{	// subscript nonmutable sequence\012 #if _ITERATOR_DEBUG_LEVEL == 2\012		if (this->_Mysize < _Off)	// sic\012			_DEBUG_ERROR(\"string subscript out of range\");\012\012 #elif _ITERATOR_DEBUG_LEVEL == 1\012		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic\012 #endif /* _ITERATOR_DEBUG_LEVEL == 2 */\012\012		return (_Myptr()[_Off]);\012		}\012\012	void push_back(_Elem _Ch)\012		{	// insert element at end\012		insert(end(), _Ch);\012		}\012\012 #if _HAS_CPP0X\012	void pop_back()\012		{	// erase element at end\012		erase(this->_Mysize - 1);	// throws if _Mysize == 0\012		}\012\012	reference front()\012		{	// return first element of mutable sequence\012		return (*begin());\012		}\012\012	const_reference front() const\012		{	// return first element of nonmutable sequence\012		return (*begin());\012		}\012\012	reference back()\012		{	// return last element of mutable sequence\012		return (*(end() - 1));\012		}\012\012	const_reference back() const\012		{	// return last element of nonmutable sequence\012		return (*(end() - 1));\012		}\012 #endif /* _HAS_CPP0X */\012\012	const _Elem *c_str() const\012		{	// return pointer to null-terminated nonmutable array\012		return (_Myptr());\012		}\012\012	const _Elem *data() const\012		{	// return pointer to nonmutable array\012		return (c_str());\012		}\012\012	size_type length() const\012		{	// return length of sequence\012		return (this->_Mysize);\012		}\012\012	size_type size() const\012		{	// return length of sequence\012		return (this->_Mysize);\012		}\012\012	size_type max_size() const\012		{	// return maximum possible length of sequence\012		size_type _Num = this->_Alval.max_size();\012		return (_Num <= 1 ? 1 : _Num - 1);\012		}\012\012	void resize(size_type _Newsize)\012		{	// determine new length, padding with null elements as needed\012		resize(_Newsize, _Elem());\012		}\012\012	void resize(size_type _Newsize, _Elem _Ch)\012		{	// determine new length, padding with _Ch elements as needed\012		if (_Newsize <= this->_Mysize)\012			erase(_Newsize);\012		else\012			append(_Newsize - this->_Mysize, _Ch);\012		}\012\012	size_type capacity() const\012		{	// return current length of allocated storage\012		return (this->_Myres);\012		}\012\012	void reserve(size_type _Newcap = 0)\012		{	// determine new minimum length of allocated storage\012		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)\012			{	// change reservation\012			size_type _Size = this->_Mysize;\012			if (_Grow(_Newcap, true))\012				_Eos(_Size);\012			}\012		}\012\012	bool empty() const\012		{	// test if sequence is empty\012		return (this->_Mysize == 0);\012		}\012\012	_SCL_INSECURE_DEPRECATE\012\012	size_type copy(_Elem *_Ptr,\012		size_type _Count, size_type _Off = 0) const\012		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)\012 #if _ITERATOR_DEBUG_LEVEL == 2\012		if (_Count != 0)\012			_DEBUG_POINTER(_Ptr);\012 #endif /* _ITERATOR_DEBUG_LEVEL == 2 */\012\012		if (this->_Mysize < _Off)\012			_Xran();	// _Off off end\012		if (this->_Mysize - _Off < _Count)\012			_Count = this->_Mysize - _Off;\012		_Traits::copy(_Ptr, _Myptr() + _Off, _Count);\012		return (_Count);\012		}\012\012	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,\012		size_type _Count, size_type _Off = 0) const\012		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)\012 #if _ITERATOR_DEBUG_LEVEL == 2\012		if (_Count != 0)\012			_DEBUG_POINTER(_Dest);\012 #endif /* _ITERATOR_DEBUG_LEVEL == 2 */\012\012		if (this->_Mysize < _Off)\012			_Xran();	// _Off off end\012		if (this->_Mysize - _Off < _Count)\012			_Count = this->_Mysize - _Off;\012		_Traits::_Copy_s(_Dest, _Dest_size, _Myptr() + _Off, _Count);\012		return (_Count);\012		}\012\012	void swap(_Myt& _Right)\012		{	// exchange contents with _Right\012		if (this == &_Right)\012			;	// same object, do nothing\012		else if (this->_Alval == _Right._Alval)\012			{	// same allocator, swap control information\012 #if 0 < _ITERATOR_DEBUG_LEVEL\012			this->_Swap_all(_Right);\012 #endif /* 0 < _ITERATOR_DEBUG_LEVEL */\012\012			_STD swap(this->_Bx, _Right._Bx);\012			_STD swap(this->_Mysize, _Right._Mysize);\012			_STD swap(this->_Myres, _Right._Myres);\012			}\012		else\012			{	// different allocator, do multiple assigns\012			_Myt _Tmp = *this;\012\012			*this = _Right;\012			_Right = _Tmp;\012			}\012		}\012\012	size_type find(const _Myt& _Right, size_type _Off = 0) const\012		{	// look for _Right beginnng at or after _Off\012		return (find(_Right._Myptr(), _Off, _Right.size()));\012		}\012\012	size_type find(const _Elem *_Ptr,\012		size_type _Off, size_type _Count) const\012		{	// look for [_Ptr, _Ptr + _Count) beginnng at or after _Off\012 #if _ITERATOR_DEBUG_LEVEL == 2\012		if (_Count != 0)\012			_DEBUG_POINTER(_Ptr);\012 #endif /* _ITERATOR_DEBUG_LEVEL == 2 */\012\012		if (_Count == 0 && _Off <= this->_Mysize)\012			return (_Off);	// null string always matches (if inside string)\012\012		size_type _Nm;\012		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))\012			{	// room for match, look for it\012			const _Elem *_Uptr, *_Vptr;\012			for (_Nm -= _Count - 1, _Vptr = _Myptr() + _Off;\012				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;\012				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)\012				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)\012					return (_Uptr - _Myptr());	// found a match\012			}\012\012		return (npos);	// no match\012		}\012\012	size_type find(const _Elem *_Ptr, size_type _Off = 0) const\012		{	// look for [_Ptr, <null>) beginnng at or after _Off\012		_DEBUG_POINTER(_Ptr);\012		return (find(_Ptr, _Off, _Traits::length(_Ptr)));\012		}\012\012	size_type find(_Elem _Ch, size_type _Off = 0) const\012		{	// look for _Ch at or after _Off\012		return (find((const _Elem *)&_Ch, _Off, 1));\012		}\012\012	size_type rfind(const _Myt& _Right, size_type _Off = npos) const\012		{	// look for _Right beginning before _Off\012		return (rfind(_Right._Myptr(), _Off, _Right.size()));\012		}\012\012	size_type rfind(const _Elem *_Ptr,\012		size_type _Off, size_type _Count) const\012		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off\012 #if _ITERATOR_DEBUG_LEVEL == 2\012		if (_Count != 0)\012			_DEBUG_POINTER(_Ptr);\012 #endif /* _ITERATOR_DEBUG_LEVEL == 2 */\012\012		if (_Count == 0)\012			return (_Off < this->_Mysize ? _Off\012				: this->_Mysize);	// null always matches\012		if (_Count <= this->_Mysize)\012			{	// room for match, look for it\012			const _Elem *_Uptr = _Myptr() +\012				(_Off < this->_Mysize - _Count ? _Off\012					: this->_Mysize - _Count);\012			for (; ; --_Uptr)\012				if (_Traits::eq(*_Uptr, *_Ptr)\012					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)\012					return (_Uptr - _Myptr());	// found a match\012				else if (_Uptr == _Myptr())\012					break;	// at beginning, no more chance for match\012			}\012\012		return (npos);	// no match\012		}\012\012	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const\012		{	// look for [_Ptr, <null>) beginning before _Off\012		_DEBUG_POINTER(_Ptr);\012		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));\012		}\012\012	size_type rfind(_Elem _Ch, size_type _Off = npos) const\012		{	// look for _Ch before _Off\012		return (rfind((const _Elem *)&_Ch, _Off, 1));\012		}\012\012	size_type find_first_of(const _Myt& _Right,\012		size_type _Off = 0) const\012		{	// look for one of _Right at or after _Off\012		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));\012		}\012\012	size_type find_first_of(const _Elem *_Ptr,\012		size_type _Off, size_type _Count) const\012		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off\012 #if _ITERATOR_DEBUG_LEVEL == 2\012		if (_Count != 0)\012			_DEBUG_POINTER(_Ptr);\012 #endif /* _ITERATOR_DEBUG_LEVEL == 2 */\012\012		if (0 < _Count && _Off < this->_Mysize)\012			{	// room for match, look for it\012			const _Elem *const _Vptr = _Myptr() + this->_Mysize;\012			for (const _Elem *_Uptr = _Myptr() + _Off; _Uptr < _Vptr; ++_Uptr)\012				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)\012					return (_Uptr - _Myptr());	// found a match\012			}\012\012		return (npos);	// no match\012		}\012\012	size_type find_first_of(const _Elem *_Ptr, size_type _Off = 0) const\012		{	// look for one of [_Ptr, <null>) at or after _Off\012		_DEBUG_POINTER(_Ptr);\012		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));\012		}\012\012	size_type find_first_of(_Elem _Ch, size_type _Off = 0) const\012		{	// look for _Ch at or after _Off\012		return (find((const _Elem *)&_Ch, _Off, 1));\012		}\012\012	size_type find_last_of(const _Myt& _Right,\012		size_type _Off = npos) const\012		{	// look for one of _Right before _Off\012		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));\012		}\012\012	size_type find_last_of(const _Elem *_Ptr,\012		size_type _Off, size_type _Count) const\012		{	// look for one of [_Ptr, _Ptr + _Count) before _Off\012 #if _ITERATOR_DEBUG_LEVEL == 2\012		if (_Count != 0)\012			_DEBUG_POINTER(_Ptr);\012 #endif /* _ITERATOR_DEBUG_LEVEL == 2 */\012\012		if (0 < _Count && 0 < this->_Mysize)\012			{	// worth searching, do it\012			const _Elem *_Uptr = _Myptr()\012				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);\012			for (; ; --_Uptr)\012				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)\012					return (_Uptr - _Myptr());	// found a match\012				else if (_Uptr == _Myptr())\012					break;	// at beginning, no more chance for match\012			}\012\012		return (npos);	// no match\012		}\012\012	size_type find_last_of(const _Elem *_Ptr,\012		size_type _Off = npos) const\012		{	// look for one of [_Ptr, <null>) before _Off\012		_DEBUG_POINTER(_Ptr);\012		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));\012		}\012\012	size_type find_last_of(_Elem _Ch, size_type _Off = npos) const\012		{	// look for _Ch before _Off\012		return (rfind((const _Elem *)&_Ch, _Off, 1));\012		}\012\012	size_type find_first_not_of(const _Myt& _Right,\012		size_type _Off = 0) const\012		{	// look for none of _Right at or after _Off\012		return (find_first_not_of(_Right._Myptr(), _Off,\012			_Right.size()));\012		}\012\012	size_type find_first_not_of(const _Elem *_Ptr,\012		size_type _Off, size_type _Count) const\012		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off\012 #if _ITERATOR_DEBUG_LEVEL == 2\012		if (_Count != 0)\012			_DEBUG_POINTER(_Ptr);\012 #endif /* _ITERATOR_DEBUG_LEVEL == 2 */\012\012		if (_Off < this->_Mysize)\012			{	// room for match, look for it\012			const _Elem *const _Vptr = _Myptr() + this->_Mysize;\012			for (const _Elem *_Uptr = _Myptr() + _Off; _Uptr < _Vptr; ++_Uptr)\012				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)\012					return (_Uptr - _Myptr());\012			}\012		return (npos);\012		}\012\012	size_type find_first_not_of(const _Elem *_Ptr,\012		size_type _Off = 0) const\012		{	// look for one of [_Ptr, <null>) at or after _Off\012		_DEBUG_POINTER(_Ptr);\012		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));\012		}\012\012	size_type find_first_not_of(_Elem _Ch, size_type _Off = 0) const\012		{	// look for non _Ch at or after _Off\012		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));\012		}\012\012	size_type find_last_not_of(const _Myt& _Right,\012		size_type _Off = npos) const\012		{	// look for none of _Right before _Off\012		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));\012		}\012\012	size_type find_last_not_of(const _Elem *_Ptr,\012		size_type _Off, size_type _Count) const\012		{	// look for none of [_Ptr, _Ptr + _Count) before _Off\012 #if _ITERATOR_DEBUG_LEVEL == 2\012		if (_Count != 0)\012			_DEBUG_POINTER(_Ptr);\012 #endif /* _ITERATOR_DEBUG_LEVEL == 2 */\012\012		if (0 < this->_Mysize)\012			{	// worth searching, do it\012			const _Elem *_Uptr = _Myptr()\012				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);\012			for (; ; --_Uptr)\012				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)\012					return (_Uptr - _Myptr());\012				else if (_Uptr == _Myptr())\012					break;\012			}\012		return (npos);\012		}\012\012	size_type find_last_not_of(const _Elem *_Ptr,\012		size_type _Off = npos) const\012		{	// look for none of [_Ptr, <null>) before _Off\012		_DEBUG_POINTER(_Ptr);\012		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));\012		}\012\012	size_type find_last_not_of(_Elem _Ch, size_type _Off = npos) const\012		{	// look for non _Ch before _Off\012		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));\012		}\012\012	_Myt substr(size_type _Off = 0, size_type _Count = npos) const\012		{	// return [_Off, _Off + _Count) as new string\012		return (_Myt(*this, _Off, _Count, get_allocator()));\012		}\012\012	int compare(const _Myt& _Right) const\012		{	// compare [0, _Mysize) with _Right\012		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));\012		}\012\012	int compare(size_type _Off, size_type _N0,\012		const _Myt& _Right) const\012		{	// compare [_Off, _Off + _N0) with _Right\012		return (compare(_Off, _N0, _Right, 0, npos));\012		}\012\012	int compare(size_type _Off,\012		size_type _N0, const _Myt& _Right,\012		size_type _Roff, size_type _Count) const\012		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)\012		if (_Right.size() < _Roff)\012			_Xran();	// _Off off end\012		if (_Right._Mysize - _Roff < _Count)\012			_Count = _Right._Mysize - _Roff;	// trim _Count to size\012		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));\012		}\012\012	int compare(const _Elem *_Ptr) const\012		{	// compare [0, _Mysize) with [_Ptr, <null>)\012		_DEBUG_POINTER(_Ptr);\012		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));\012		}\012\012	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const\012		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)\012		_DEBUG_POINTER(_Ptr);\012		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));\012		}\012\012	int compare(size_type _Off,\012		size_type _N0, const _Elem *_Ptr, size_type _Count) const\012		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)\012 #if _ITERATOR_DEBUG_LEVEL == 2\012		if (_Count != 0)\012			_DEBUG_POINTER(_Ptr);\012 #endif /* _ITERATOR_DEBUG_LEVEL == 2 */\012\012		if (this->_Mysize < _Off)\012			_Xran();	// _Off off end\012		if (this->_Mysize - _Off < _N0)\012			_N0 = this->_Mysize - _Off;	// trim _N0 to size\012\012		size_type _Ans = _Traits::compare(_Myptr() + _Off, _Ptr,\012			_N0 < _Count ? _N0 : _Count);\012		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1\012			: _N0 == _Count ? 0 : +1);\012		}\012\012	allocator_type get_allocator() const\012		{	// return allocator object for values\012		return (this->_Alval);\012		}\012\012	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)\012		{	// assign _Count copies of _Ch beginning at _Off\012		if (_Count == 1)\012			_Traits::assign(*(_Myptr() + _Off), _Ch);\012		else\012			_Traits::assign(_Myptr() + _Off, _Count, _Ch);\012		}\012\012	void _Copy(size_type _Newsize, size_type _Oldlen)\012		{	// copy _Oldlen elements to newly allocated buffer\012		size_type _Newres = _Newsize | this->_ALLOC_MASK;\012		if (max_size() < _Newres)\012			_Newres = _Newsize;	// undo roundup if too big\012		else if (this->_Myres / 2 <= _Newres / 3)\012			;\012		else if (this->_Myres <= max_size() - this->_Myres / 2)\012			_Newres = this->_Myres\012				+ this->_Myres / 2;	// grow exponentially if possible\012		else\012			_Newres = max_size();	// settle for max_size()\012\012		_Elem *_Ptr;\012		_TRY_BEGIN\012			_Ptr = this->_Alval.allocate(_Newres + 1);\012		_CATCH_ALL\012			_Newres = _Newsize;	// allocation failed, undo roundup and retry\012			_TRY_BEGIN\012				_Ptr = this->_Alval.allocate(_Newres + 1);\012			_CATCH_ALL\012			_Tidy(true);	// failed again, discard storage and reraise\012			_RERAISE;\012			_CATCH_END\012		_CATCH_END\012\012		if (0 < _Oldlen)\012			_Traits::copy(_Ptr, _Myptr(), _Oldlen);	// copy existing elements\012		_Tidy(true);\012		this->_Bx._Ptr = _Ptr;\012		this->_Myres = _Newres;\012		_Eos(_Oldlen);\012		}\012\012	void _Eos(size_type _Newsize)\012		{	// set new length and null terminator\012		_Traits::assign(_Myptr()[this->_Mysize = _Newsize], _Elem());\012		}\012\012	bool _Grow(size_type _Newsize,\012		bool _Trim = false)\012		{	// ensure buffer is big enough, trim to size if _Trim is true\012		if (max_size() < _Newsize)\012			_Xlen();	// result too long\012		if (this->_Myres < _Newsize)\012			_Copy(_Newsize, this->_Mysize);	// reallocate to grow\012		else if (_Trim && _Newsize < this->_BUF_SIZE)\012			_Tidy(true,	// copy and deallocate if trimming to small string\012				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);\012		else if (_Newsize == 0)\012			_Eos(0);	// new size is zero, just null terminate\012		return (0 < _Newsize);	// return true only if more work to do\012		}\012\012	bool _Inside(const _Elem *_Ptr)\012		{	// test if _Ptr points inside string\012		if (_Ptr == 0 || _Ptr < _Myptr() || _Myptr() + this->_Mysize <= _Ptr)\012			return (false);	// don't ask\012		else\012			return (true);\012		}\012\012	static size_type _Pdif(const_iterator _P2,\012		const_iterator _P1)\012		{	// compute safe iterator difference\012		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);\012		}\012\012	void _Tidy(bool _Built = false,\012		size_type _Newsize = 0)\012		{	// initialize buffer, deallocating any storage\012		if (!_Built)\012			;\012		else if (this->_BUF_SIZE <= this->_Myres)\012			{	// copy any leftovers to small buffer and deallocate\012			_Elem *_Ptr = this->_Bx._Ptr;\012			if (0 < _Newsize)\012				_Traits::copy(this->_Bx._Buf, _Ptr, _Newsize);\012			this->_Alval.deallocate(_Ptr, this->_Myres + 1);\012			}\012		this->_Myres = this->_BUF_SIZE - 1;\012		_Eos(_Newsize);\012		}\012\012	_Elem *_Myptr()\012		{	// determine current pointer to buffer for mutable string\012		return (this->_BUF_SIZE <= this->_Myres ? this->_Bx._Ptr\012			: this->_Bx._Buf);\012		}\012\012	const _Elem *_Myptr() const\012		{	// determine current pointer to buffer for nonmutable string\012		return (this->_BUF_SIZE <= this->_Myres ? this->_Bx._Ptr\012			: this->_Bx._Buf);\012		}\012\012	__declspec(noreturn) void _Xlen() const\012		{	// report a length_error\012		_Xlength_error(\"string too long\");\012		}\012\012	__declspec(noreturn) void _Xran() const\012		{	// report an out_of_range error\012		_Xout_of_range(\"invalid string position\");\012		}\012	};\012\012		// STATIC npos OBJECT\012template<class _Elem,\012	class _Traits,\012	class _Alloc>\012	_PGLOBAL const typename basic_string<_Elem, _Traits, _Alloc>::size_type\012		basic_string<_Elem, _Traits, _Alloc>::npos =\012			(typename basic_string<_Elem, _Traits, _Alloc>::size_type)(-1);\012\012		// basic_string TEMPLATE OPERATORS\012\012template<class _Elem,\012	class _Traits,\012	class _Alloc> inline\012	void swap(basic_string<_Elem, _Traits, _Alloc>& _Left,\012		basic_string<_Elem, _Traits, _Alloc>& _Right)\012	{	// swap _Left and _Right strings\012	_Left.swap(_Right);\012	}\012\012template<class _Elem,\012	class _Traits,\012	class _Alloc> inline\012	void swap(basic_string<_Elem, _Traits, _Alloc>& _Left,\012		basic_string<_Elem, _Traits, _Alloc>&& _Right)\012	{	// swap _Left and _Right strings\012	_Left.swap(_Right);\012	}\012\012template<class _Elem,\012	class _Traits,\012	class _Alloc> inline\012	void swap(basic_string<_Elem, _Traits, _Alloc>&& _Left,\012		basic_string<_Elem, _Traits, _Alloc>& _Right)\012	{	// swap _Left and _Right strings\012	_Right.swap(_Left);\012	}\012\012typedef basic_string<char, char_traits<char>, allocator<char> >\012	string;\012typedef basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >\012	wstring;\012\012 #if _HAS_CPP0X\012typedef basic_string<char16_t, char_traits<char16_t>, allocator<char16_t> >\012	u16string;\012typedef basic_string<char32_t, char_traits<char32_t>, allocator<char32_t> >\012	u32string;\012 #endif /* _HAS_CPP0X */\012_STD_END\012\012 #pragma warning(pop)\012 #pragma pack(pop)\012\012#endif /* RC_INVOKED */\012#endif /* _XSTRING */\012\012/*\012 * Copyright (c) 1992-2009 by P.J. Plauger.  ALL RIGHTS RESERVED.\012 * Consult your license regarding permissions and restrictions.\012V5.20:0009 */\012"}, {"path":"C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/xutility", "name":"xutility", "has_active_debug_locs":true, "absName":"c:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/include/xutility", "content":"// xutility internal header\012#pragma once\012#ifndef _XUTILITY_\012#define _XUTILITY_\012#ifndef RC_INVOKED\012#include <climits>\012#include <cstdlib>\012#include <utility>\012\012 #pragma pack(push,_CRT_PACKING)\012 #pragma warning(push,3)\012\012_STD_BEGIN\012		// MACRO DEBUG_ERROR\012\012 #if _ITERATOR_DEBUG_LEVEL == 2\012\012  #define _DEBUG_ERROR(mesg)	\\\012	_DEBUG_ERROR2(mesg, __FILEW__, __LINE__)\012  #define _DEBUG_ERROR2(mesg, file, line)	\\\012	_Debug_message(L ## mesg, file, line)\012\012typedef const wchar_t *_Dbfile_t;\012typedef unsigned int _Dbline_t;\012\012_CRTIMP2_PURE void __CLRCALL_PURE_OR_CDECL _Debug_message(const wchar_t *,\012	const wchar_t *, unsigned int);\012\012 #else /* _ITERATOR_DEBUG_LEVEL == 2 */\012  #define _DEBUG_ERROR(mesg)\012 #endif /* _ITERATOR_DEBUG_LEVEL == 2 */\012\012		// CLASSES _Container_base*, _Iterator_base*\012struct _CRTIMP2_PURE _Container_base0\012	{	// base of all containers\012	void _Orphan_all()\012		{	// orphan all iterators\012		}\012\012	void _Swap_all(_Container_base0&)\012		{	// swap all iterators\012		}\012	};\012\012struct _Iterator_base0\012	{	// base of all iterators\012	void _Adopt(const void *)\012		{	// adopt this iterator by parent\012		}\012\012	const _Container_base0 *_Getcont() const\012		{	// get owning container\012		return (0);\012		}\012	};\012\012struct _Container_base12;\012struct _Iterator_base12;\012\012		// CLASS _Container_proxy\012struct _Container_proxy\012	{	// store head of iterator chain and back pointer\012	_Container_proxy()\012		: _Mycont(0), _Myfirstiter(0)\012		{	// construct from pointers\012		}\012\012	const _Container_base12 *_Mycont;\012	_Iterator_base12 *_Myfirstiter;\012	};\012\012struct _CRTIMP2_PURE _Container_base12\012	{	// store pointer to _Container_proxy\012public:\012	_Container_base12()\012		: _Myproxy(0)\012		{	// construct childless container\012		}\012\012	_Container_base12(const _Container_base12&)\012		: _Myproxy(0)\012		{	// copy a container\012		}\012\012	_Container_base12& operator=(const _Container_base12&)\012		{	// assign a container\012		return (*this);\012		}\012\012	~_Container_base12()\012		{	// destroy the container\012		_Orphan_all();\012		}\012\012	_Iterator_base12 **_Getpfirst() const\012		{	// get address of iterator chain\012		return (_Myproxy == 0 ? 0 : &_Myproxy->_Myfirstiter);\012		}\012\012	void _Orphan_all();	// orphan all iterators\012	void _Swap_all(_Container_base12&);	// swap all iterators\012\012	_Container_proxy *_Myproxy;\012	};\012\012struct _Iterator_base12\012	{	// store links to container proxy, next iterator\012public:\012	_Iterator_base12()\012		: _Myproxy(0), _Mynextiter(0)\012		{	// construct orphaned iterator\012		}\012\012	_Iterator_base12(const _Iterator_base12& _Right)\012		: _Myproxy(0), _Mynextiter(0)\012		{	// copy an iterator\012		*this = _Right;\012		}\012\012	_Iterator_base12& operator=(const _Iterator_base12& _Right)\012		{	// assign an iterator\012		if (_Myproxy != _Right._Myproxy)\012			_Adopt(_Right._Myproxy->_Mycont);\012		return (*this);\012		}\012\012	~_Iterator_base12()\012		{	// destroy the iterator\012 #if _ITERATOR_DEBUG_LEVEL == 2\012		_Lockit _Lock(_LOCK_DEBUG);\012		_Orphan_me();\012 #endif /* _ITERATOR_DEBUG_LEVEL == 2 */\012		}\012\012	void _Adopt(const _Container_base12 *_Parent)\012		{	// adopt this iterator by parent\012		if (_Parent != 0)\012			{	// have a parent, do adoption\012			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;\012\012 #if _ITERATOR_DEBUG_LEVEL == 2\012			if (_Myproxy != _Parent_proxy)\012				{	// change parentage\012				_Lockit _Lock(_LOCK_DEBUG);\012				_Orphan_me();\012				_Mynextiter = _Parent_proxy->_Myfirstiter;\012				_Parent_proxy->_Myfirstiter = this;\012				_Myproxy = _Parent_proxy;\012				}\012 #else /* _ITERATOR_DEBUG_LEVEL == 2 */\012			_Myproxy = _Parent_proxy;\012 #endif /* _ITERATOR_DEBUG_LEVEL == 2 */\012			}\012		}\012\012	void _Clrcont()\012		{	// disown owning container\012		_Myproxy = 0;\012		}\012\012	const _Container_base12 *_Getcont() const\012		{	// get owning container\012		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);\012		}\012\012	_Iterator_base12 **_Getpnext()\012		{	// get address of remaining iterator chain\012		return (&_Mynextiter);\012		}\012\012	void _Orphan_me()\012		{	// cut ties with parent\012 #if _ITERATOR_DEBUG_LEVEL == 2\012		if (_Myproxy != 0)\012			{	// adopted, remove self from list\012			_Iterator_base12 **_Pnext = &_Myproxy->_Myfirstiter;\012			while (*_Pnext != 0 && *_Pnext != this)\012				_Pnext = &(*_Pnext)->_Mynextiter;\012\012			if (*_Pnext == 0)\012				_DEBUG_ERROR(\"ITERATOR LIST CORRUPTED!\");\012			*_Pnext = _Mynextiter;\012			_Myproxy = 0;\012			}\012 #endif /* _ITERATOR_DEBUG_LEVEL == 2 */\012		}\012\012	_Container_proxy *_Myproxy;\012	_Iterator_base12 *_Mynextiter;\012	};\012\012		// MEMBER FUNCTIONS FOR _Container_base12\012inline void _Container_base12::_Orphan_all()\012	{	// orphan all iterators\012 #if _ITERATOR_DEBUG_LEVEL == 2\012	if (_Myproxy != 0)\012		{	// proxy allocated, drain it\012		_Lockit _Lock(_LOCK_DEBUG);\012\012		for (_Iterator_base12 **_Pnext = &_Myproxy->_Myfirstiter;\012			*_Pnext != 0; *_Pnext = (*_Pnext)->_Mynextiter)\012			(*_Pnext)->_Myproxy = 0;\012		_Myproxy->_Myfirstiter = 0;\012		}\012 #endif /* _ITERATOR_DEBUG_LEVEL == 2 */\012	}\012\012inline void _Container_base12::_Swap_all(_Container_base12& _Right)\012	{	// swap all iterators\012 #if _ITERATOR_DEBUG_LEVEL == 2\012	_Lockit _Lock(_LOCK_DEBUG);\012 #endif /* _ITERATOR_DEBUG_LEVEL == 2 */\012\012	_Container_proxy *_Temp = _Myproxy;\012	_Myproxy = _Right._Myproxy;\012	_Right._Myproxy = _Temp;\012\012	if (_Myproxy != 0)\012		_Myproxy->_Mycont = (_Container_base12 *)this;\012	if (_Right._Myproxy != 0)\012		_Right._Myproxy->_Mycont = (_Container_base12 *)&_Right;\012	}\012\012 #if _ITERATOR_DEBUG_LEVEL == 0\012typedef _Container_base0 _Container_base;\012typedef _Iterator_base0 _Iterator_base;\012 #else /* _ITERATOR_DEBUG_LEVEL == 0 */\012typedef _Container_base12 _Container_base;\012typedef _Iterator_base12 _Iterator_base;\012 #endif /* _ITERATOR_DEBUG_LEVEL == 0 */\012\012		// TEMPLATE FUNCTION _Has_unchecked_type AND FRIENDS\012\012 #define _UNCHECKED_TYPE(_Iter) \\\012	typename _Get_unchecked_type<_Iter>::type\012\012_STD tr1::_No _Has_unchecked_type(...);\012\012template<class _Ty>\012	_STD tr1::_Yes _Has_unchecked_type(_Ty *,\012		typename _Ty::_Unchecked_type * = 0);\012\012template<class _Iter,\012	bool>\012	struct _Unchecked_helper\012	{	// _Iter doesn't define _Unchecked_type\012	typedef _Iter type;\012	};\012\012template<class _Iter>\012	struct _Unchecked_helper<_Iter, true>\012	{	// _Iter defines _Unchecked_type\012	typedef typename _Iter::_Unchecked_type type;\012	};\012\012template<class _Iter>\012	struct _Get_unchecked_type\012	{	// wraps unchecked type\012	typedef typename _Unchecked_helper<_Iter,\012		_IS_YES(_Has_unchecked_type((_Iter *)0))>::type type;\012	};\012\012		// TEMPLATE FUNCTION _Unchecked\012template<class _Iter> inline\012	_Iter _Unchecked(_Iter _Src)\012	{	// construct unchecked from checked, generic\012	return (_Src);\012	}\012\012		// TEMPLATE FUNCTION _Rechecked\012template<class _Iter,\012	class _UIter> inline\012	_Iter& _Rechecked(_Iter& _Dest, _UIter _Src)\012	{	// reset checked from unchecked, generic\012	_Dest = _Src;\012	return (_Dest);\012	}\012\012		// TEMPLATE STRUCT _Is_checked_helper\012template<class _Iter>\012	struct _Is_checked_helper\012	: public _STD tr1::integral_constant<bool, _IS_YES(_Has_unchecked_type((_Iter *)0))>\012	{	// determine whether _Iter is checked\012	};\012\012		// TEMPLATE FUNCTION _Is_checked\012template<class _Iter> inline\012	_Is_checked_helper<_Iter> _Is_checked(_Iter)\012	{	// return type is derived from true_type if iterator is checked\012	return (_Is_checked_helper<_Iter>());\012	}\012\012		//	ITERATOR STUFF (from <iterator>)\012		// ITERATOR TAGS\012struct input_iterator_tag\012	{	// identifying tag for input iterators\012	};\012\012struct output_iterator_tag\012	{	// identifying tag for output iterators\012	};\012\012struct forward_iterator_tag\012	: public input_iterator_tag, output_iterator_tag\012	{	// identifying tag for forward iterators\012	};\012\012struct bidirectional_iterator_tag\012	: public forward_iterator_tag\012	{	// identifying tag for bidirectional iterators\012	};\012\012struct random_access_iterator_tag\012	: public bidirectional_iterator_tag\012	{	// identifying tag for random-access iterators\012	};\012\012struct _Int_iterator_tag\012	{	// identifying tag for integer types, not an iterator\012	};\012\012		// POINTER ITERATOR TAGS\012struct _Nonscalar_ptr_iterator_tag\012	{	// pointer to unknown type\012	};\012struct _Scalar_ptr_iterator_tag\012	{	// pointer to scalar type\012	};\012\012		// TEMPLATE CLASS iterator\012template<class _Category,\012	class _Ty,\012	class _Diff = ptrdiff_t,\012	class _Pointer = _Ty *,\012	class _Reference = _Ty&>\012	struct iterator\012	{	// base type for all iterator classes\012	typedef _Category iterator_category;\012	typedef _Ty value_type;\012	typedef _Diff difference_type;\012	typedef _Diff distance_type;	// retained\012	typedef _Pointer pointer;\012	typedef _Reference reference;\012	};\012\012template<class _Category,\012	class _Ty,\012	class _Diff,\012	class _Pointer,\012	class _Reference,\012	class _Base>\012	struct _Iterator012\012		: public _Base\012	{\012	typedef _Category iterator_category;\012	typedef _Ty value_type;\012	typedef _Diff difference_type;\012	typedef _Diff distance_type;	// retained\012	typedef _Pointer pointer;\012	typedef _Reference reference;\012	};\012\012struct _Outit\012	: public iterator<output_iterator_tag, void, void,\012		void, void>\012	{	// base for output iterators\012	};\012\012		// TEMPLATE CLASS iterator_traits\012template<class _Iter>\012	struct iterator_traits\012	{	// get traits from iterator _Iter\012	typedef typename _Iter::iterator_category iterator_category;\012	typedef typename _Iter::value_type value_type;\012	typedef typename _Iter::difference_type difference_type;\012	typedef difference_type distance_type;	// retained\012	typedef typename _Iter::pointer pointer;\012	typedef typename _Iter::reference reference;\012	};\012\012template<class _Ty>\012	struct iterator_traits<_Ty *>\012	{	// get traits from pointer\012	typedef random_access_iterator_tag iterator_category;\012	typedef _Ty value_type;\012	typedef ptrdiff_t difference_type;\012	typedef ptrdiff_t distance_type;	// retained\012	typedef _Ty *pointer;\012	typedef _Ty& reference;\012	};\012\012template<class _Ty>\012	struct iterator_traits<const _Ty *>\012	{	// get traits from const pointer\012	typedef random_access_iterator_tag iterator_category;\012	typedef _Ty value_type;\012	typedef ptrdiff_t difference_type;\012	typedef ptrdiff_t distance_type;	// retained\012	typedef const _Ty *pointer;\012	typedef const _Ty& reference;\012	};\012\012template<> struct iterator_traits<_Bool>\012	{	// get traits from integer type\012	typedef _Int_iterator_tag iterator_category;\012	};\012\012template<> struct iterator_traits<char>\012	{	// get traits from integer type\012	typedef _Int_iterator_tag iterator_category;\012	};\012\012template<> struct iterator_traits<signed char>\012	{	// get traits from integer type\012	typedef _Int_iterator_tag iterator_category;\012	};\012\012template<> struct iterator_traits<unsigned char>\012	{	// get traits from integer type\012	typedef _Int_iterator_tag iterator_category;\012	};\012\012 #ifdef _NATIVE_WCHAR_T_DEFINED\012template<> struct iterator_traits<wchar_t>\012	{	// get traits from integer type\012	typedef _Int_iterator_tag iterator_category;\012	};\012 #endif /* _NATIVE_WCHAR_T_DEFINED */\012\012template<> struct iterator_traits<short>\012	{	// get traits from integer type\012	typedef _Int_iterator_tag iterator_category;\012	};\012\012template<> struct iterator_traits<unsigned short>\012	{	// get traits from integer type\012	typedef _Int_iterator_tag iterator_category;\012	};\012\012template<> struct iterator_traits<int>\012	{	// get traits from integer type\012	typedef _Int_iterator_tag iterator_category;\012	};\012\012template<> struct iterator_traits<unsigned int>\012	{	// get traits from integer type\012	typedef _Int_iterator_tag iterator_category;\012	};\012\012template<> struct iterator_traits<long>\012	{	// get traits from integer type\012	typedef _Int_iterator_tag iterator_category;\012	};\012\012template<> struct iterator_traits<unsigned long>\012	{	// get traits from integer type\012	typedef _Int_iterator_tag iterator_category;\012	};\012\012 #ifdef _LONGLONG\012template<> struct iterator_traits<_LONGLONG>\012	{	// get traits from integer type\012	typedef _Int_iterator_tag iterator_category;\012	};\012\012template<> struct iterator_traits<_ULONGLONG>\012	{	// get traits from integer type\012	typedef _Int_iterator_tag iterator_category;\012	};\012 #endif /* _LONGLONG */\012\012		// TEMPLATE FUNCTION _Iter_cat\012template<class _Iter> inline\012	typename iterator_traits<_Iter>::iterator_category\012		_Iter_cat(const _Iter&)\012	{	// return category from iterator argument\012	typename iterator_traits<_Iter>::iterator_category _Cat;\012	return (_Cat);\012	}\012\012		// TEMPLATE FUNCTION _Ptr_cat\012template<class _Iter1,\012	class _Iter2> inline\012	_Nonscalar_ptr_iterator_tag _Ptr_cat(_Iter1&, _Iter2&)\012	{	// return pointer category from arbitrary arguments\012	_Nonscalar_ptr_iterator_tag _Cat;\012	return (_Cat);\012	}\012\012template<class _Elem1,\012	class _Elem2>\012	struct _Ptr_cat_helper\012	{	// determines pointer category, nonscalar by default\012	typedef _Nonscalar_ptr_iterator_tag _Type;\012	};\012\012template<class _Elem>\012	struct _Ptr_cat_helper<_Elem, _Elem>\012	{	// determines pointer category, common type\012	typedef typename _STD tr1::conditional<\012		_STD tr1::is_scalar<_Elem>::value,\012			_Scalar_ptr_iterator_tag,\012			_Nonscalar_ptr_iterator_tag>::type _Type;\012	};\012\012template<class _Anything>\012	struct _Ptr_cat_helper<_Anything *, const _Anything *>\012	{	// determines pointer category\012	typedef _Scalar_ptr_iterator_tag _Type;\012	};\012\012template<class _Elem1,\012	class _Elem2> inline\012	typename _Ptr_cat_helper<_Elem1, _Elem2>::_Type\012		_Ptr_cat(_Elem1 *, _Elem2 *)\012	{	// return pointer category from pointers\012	typename _Ptr_cat_helper<_Elem1, _Elem2>::_Type _Cat;\012	return (_Cat);\012	}\012\012template<class _Elem1,\012	class _Elem2> inline\012	typename _Ptr_cat_helper<_Elem1, _Elem2>::_Type\012		_Ptr_cat(const _Elem1 *, _Elem2 *)\012	{	// return pointer category from pointers\012	typename _Ptr_cat_helper<_Elem1, _Elem2>::_Type _Cat;\012	return (_Cat);\012	}\012\012		// DEBUG TESTING MACROS\012\012 #if _ITERATOR_DEBUG_LEVEL < 2\012  #define _DEBUG_LT(x, y)	((x) < (y))\012  #define _DEBUG_LT_PRED(pred, x, y)	pred(x, y)\012  #define _DEBUG_ORDER(first, last)\012  #define _DEBUG_ORDER_PRED(first, last, pred)\012  #define _DEBUG_POINTER(first)\012  #define _DEBUG_POINTER2(first, file, line)\012  #define _DEBUG_RANGE(first, last)\012  #define _DEBUG_RANGE2(first, last, file, line)\012\012 #else /* _ITERATOR_DEBUG_LEVEL < 2 */\012\012  #define _FILENAME	__FILEW__\012\012  #ifndef _DEBUG_LT_IMPL\012   #define _DEBUG_LT_IMPL	_Debug_lt\012  #endif /* _DEBUG_LT_IMPL */\012\012  #define _DEBUG_LT(x, y) \\\012	_DEBUG_LT_IMPL(x, y, _FILENAME, __LINE__)\012\012  #ifndef _DEBUG_LT_PRED_IMPL\012   #define _DEBUG_LT_PRED_IMPL	_Debug_lt_pred\012  #endif /* _DEBUG_LT_PRED_IMPL */\012\012  #define _DEBUG_LT_PRED(pred, x, y)	\\\012	_DEBUG_LT_PRED_IMPL(pred, x, y, _FILENAME, __LINE__)\012\012  #ifndef _DEBUG_ORDER_IMPL\012   #define _DEBUG_ORDER_IMPL	_Debug_order\012  #endif /* _DEBUG_ORDER_IMPL */\012\012  #define _DEBUG_ORDER(first, last)	\\\012	_DEBUG_ORDER_IMPL(first, last, _FILENAME, __LINE__)\012  #define _DEBUG_ORDER_PRED(first, last, pred)	\\\012	_DEBUG_ORDER_IMPL(first, last, pred, _FILENAME, __LINE__)\012\012  #ifndef _DEBUG_POINTER_IMPL\012   #define _DEBUG_POINTER_IMPL	_Debug_pointer\012  #endif /* _DEBUG_POINTER_IMPL */\012\012  #define _DEBUG_POINTER(first)	\\\012	_DEBUG_POINTER_IMPL(first, _FILENAME, __LINE__)\012  #define _DEBUG_POINTER2(first, file, line)	\\\012	_DEBUG_POINTER_IMPL(first, file, line)\012\012  #ifndef _DEBUG_RANGE_IMPL\012   #define _DEBUG_RANGE_IMPL	_Debug_range\012  #endif /* _DEBUG_RANGE_IMPL */\012\012  #define _DEBUG_RANGE(first, last)	\\\012	_DEBUG_RANGE_IMPL(first, last, _FILENAME, __LINE__)\012  #define _DEBUG_RANGE2(first, last, file, line)	\\\012	_DEBUG_RANGE_IMPL(first, last, file, line)\012\012		// TEMPLATE FUNCTION _Debug_lt\012template<class _Ty1, class _Ty2> inline\012	bool _Debug_lt(const _Ty1& _Left, const _Ty2& _Right,\012		_Dbfile_t _File, _Dbline_t _Line)\012	{	// test if _Left < _Right and operator< is strict weak ordering\012	if (!(_Left < _Right))\012		return (false);\012	else if (_Right < _Left)\012		_DEBUG_ERROR2(\"invalid operator<\", _File, _Line);\012	return (true);\012	}\012\012template<class _Ty1, class _Ty2> inline\012	bool _Debug_lt(const _Ty1& _Left, _Ty2& _Right,\012		_Dbfile_t _File, _Dbline_t _Line)\012	{	// test if _Left < _Right and operator< is strict weak ordering\012	if (!(_Left < _Right))\012		return (false);\012	else if (_Right < _Left)\012		_DEBUG_ERROR2(\"invalid operator<\", _File, _Line);\012	return (true);\012	}\012\012template<class _Ty1, class _Ty2> inline\012	bool _Debug_lt(_Ty1& _Left, const _Ty2& _Right,\012		_Dbfile_t _File, _Dbline_t _Line)\012	{	// test if _Left < _Right and operator< is strict weak ordering\012	if (!(_Left < _Right))\012		return (false);\012	else if (_Right < _Left)\012		_DEBUG_ERROR2(\"invalid operator<\", _File, _Line);\012	return (true);\012	}\012\012template<class _Ty1, class _Ty2> inline\012	bool _Debug_lt(_Ty1& _Left, _Ty2& _Right,\012		_Dbfile_t _File, _Dbline_t _Line)\012	{	// test if _Left < _Right and operator< is strict weak ordering\012	if (!(_Left < _Right))\012		return (false);\012	else if (_Right < _Left)\012		_DEBUG_ERROR2(\"invalid operator<\", _File, _Line);\012	return (true);\012	}\012\012		// TEMPLATE FUNCTION _Debug_lt_pred\012template<class _Pr, class _Ty1, class _Ty2> inline\012	bool _Debug_lt_pred(_Pr _Pred,\012		const _Ty1& _Left, const _Ty2& _Right,\012		_Dbfile_t _File, _Dbline_t _Line)\012	{	// test if _Pred(_Left, _Right) and _Pred is strict weak ordering\012	if (!_Pred(_Left, _Right))\012		return (false);\012	else if (_Pred(_Right, _Left))\012		_DEBUG_ERROR2(\"invalid operator<\", _File, _Line);\012	return (true);\012	}\012\012template<class _Pr, class _Ty1, class _Ty2> inline\012	bool _Debug_lt_pred(_Pr _Pred,\012		const _Ty1& _Left, _Ty2& _Right,\012		_Dbfile_t _File, _Dbline_t _Line)\012	{	// test if _Pred(_Left, _Right) and _Pred is strict weak ordering\012	if (!_Pred(_Left, _Right))\012		return (false);\012	else if (_Pred(_Right, _Left))\012		_DEBUG_ERROR2(\"invalid operator<\", _File, _Line);\012	return (true);\012	}\012\012template<class _Pr, class _Ty1, class _Ty2> inline\012	bool _Debug_lt_pred(_Pr _Pred,\012		_Ty1& _Left, const _Ty2& _Right,\012		_Dbfile_t _File, _Dbline_t _Line)\012	{	// test if _Pred(_Left, _Right) and _Pred is strict weak ordering\012	if (!_Pred(_Left, _Right))\012		return (false);\012	else if (_Pred(_Right, _Left))\012		_DEBUG_ERROR2(\"invalid operator<\", _File, _Line);\012	return (true);\012	}\012\012template<class _Pr, class _Ty1, class _Ty2> inline\012	bool _Debug_lt_pred(_Pr _Pred,\012		_Ty1& _Left, _Ty2& _Right,\012		_Dbfile_t _File, _Dbline_t _Line)\012	{	// test if _Pred(_Left, _Right) and _Pred is strict weak ordering\012	if (!_Pred(_Left, _Right))\012		return (false);\012	else if (_Pred(_Right, _Left))\012		_DEBUG_ERROR2(\"invalid operator<\", _File, _Line);\012	return (true);\012	}\012\012		// TEMPLATE FUNCTION _Debug_pointer\012template<class _InIt> inline\012	void _Debug_pointer(_InIt&, _Dbfile_t, _Dbline_t)\012	{	// test pointer for non-singularity, arbitrary type\012	}\012\012template<class _Ty> inline\012	void _Debug_pointer(const _Ty *_First, _Dbfile_t _File, _Dbline_t _Line)\012	{	// test iterator for non-singularity, const pointers\012	if (_First == 0)\012		_DEBUG_ERROR2(\"invalid null pointer\", _File, _Line);\012	}\012\012template<class _Ty> inline\012	void _Debug_pointer(_Ty *_First, _Dbfile_t _File, _Dbline_t _Line)\012	{	// test iterator for non-singularity, pointers\012	if (_First == 0)\012		_DEBUG_ERROR2(\"invalid null pointer\", _File, _Line);\012	}\012\012		// TEMPLATE FUNCTION _Debug_range\012template<class _InIt> inline\012	void _Debug_range2(_InIt _First, _InIt _Last, _Dbfile_t, _Dbline_t,\012		input_iterator_tag)\012	{	// test iterator pair for valid range, arbitrary iterators\012	bool _Ans = _First == _Last;	// make sure they're comparable\012	_Ans = _Ans;	// to quiet diagnostics\012	}\012\012template<class _RanIt> inline\012	void _Debug_range2(_RanIt _First, _RanIt _Last,\012		_Dbfile_t _File, _Dbline_t _Line,\012		random_access_iterator_tag)\012	{	// test iterator pair for valid range, random-access iterators\012	if (_First != _Last)\012		{	// check for non-null pointers, valid range\012		_DEBUG_POINTER2(_First, _File, _Line);\012		_DEBUG_POINTER2(_Last, _File, _Line);\012		if (_Last < _First)\012			_DEBUG_ERROR2(\"invalid iterator range\", _File, _Line);\012		}\012	}\012\012template<class _InIt> inline\012	void _Debug_range(_InIt _First, _InIt _Last,\012		_Dbfile_t _File, _Dbline_t _Line)\012	{	// test iterator pair for valid range\012	_Debug_range2(_First, _Last, _File, _Line, _Iter_cat(_First));\012	}\012\012		// TEMPLATE FUNCTION _Debug_order\012template<class _InIt> inline\012	void _Debug_order2(_InIt, _InIt,\012		_Dbfile_t, _Dbline_t, input_iterator_tag)\012	{	// test if range is ordered by operator<, input iterators\012	}\012\012template<class _FwdIt> inline\012	void _Debug_order2(_FwdIt _First, _FwdIt _Last,\012		_Dbfile_t _File, _Dbline_t _Line, forward_iterator_tag)\012	{	// test if range is ordered by operator<, forward iterators\012	for (_FwdIt _Next = _First; _First != _Last && ++_Next != _Last; ++_First)\012		if (_DEBUG_LT(*_Next, *_First))\012			_DEBUG_ERROR2(\"sequence not ordered\", _File, _Line);\012	}\012\012template<class _InIt> inline\012	void _Debug_order(_InIt _First, _InIt _Last,\012		_Dbfile_t _File, _Dbline_t _Line)\012	{	// test is range is ordered by operator<\012	_DEBUG_RANGE2(_First, _Last, _File, _Line);\012	_Debug_order2(_First, _Last, _File, _Line, _Iter_cat(_First));\012	}\012\012		// TEMPLATE FUNCTION _Debug_order_pred\012template<class _InIt,\012	class _Pr> inline\012	void _Debug_order2(_InIt, _InIt, _Pr,\012		_Dbfile_t, _Dbline_t, input_iterator_tag)\012	{	// test if range is ordered by predicate, input iterators\012	}\012\012template<class _FwdIt,\012	class _Pr> inline\012	void _Debug_order2(_FwdIt _First, _FwdIt _Last, _Pr _Pred,\012		_Dbfile_t _File, _Dbline_t _Line, forward_iterator_tag)\012	{	// test if range is ordered by predicate, forward iterators\012	for (_FwdIt _Next = _First; _First != _Last && ++_Next != _Last; ++_First)\012		if (_DEBUG_LT_PRED(_Pred, *_Next, *_First))\012			_DEBUG_ERROR2(\"sequence not ordered\", _File, _Line);\012	}\012\012template<class _InIt,\012	class _Pr> inline\012	void _Debug_order(_InIt _First, _InIt _Last, _Pr _Pred,\012		_Dbfile_t _File, _Dbline_t _Line)\012	{	// test if range is ordered by predicate\012	_DEBUG_RANGE2(_First, _Last, _File, _Line);\012	_DEBUG_POINTER2(_Pred, _File, _Line);\012	_Debug_order2(_First, _Last, _Pred, _File, _Line, _Iter_cat(_First));\012	}\012 #endif /* _ITERATOR_DEBUG_LEVEL < 2 */\012\012		// MORE ITERATOR STUFF (from <iterator>\012		// TEMPLATE FUNCTION _Val_type\012\012template<class _Iter> inline\012	typename iterator_traits<_Iter>::value_type *_Val_type(_Iter)\012	{	// return value type from arbitrary argument\012	return (0);\012	}\012\012		// TEMPLATE FUNCTION advance\012template<class _InIt,\012	class _Diff> inline\012	void advance(_InIt& _Where, _Diff _Off)\012	{	// increment iterator by offset, arbitrary iterators\012	_Advance(_Where, _Off, _Iter_cat(_Where));\012	}\012\012template<class _InIt,\012	class _Diff> inline\012	void _Advance(_InIt& _Where, _Diff _Off, input_iterator_tag)\012	{	// increment iterator by offset, input iterators\012 #if _ITERATOR_DEBUG_LEVEL == 2\012//	if (_Off < 0)\012//		_DEBUG_ERROR(\"negative offset in advance\");\012 #endif /* _ITERATOR_DEBUG_LEVEL == 2 */\012\012	for (; 0 < _Off; --_Off)\012		++_Where;\012	}\012\012template<class _FI,\012	class _Diff> inline\012	void _Advance(_FI& _Where, _Diff _Off, forward_iterator_tag)\012	{	// increment iterator by offset, forward iterators\012 #if _ITERATOR_DEBUG_LEVEL == 2\012//	if (_Off < 0)\012//		_DEBUG_ERROR(\"negative offset in advance\");\012 #endif /* _ITERATOR_DEBUG_LEVEL == 2 */\012\012	for (; 0 < _Off; --_Off)\012		++_Where;\012	}\012\012template<class _BI,\012	class _Diff> inline\012	void _Advance(_BI& _Where, _Diff _Off, bidirectional_iterator_tag)\012	{	// increment iterator by offset, bidirectional iterators\012	for (; 0 < _Off; --_Off)\012		++_Where;\012	for (; _Off < 0; ++_Off)\012		--_Where;\012	}\012\012template<class _RI,\012	class _Diff> inline\012	void _Advance(_RI& _Where, _Diff _Off, random_access_iterator_tag)\012	{	// increment iterator by offset, random-access iterators\012	_Where += _Off;\012	}\012\012		// TEMPLATE FUNCTION _Dist_type\012\012template<class _Iter> inline\012	typename iterator_traits<_Iter>::difference_type\012		*_Dist_type(_Iter)\012	{	// return distance type from arbitrary argument\012	return (0);\012	}\012\012		// TEMPLATE FUNCTIONS distance and _Distance\012template<class _InIt,\012	class _Diff> inline\012		void _Distance2(_InIt _First, _InIt _Last, _Diff& _Off,\012			input_iterator_tag)\012	{	// add to _Off distance between input iterators\012	for (; _First != _Last; ++_First)\012		++_Off;\012	}\012\012template<class _FwdIt,\012	class _Diff> inline\012		void _Distance2(_FwdIt _First, _FwdIt _Last, _Diff& _Off,\012			forward_iterator_tag)\012	{	// add to _Off distance between forward iterators (redundant)\012	for (; _First != _Last; ++_First)\012		++_Off;\012	}\012\012template<class _BidIt,\012	class _Diff> inline\012		void _Distance2(_BidIt _First, _BidIt _Last, _Diff& _Off,\012			bidirectional_iterator_tag)\012	{	// add to _Off distance between bidirectional iterators (redundant)\012	for (; _First != _Last; ++_First)\012		++_Off;\012	}\012\012template<class _RanIt,\012	class _Diff> inline\012		void _Distance2(_RanIt _First, _RanIt _Last, _Diff& _Off,\012			random_access_iterator_tag)\012	{	// add to _Off distance between random-access iterators\012 #if _ITERATOR_DEBUG_LEVEL == 2\012	if (_First != _Last)\012		{	// check for null pointers\012		_DEBUG_POINTER(_First);\012		_DEBUG_POINTER(_Last);\012		}\012 #endif /* _ITERATOR_DEBUG_LEVEL == 2 */\012\012	_Off += _Last - _First;\012	}\012\012template<class _InIt> inline\012	typename iterator_traits<_InIt>::difference_type\012		distance(_InIt _First, _InIt _Last)\012	{	// return distance between iterators\012	typename iterator_traits<_InIt>::difference_type _Off = 0;\012	_Distance2(_First, _Last, _Off, _Iter_cat(_First));\012	return (_Off);\012	}\012\012template<class _InIt,\012	class _Diff> inline\012		void _Distance(_InIt _First, _InIt _Last, _Diff& _Off)\012	{	// add to _Off distance between iterators\012	_Distance2(_First, _Last, _Off, _Iter_cat(_First));\012	}\012\012 #if _HAS_CPP0X\012		// TEMPLATE FUNCTIONS next and prev\012template<class _InIt,\012	class _Diff> inline\012		_InIt _Increment(_InIt _First, _Diff _Off,\012			input_iterator_tag)\012	{	// add _Off to input iterator\012	for (; 0 < _Off; --_Off)\012		++_First;\012	return (_First);\012	}\012\012template<class _FwdIt,\012	class _Diff> inline\012		_FwdIt _Increment(_FwdIt _First, _Diff _Off,\012			forward_iterator_tag)\012	{	// add _Off to forward iterator\012	for (; 0 < _Off; --_Off)\012		++_First;\012	return (_First);\012	}\012\012template<class _BidIt,\012	class _Diff> inline\012		_BidIt _Increment(_BidIt _First, _Diff _Off,\012			bidirectional_iterator_tag)\012	{	// add _Off to bidirectional iterator\012	for (; _Off < 0; ++_Off)\012		--_First;\012	for (; 0 < _Off; --_Off)\012		++_First;\012	return (_First);\012	}\012\012template<class _RanIt,\012	class _Diff> inline\012		_RanIt _Increment(_RanIt _First, _Diff _Off,\012			random_access_iterator_tag)\012	{	// add _Off to random-access iterator\012	return (_First + _Off);\012	}\012\012template<class _InIt> inline\012	_InIt next(_InIt _First,\012		typename iterator_traits<_InIt>::difference_type _Off = 1)\012	{	// increment iterator\012	return (_Increment(_First, _Off, _Iter_cat(_First)));\012	}\012\012template<class _InIt> inline\012	_InIt prev(_InIt _First,\012		typename iterator_traits<_InIt>::difference_type _Off = 1)\012	{	// decrement iterator\012	return (_Increment(_First, -_Off, _Iter_cat(_First)));\012	}\012\012template<class _Container> inline\012	typename _Container::iterator begin(_Container& _Cont)\012	{	// get beginning of sequence\012	return (_Cont.begin());\012	}\012\012template<class _Container> inline\012	typename _Container::const_iterator begin(const _Container& _Cont)\012	{	// get beginning of sequence\012	return (_Cont.begin());\012	}\012\012template<class _Container> inline\012	typename _Container::iterator end(_Container& _Cont)\012	{	// get end of sequence\012	return (_Cont.end());\012	}\012\012template<class _Container> inline\012	typename _Container::const_iterator end(const _Container& _Cont)\012	{	// get end of sequence\012	return (_Cont.end());\012	}\012\012template<class _Ty,\012	size_t _Size> inline\012	_Ty *begin(_Ty (&_Array)[_Size])\012	{	// get beginning of array\012	return (&_Array[0]);\012	}\012\012template<class _Ty,\012	size_t _Size> inline\012	_Ty *end(_Ty (&_Array)[_Size])\012	{	// get end of array\012	return (&_Array[0] + _Size);\012	}\012 #endif /* _HAS_CPP0X */\012\012		// TEMPLATE CLASS _Revranit\012template<class _RanIt,\012	class _Base>\012	class _Revranit\012		: public _Base\012	{	// wrap iterator to run it backwards\012public:\012	typedef _Revranit<_RanIt, _Base> _Myt;\012 	typedef typename _Base::difference_type difference_type;\012	typedef typename _Base::pointer pointer;\012	typedef typename _Base::reference reference;\012	typedef _RanIt iterator_type;\012\012	_Revranit()\012		{	// construct with default wrapped iterator\012		}\012\012	explicit _Revranit(_RanIt _Right)\012		: current(_Right)\012		{	// construct wrapped iterator from _Right\012		}\012\012	template<class _RanIt2,\012		class _Base2>\012		_Revranit(const _Revranit<_RanIt2, _Base2>& _Right)\012		: current(_Right.base())\012		{	// initialize with compatible base\012		}\012\012	_RanIt base() const\012		{	// return wrapped iterator\012		return (current);\012		}\012\012	reference operator*() const\012		{	// return designated value\012		_RanIt _Tmp = current;\012		return (*--_Tmp);\012		}\012\012	pointer operator->() const\012		{	// return pointer to class object\012		return (&**this);\012		}\012\012	_Myt& operator++()\012		{	// preincrement\012		--current;\012		return (*this);\012		}\012\012	_Myt operator++(int)\012		{	// postincrement\012		_Myt _Tmp = *this;\012		--current;\012		return (_Tmp);\012		}\012\012	_Myt& operator--()\012		{	// predecrement\012		++current;\012		return (*this);\012		}\012\012	_Myt operator--(int)\012		{	// postdecrement\012		_Myt _Tmp = *this;\012		++current;\012		return (_Tmp);\012		}\012\012	template<class _RanIt2,\012		class _Base2>\012		bool _Equal(const _Revranit<_RanIt2, _Base2>& _Right) const\012		{	// test for iterator equality\012		return (current == _Right.base());\012		}\012\012// N.B. functions valid for random-access iterators only beyond this point\012\012	_Myt& operator+=(difference_type _Off)\012		{	// increment by integer\012		current -= _Off;\012		return (*this);\012		}\012\012	_Myt operator+(difference_type _Off) const\012		{	// return this + integer\012		return (_Myt(current - _Off));\012		}\012\012	_Myt& operator-=(difference_type _Off)\012		{	// decrement by integer\012		current += _Off;\012		return (*this);\012		}\012\012	_Myt operator-(difference_type _Off) const\012		{	// return this - integer\012		return (_Myt(current + _Off));\012		}\012\012	reference operator[](difference_type _Off) const\012		{	// subscript\012		return (*(*this + _Off));\012		}\012\012	template<class _RanIt2,\012		class _Base2>\012		bool _Less(const _Revranit<_RanIt2, _Base2>& _Right) const\012		{	// test if this < _Right\012		return (_Right.base() < current);\012		}\012\012	difference_type operator-(const _Myt& _Right) const\012		{	// return difference of iterators\012		return (_Right.base() - current);\012		}\012\012protected:\012	_RanIt current;	// the wrapped iterator\012	};\012\012		// _Revranit TEMPLATE OPERATORS\012template<class _RanIt,\012	class _Base,\012	class _Diff> inline\012	_Revranit<_RanIt, _Base>\012		operator+(_Diff _Off,\012		const _Revranit<_RanIt, _Base>& _Right)\012	{	// return reverse_iterator + integer\012	return (_Right + _Off);\012	}\012\012template<class _RanIt1,\012	class _Base1,\012	class _RanIt2,\012	class _Base2> inline\012	typename _Base1::difference_type operator-(\012		const _Revranit<_RanIt1, _Base1>& _Left,\012		const _Revranit<_RanIt2, _Base2>& _Right)\012	{	// return difference of reverse_iterators\012	return (_Right.base() - _Left.base());\012	}\012\012template<class _RanIt1,\012	class _Base1,\012	class _RanIt2,\012	class _Base2> inline\012	bool operator==(\012		const _Revranit<_RanIt1, _Base1>& _Left,\012		const _Revranit<_RanIt2, _Base2>& _Right)\012	{	// test for reverse_iterator equality\012	return (_Left._Equal(_Right));\012	}\012\012template<class _RanIt1,\012	class _Base1,\012	class _RanIt2,\012	class _Base2> inline\012	bool operator!=(\012		const _Revranit<_RanIt1, _Base1>& _Left,\012		const _Revranit<_RanIt2, _Base2>& _Right)\012	{	// test for reverse_iterator inequality\012	return (!(_Left == _Right));\012	}\012\012template<class _RanIt1,\012	class _Base1,\012	class _RanIt2,\012	class _Base2> inline\012	bool operator<(\012		const _Revranit<_RanIt1, _Base1>& _Left,\012		const _Revranit<_RanIt2, _Base2>& _Right)\012	{	// test for reverse_iterator < reverse_iterator\012	return (_Left._Less(_Right));\012	}\012\012template<class _RanIt1,\012	class _Base1,\012	class _RanIt2,\012	class _Base2> inline\012	bool operator>(\012		const _Revranit<_RanIt1, _Base1>& _Left,\012		const _Revranit<_RanIt2, _Base2>& _Right)\012	{	// test for reverse_iterator > reverse_iterator\012	return (_Right < _Left);\012	}\012\012template<class _RanIt1,\012	class _Base1,\012	class _RanIt2,\012	class _Base2> inline\012	bool operator<=(\012		const _Revranit<_RanIt1, _Base1>& _Left,\012		const _Revranit<_RanIt2, _Base2>& _Right)\012	{	// test for reverse_iterator <= reverse_iterator\012	return (!(_Right < _Left));\012	}\012\012template<class _RanIt1,\012	class _Base1,\012	class _RanIt2,\012	class _Base2> inline\012	bool operator>=(\012		const _Revranit<_RanIt1, _Base1>& _Left,\012		const _Revranit<_RanIt2, _Base2>& _Right)\012	{	// test for reverse_iterator >= reverse_iterator\012	return (!(_Left < _Right));\012	}\012\012		// TEMPLATE CLASS reverse_iterator\012template<class _RanIt>\012	class reverse_iterator\012		: public _Revranit<_RanIt, iterator<\012			typename iterator_traits<_RanIt>::iterator_category,\012			typename iterator_traits<_RanIt>::value_type,\012			typename iterator_traits<_RanIt>::difference_type,\012			typename iterator_traits<_RanIt>::pointer,\012			typename iterator_traits<_RanIt>::reference> >\012	{	// wrap iterator to run it backwards\012	typedef reverse_iterator<_RanIt> _Myt;\012	typedef _Revranit<_RanIt, iterator<\012		typename iterator_traits<_RanIt>::iterator_category,\012		typename iterator_traits<_RanIt>::value_type,\012		typename iterator_traits<_RanIt>::difference_type,\012		typename iterator_traits<_RanIt>::pointer,\012		typename iterator_traits<_RanIt>::reference> > _Mybase;\012\012public:\012 	typedef typename iterator_traits<_RanIt>::difference_type difference_type;\012	typedef typename iterator_traits<_RanIt>::pointer pointer;\012	typedef typename iterator_traits<_RanIt>::reference reference;\012	typedef _RanIt iterator_type;\012\012	reverse_iterator()\012		{	// construct with default wrapped iterator\012		}\012\012	explicit reverse_iterator(_RanIt _Right)\012		: _Mybase(_Right)\012		{	// construct wrapped iterator from _Right\012		}\012\012	template<class _Other>\012		reverse_iterator(const reverse_iterator<_Other>& _Right)\012		: _Mybase(_Right.base())\012		{	// initialize with compatible base\012		}\012\012	reverse_iterator(_Mybase _Right)\012		: _Mybase(_Right)\012		{	// construct wrapped iterator from base object\012		}\012\012	_Myt& operator++()\012		{	// preincrement\012		++*((_Mybase *)this);\012		return (*this);\012		}\012\012	_Myt operator++(int)\012		{	// postincrement\012		_Myt _Tmp = *this;\012		++*this;\012		return (_Tmp);\012		}\012\012	_Myt& operator--()\012		{	// predecrement\012		--*((_Mybase *)this);\012		return (*this);\012		}\012\012	_Myt operator--(int)\012		{	// postdecrement\012		_Myt _Tmp = *this;\012		--*this;\012		return (_Tmp);\012		}\012\012	_Myt& operator+=(difference_type _Off)\012		{	// increment by integer\012		*((_Mybase *)this) += _Off;\012		return (*this);\012		}\012\012	_Myt operator+(difference_type _Off) const\012		{	// return this + integer\012		_Myt _Tmp = *this;\012		return (_Tmp += _Off);\012		}\012\012	_Myt& operator-=(difference_type _Off)\012		{	// decrement by integer\012		*((_Mybase *)this) -= _Off;\012		return (*this);\012		}\012\012	_Myt operator-(difference_type _Off) const\012		{	// return this - integer\012		_Myt _Tmp = *this;\012		return (_Tmp -= _Off);\012		}\012	};\012\012template<class _RanIt>\012	struct _Is_checked_helper<reverse_iterator<_RanIt> >\012	: public _Is_checked_helper<_RanIt>\012	{	// mark reverse_iterator as checked if its underlying iterator is checked\012	};\012\012		// reverse_iterator TEMPLATE OPERATORS\012template<class _RanIt,\012	class _Diff> inline\012	reverse_iterator<_RanIt> operator+(_Diff _Off,\012		const reverse_iterator<_RanIt>& _Right)\012	{	// return reverse_iterator + integer\012	return (_Right + _Off);\012	}\012\012template<class _RanIt1,\012	class _RanIt2> inline\012	typename reverse_iterator<_RanIt1>::difference_type\012		operator-(const reverse_iterator<_RanIt1>& _Left,\012			const reverse_iterator<_RanIt2>& _Right)\012	{	// return difference of reverse_iterators\012	return (_Right.base() - _Left.base());\012	}\012\012template<class _RanIt1,\012	class _RanIt2> inline\012	bool operator==(const reverse_iterator<_RanIt1>& _Left,\012		const reverse_iterator<_RanIt2>& _Right)\012	{	// test for reverse_iterator equality\012	return (_Left._Equal(_Right));\012	}\012\012template<class _RanIt1,\012	class _RanIt2> inline\012	bool operator!=(const reverse_iterator<_RanIt1>& _Left,\012		const reverse_iterator<_RanIt2>& _Right)\012	{	// test for reverse_iterator inequality\012	return (!(_Left == _Right));\012	}\012\012template<class _RanIt1,\012	class _RanIt2> inline\012	bool operator<(const reverse_iterator<_RanIt1>& _Left,\012		const reverse_iterator<_RanIt2>& _Right)\012	{	// test for reverse_iterator < reverse_iterator\012	return (_Left._Less(_Right));\012	}\012\012template<class _RanIt1,\012	class _RanIt2> inline\012	bool operator>(const reverse_iterator<_RanIt1>& _Left,\012		const reverse_iterator<_RanIt2>& _Right)\012	{	// test for reverse_iterator > reverse_iterator\012	return (_Right < _Left);\012	}\012\012template<class _RanIt1,\012	class _RanIt2> inline\012	bool operator<=(const reverse_iterator<_RanIt1>& _Left,\012		const reverse_iterator<_RanIt2>& _Right)\012	{	// test for reverse_iterator <= reverse_iterator\012	return (!(_Right < _Left));\012	}\012\012template<class _RanIt1,\012	class _RanIt2> inline\012	bool operator>=(const reverse_iterator<_RanIt1>& _Left,\012		const reverse_iterator<_RanIt2>& _Right)\012	{	// test for reverse_iterator >= reverse_iterator\012	return (!(_Left < _Right));\012	}\012\012		// TEMPLATE CLASS reverse_bidirectional_iterator (retained)\012template<class _BidIt,\012	class _Ty,\012	class _Reference = _Ty&,\012	class _Pointer = _Ty *,\012	class _Diff = ptrdiff_t>\012	class reverse_bidirectional_iterator\012		: public iterator<bidirectional_iterator_tag, _Ty, _Diff,\012			_Pointer, _Reference>\012	{	// wrap bidirectional iterator to run it backwards\012public:\012	typedef reverse_bidirectional_iterator<_BidIt, _Ty, _Reference,\012		_Pointer, _Diff> _Myt;\012	typedef _BidIt iterator_type;\012\012	reverse_bidirectional_iterator()\012		{	// construct with default wrapped iterator\012		}\012\012	explicit reverse_bidirectional_iterator(_BidIt _Right)\012		: current(_Right)\012		{	// construct wrapped iterator from _Right\012		}\012\012	_BidIt base() const\012		{	// return wrapped iterator\012		return (current);\012		}\012\012	_Reference operator*() const\012		{	// return designated value\012		_BidIt _Tmp = current;\012		return (*--_Tmp);\012		}\012\012	_Pointer operator->() const\012		{	// return pointer to class object\012		_Reference _Tmp = **this;\012		return (&_Tmp);\012		}\012\012	_Myt& operator++()\012		{	// preincrement\012		--current;\012		return (*this);\012		}\012\012	_Myt operator++(int)\012		{	// postincrement\012		_Myt _Tmp = *this;\012		--current;\012		return (_Tmp);\012		}\012\012	_Myt& operator--()\012		{	// predecrement\012		++current;\012		return (*this);\012		}\012\012	_Myt operator--(int)\012		{	// postdecrement\012		_Myt _Tmp = *this;\012		++current;\012		return (_Tmp);\012		}\012\012	bool operator==(const _Myt& _Right) const\012		{	// test for iterator equality\012		return (current == _Right.current);\012		}\012\012	bool operator!=(const _Myt& _Right) const\012		{	// test for iterator inequality\012		return (!(*this == _Right));\012		}\012\012protected:\012	_BidIt current;	// the wrapped iterator\012	};\012\012		// TEMPLATE CLASS _Revbidit\012template<class _BidIt,\012	class _BidIt2 = _BidIt>\012	class _Revbidit\012		: public iterator<\012			typename iterator_traits<_BidIt>::iterator_category,\012			typename iterator_traits<_BidIt>::value_type,\012			typename iterator_traits<_BidIt>::difference_type,\012			typename iterator_traits<_BidIt>::pointer,\012			typename iterator_traits<_BidIt>::reference>\012	{	// wrap bidirectional iterator to run it backwards\012public:\012	typedef _Revbidit<_BidIt, _BidIt2> _Myt;\012	typedef typename iterator_traits<_BidIt>::difference_type _Diff;\012	typedef typename iterator_traits<_BidIt>::pointer _Pointer;\012	typedef typename iterator_traits<_BidIt>::reference _Reference;\012	typedef _BidIt iterator_type;\012\012	_Revbidit()\012		{	// construct with default wrapped iterator\012		}\012\012	explicit _Revbidit(_BidIt _Right)\012		: current(_Right)\012		{	// construct wrapped iterator from _Right\012		}\012\012	_Revbidit(const _Revbidit<_BidIt2>& _Other)\012		: current (_Other.base())\012		{	// const converter or copy constructor\012		}\012\012	_BidIt base() const\012		{	// return wrapped iterator\012		return (current);\012		}\012\012	_Reference operator*() const\012		{	// return designated value\012		_BidIt _Tmp = current;\012		return (*--_Tmp);\012		}\012\012	_Pointer operator->() const\012		{	// return pointer to class object\012		_Reference _Tmp = **this;\012		return (&_Tmp);\012		}\012\012	_Myt& operator++()\012		{	// preincrement\012		--current;\012		return (*this);\012		}\012\012	_Myt operator++(int)\012		{	// postincrement\012		_Myt _Tmp = *this;\012		--current;\012		return (_Tmp);\012		}\012\012	_Myt& operator--()\012		{	// predecrement\012		++current;\012		return (*this);\012		}\012\012	_Myt operator--(int)\012		{	// postdecrement\012		_Myt _Tmp = *this;\012		++current;\012		return (_Tmp);\012		}\012\012	bool operator==(const _Myt& _Right) const\012		{	// test for iterator equality\012		return (current == _Right.current);\012		}\012\012	bool operator!=(const _Myt& _Right) const\012		{	// test for iterator inequality\012		return (!(*this == _Right));\012		}\012\012protected:\012	_BidIt current;\012	};\012\012		// TEMPLATE CLASS _Array_const_iterator\012template<class _Ty,\012	size_t _Size>\012	class _Array_const_iterator\012		: public _Iterator012<random_access_iterator_tag,\012			_Ty,\012			ptrdiff_t,\012			const _Ty *,\012			const _Ty&,\012			_Iterator_base>\012	{	// iterator for nonmutable array\012public:\012	typedef _Array_const_iterator<_Ty, _Size> _Myiter;\012	typedef random_access_iterator_tag iterator_category;\012\012	typedef _Ty value_type;\012	typedef size_t size_type;\012	typedef ptrdiff_t difference_type;\012	typedef const _Ty *pointer;\012	typedef const _Ty& reference;\012	enum {_EEN_SIZE = _Size};	// helper for expression evaluator\012	enum {_EEN_IDL =\012		_ITERATOR_DEBUG_LEVEL};	// helper for expression evaluator\012\012 #if _ITERATOR_DEBUG_LEVEL == 0\012	_Array_const_iterator()\012		{	// construct with null pointer\012		_Ptr = 0;\012		}\012\012	explicit _Array_const_iterator(pointer _Parg, size_t _Off = 0)\012		{	// construct with pointer and offset\012		_Ptr = _Parg + _Off;\012		}\012\012	typedef pointer _Unchecked_type;\012\012	_Myiter& _Rechecked(_Unchecked_type _Right)\012		{	// reset from unchecked iterator\012		_Ptr = _Right;\012		return (*this);\012		}\012\012	_Unchecked_type _Unchecked() const\012		{	// make an unchecked iterator\012		return (_Ptr);\012		}\012\012	reference operator*() const\012		{	// return designated object\012		return (*_Ptr);\012		}\012\012	pointer operator->() const\012		{	// return pointer to class object\012		return (&**this);\012		}\012\012	_Myiter& operator++()\012		{	// preincrement\012		++_Ptr;\012		return (*this);\012		}\012\012	_Myiter operator++(int)\012		{	// postincrement\012		_Myiter _Tmp = *this;\012		++*this;\012		return (_Tmp);\012		}\012\012	_Myiter& operator--()\012		{	// predecrement\012		--_Ptr;\012		return (*this);\012		}\012\012	_Myiter operator--(int)\012		{	// postdecrement\012		_Myiter _Tmp = *this;\012		--*this;\012		return (_Tmp);\012		}\012\012	_Myiter& operator+=(difference_type _Off)\012		{	// increment by integer\012		_Ptr += _Off;\012		return (*this);\012		}\012\012	_Myiter operator+(difference_type _Off) const\012		{	// return this + integer\012		_Myiter _Tmp = *this;\012		return (_Tmp += _Off);\012		}\012\012	_Myiter& operator-=(difference_type _Off)\012		{	// decrement by integer\012		return (*this += -_Off);\012		}\012\012	_Myiter operator-(difference_type _Off) const\012		{	// return this - integer\012		_Myiter _Tmp = *this;\012		return (_Tmp -= _Off);\012		}\012\012	difference_type operator-(const _Myiter& _Right) const\012		{	// return difference of iterators\012		return (_Ptr - _Right._Ptr);\012		}\012\012	reference operator[](difference_type _Off) const\012		{	// subscript\012		return (*(*this + _Off));\012		}\012\012	bool operator==(const _Myiter& _Right) const\012		{	// test for iterator equality\012		return (_Ptr == _Right._Ptr);\012		}\012\012	bool operator!=(const _Myiter& _Right) const\012		{	// test for iterator inequality\012		return (!(*this == _Right));\012		}\012\012	bool operator<(const _Myiter& _Right) const\012		{	// test if this < _Right\012		return (_Ptr < _Right._Ptr);\012		}\012\012	bool operator>(const _Myiter& _Right) const\012		{	// test if this > _Right\012		return (_Right < *this);\012		}\012\012	bool operator<=(const _Myiter& _Right) const\012		{	// test if this <= _Right\012		return (!(_Right < *this));\012		}\012\012	bool operator>=(const _Myiter& _Right) const\012		{	// test if this >= _Right\012		return (!(*this < _Right));\012		}\012\012	pointer _Ptr;	// beginning of array\012\012 #else /* _ITERATOR_DEBUG_LEVEL == 0 */\012	_Array_const_iterator()\012		{	// construct with null pointer\012		_Ptr = 0;\012		_Idx = 0;\012		}\012\012	explicit _Array_const_iterator(pointer _Parg, size_t _Off = 0)\012		{	// construct with pointer and offset\012		_Ptr = _Parg;\012		_Idx = _Off;\012		}\012\012	typedef pointer _Unchecked_type;\012\012	_Myiter& _Rechecked(_Unchecked_type _Right)\012		{	// reset from unchecked iterator\012		_Idx = _Right - _Ptr;\012		return (*this);\012		}\012\012	_Unchecked_type _Unchecked() const\012		{	// make an unchecked iterator\012		return (_Ptr + _Idx);\012		}\012\012	reference operator*() const\012		{	// return designated object\012 #if _ITERATOR_DEBUG_LEVEL == 2\012		if (_Ptr == 0\012			|| _Size <= _Idx)\012			{	// report error\012			_DEBUG_ERROR(\"array iterator not dereferencable\");\012			_SCL_SECURE_OUT_OF_RANGE;\012			}\012\012 #elif _ITERATOR_DEBUG_LEVEL == 1\012		_SCL_SECURE_VALIDATE(_Ptr != 0);\012		_SCL_SECURE_VALIDATE_RANGE(_Idx < _Size);\012 #endif /* _ITERATOR_DEBUG_LEVEL */\012\012		__analysis_assume(_Ptr != 0);\012\012		return (_Ptr[_Idx]);\012		}\012\012	pointer operator->() const\012		{	// return pointer to class object\012		return (&**this);\012		}\012\012	_Myiter& operator++()\012		{	// preincrement\012 #if _ITERATOR_DEBUG_LEVEL == 2\012		if (_Ptr == 0\012			|| _Size <= _Idx)\012			{	// report error\012			_DEBUG_ERROR(\"array iterator not incrementable\");\012			_SCL_SECURE_OUT_OF_RANGE;\012			}\012\012 #elif _ITERATOR_DEBUG_LEVEL == 1\012		_SCL_SECURE_VALIDATE(_Ptr != 0);\012		_SCL_SECURE_VALIDATE_RANGE(_Idx < _Size);\012 #endif /* _ITERATOR_DEBUG_LEVEL */\012\012		++_Idx;\012		return (*this);\012		}\012\012	_Myiter operator++(int)\012		{	// postincrement\012		_Myiter _Tmp = *this;\012		++*this;\012		return (_Tmp);\012		}\012\012	_Myiter& operator--()\012		{	// predecrement\012 #if _ITERATOR_DEBUG_LEVEL == 2\012		if (_Ptr == 0\012			|| _Idx <= 0)\012			{	// report error\012			_DEBUG_ERROR(\"array iterator not decrementable\");\012			_SCL_SECURE_OUT_OF_RANGE;\012			}\012\012 #elif _ITERATOR_DEBUG_LEVEL == 1\012		_SCL_SECURE_VALIDATE(_Ptr != 0);\012		_SCL_SECURE_VALIDATE_RANGE(0 < _Idx);\012 #endif /* _ITERATOR_DEBUG_LEVEL */\012\012		--_Idx;\012		return (*this);\012		}\012\012	_Myiter operator--(int)\012		{	// postdecrement\012		_Myiter _Tmp = *this;\012		--*this;\012		return (_Tmp);\012		}\012\012	_Myiter& operator+=(difference_type _Off)\012		{	// increment by integer\012 #if _ITERATOR_DEBUG_LEVEL == 2\012		if (_Size < _Idx + _Off)\012			{	// report error\012			_DEBUG_ERROR(\"array iterator + offset out of range\");\012			_SCL_SECURE_OUT_OF_RANGE;\012			}\012\012 #elif _ITERATOR_DEBUG_LEVEL == 1\012		_SCL_SECURE_VALIDATE_RANGE(_Idx + _Off <= _Size);\012 #endif /* _ITERATOR_DEBUG_LEVEL */\012\012		_Idx += _Off;\012		return (*this);\012		}\012\012	_Myiter operator+(difference_type _Off) const\012		{	// return this + integer\012		_Myiter _Tmp = *this;\012		return (_Tmp += _Off);\012		}\012\012	_Myiter& operator-=(difference_type _Off)\012		{	// decrement by integer\012		return (*this += -_Off);\012		}\012\012	_Myiter operator-(difference_type _Off) const\012		{	// return this - integer\012		_Myiter _Tmp = *this;\012		return (_Tmp -= _Off);\012		}\012\012	difference_type operator-(const _Myiter& _Right) const\012		{	// return difference of iterators\012		_Compat(_Right);\012		return (_Idx < _Right._Idx\012			? -(difference_type)(_Right._Idx - _Idx)\012			: (difference_type)_Idx - _Right._Idx);\012		}\012\012	reference operator[](difference_type _Off) const\012		{	// subscript\012		return (*(*this + _Off));\012		}\012\012	bool operator==(const _Myiter& _Right) const\012		{	// test for iterator equality\012		_Compat(_Right);\012		return (_Idx == _Right._Idx);\012		}\012\012	bool operator!=(const _Myiter& _Right) const\012		{	// test for iterator inequality\012		return (!(*this == _Right));\012		}\012\012	bool operator<(const _Myiter& _Right) const\012		{	// test if this < _Right\012		_Compat(_Right);\012		return (_Idx < _Right._Idx);\012		}\012\012	bool operator>(const _Myiter& _Right) const\012		{	// test if this > _Right\012		return (_Right < *this);\012		}\012\012	bool operator<=(const _Myiter& _Right) const\012		{	// test if this <= _Right\012		return (!(_Right < *this));\012		}\012\012	bool operator>=(const _Myiter& _Right) const\012		{	// test if this >= _Right\012		return (!(*this < _Right));\012		}\012\012 #if _ITERATOR_DEBUG_LEVEL == 2\012	void _Compat(const _Myiter& _Right) const\012		{	// test for compatible iterator pair\012		if (_Ptr != _Right._Ptr)\012			{	// report error\012			_DEBUG_ERROR(\"array iterators incompatible\");\012			_SCL_SECURE_INVALID_ARGUMENT;\012			}\012		}\012\012 #elif _ITERATOR_DEBUG_LEVEL == 1\012	void _Compat(const _Myiter& _Right) const\012		{	// test for compatible iterator pair\012		_SCL_SECURE_VALIDATE_RANGE(_Ptr == _Right._Ptr);\012		}\012 #endif /* _ITERATOR_DEBUG_LEVEL */\012\012	pointer _Ptr;	// beginning of array\012	size_t _Idx;	// offset into array\012 #endif /* _ITERATOR_DEBUG_LEVEL == 0 */\012	};\012\012template<class _Ty,\012	size_t _Size> inline\012	typename _Array_const_iterator<_Ty, _Size>::_Unchecked_type\012		_Unchecked(_Array_const_iterator<_Ty, _Size> _Iter)\012	{	// convert to unchecked\012	return (_Iter._Unchecked());\012	}\012\012template<class _Ty,\012	size_t _Size> inline\012	_Array_const_iterator<_Ty, _Size>&\012		_Rechecked(_Array_const_iterator<_Ty, _Size>& _Iter,\012			typename _Array_const_iterator<_Ty, _Size>\012				::_Unchecked_type _Right)\012	{	// convert to checked\012	return (_Iter._Rechecked(_Right));\012	}\012\012template<class _Ty,\012	size_t _Size> inline\012	_Array_const_iterator<_Ty, _Size> operator+(\012		typename _Array_const_iterator<_Ty, _Size>::difference_type _Off,\012		_Array_const_iterator<_Ty, _Size> _Next)\012	{	// add offset to iterator\012	return (_Next += _Off);\012	}\012\012		// TEMPLATE CLASS _Array_iterator\012template<class _Ty,\012	size_t _Size>\012	class _Array_iterator\012		: public _Array_const_iterator<_Ty, _Size>\012	{	// iterator for mutable array\012public:\012	typedef _Array_iterator<_Ty, _Size> _Myiter;\012	typedef _Array_const_iterator<_Ty, _Size> _Mybase;\012	typedef random_access_iterator_tag iterator_category;\012\012	typedef _Ty value_type;\012	typedef size_t size_type;\012	typedef ptrdiff_t difference_type;\012	typedef _Ty *pointer;\012	typedef _Ty& reference;\012\012	_Array_iterator()\012		{	// construct with null pointer\012		}\012\012	explicit _Array_iterator(pointer _Parg, size_t _Off = 0)\012		: _Mybase(_Parg, _Off)\012		{	// construct with pointer and offset\012		}\012	enum {_EEN_SIZE = _Size};	// helper for expression evaluator\012	enum {_EEN_IDL =\012		_ITERATOR_DEBUG_LEVEL};	// helper for expression evaluator\012\012	typedef pointer _Unchecked_type;\012\012	_Myiter& _Rechecked(_Unchecked_type _Right)\012		{	// reset from unchecked iterator\012		((_Mybase *)this)->_Rechecked(_Right);\012		return (*this);\012		}\012\012	_Unchecked_type _Unchecked() const\012		{	// make an unchecked iterator\012		return ((pointer)((_Mybase *)this)->_Unchecked());\012		}\012\012	reference operator*() const\012		{	// return designated object\012		return ((reference)**(_Mybase *)this);\012		}\012\012	pointer operator->() const\012		{	// return pointer to class object\012		return (&**this);\012		}\012\012	_Myiter& operator++()\012		{	// preincrement\012		++*(_Mybase *)this;\012		return (*this);\012		}\012\012	_Myiter operator++(int)\012		{	// postincrement\012		_Myiter _Tmp = *this;\012		++*this;\012		return (_Tmp);\012		}\012\012	_Myiter& operator--()\012		{	// predecrement\012		--*(_Mybase *)this;\012		return (*this);\012		}\012\012	_Myiter operator--(int)\012		{	// postdecrement\012		_Myiter _Tmp = *this;\012		--*this;\012		return (_Tmp);\012		}\012\012	_Myiter& operator+=(difference_type _Off)\012		{	// increment by integer\012		*(_Mybase *)this += _Off;\012		return (*this);\012		}\012\012	_Myiter operator+(difference_type _Off) const\012		{	// return this + integer\012		_Myiter _Tmp = *this;\012		return (_Tmp += _Off);\012		}\012\012	_Myiter& operator-=(difference_type _Off)\012		{	// decrement by integer\012		return (*this += -_Off);\012		}\012\012	_Myiter operator-(difference_type _Off) const\012		{	// return this - integer\012		_Myiter _Tmp = *this;\012		return (_Tmp -= _Off);\012		}\012\012	difference_type operator-(const _Mybase& _Right) const\012		{	// return difference of iterators\012		return (*(_Mybase *)this - _Right);\012		}\012\012	reference operator[](difference_type _Off) const\012		{	// subscript\012		return (*(*this + _Off));\012		}\012	};\012\012template<class _Ty,\012	size_t _Size> inline\012	typename _Array_iterator<_Ty, _Size>::_Unchecked_type\012		_Unchecked(_Array_iterator<_Ty, _Size> _Iter)\012	{	// convert to unchecked\012	return (_Iter._Unchecked());\012	}\012\012template<class _Ty,\012	size_t _Size> inline\012	_Array_iterator<_Ty, _Size>&\012		_Rechecked(_Array_iterator<_Ty, _Size>& _Iter,\012			typename _Array_iterator<_Ty, _Size>\012				::_Unchecked_type _Right)\012	{	// convert to checked\012	return (_Iter._Rechecked(_Right));\012	}\012\012template<class _Ty,\012	size_t _Size> inline\012	_Array_iterator<_Ty, _Size> operator+(\012		typename _Array_iterator<_Ty, _Size>::difference_type _Off,\012		_Array_iterator<_Ty, _Size> _Next)\012	{	// add offset to iterator\012	return (_Next += _Off);\012	}\012\012		//	ALGORITHM STUFF (from <algorithm>)\012		// TEMPLATE FUNCTION max\012template<class _Ty> inline\012	const _Ty& (max)(const _Ty& _Left, const _Ty& _Right)\012	{	// return larger of _Left and _Right\012	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);\012	}\012\012		// TEMPLATE FUNCTION max WITH PRED\012template<class _Ty,\012	class _Pr> inline\012	const _Ty& (max)(const _Ty& _Left, const _Ty& _Right, _Pr _Pred)\012	{	// return larger of _Left and _Right using _Pred\012	return (_DEBUG_LT_PRED(_Pred, _Left, _Right) ? _Right : _Left);\012	}\012\012		// TEMPLATE FUNCTION min\012template<class _Ty> inline\012	const _Ty& (min)(const _Ty& _Left, const _Ty& _Right)\012	{	// return smaller of _Left and _Right\012	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);\012	}\012\012		// TEMPLATE FUNCTION min WITH PRED\012template<class _Ty,\012	class _Pr> inline\012	const _Ty& (min)(const _Ty& _Left, const _Ty& _Right, _Pr _Pred)\012	{	// return smaller of _Left and _Right using _Pred\012	return (_DEBUG_LT_PRED(_Pred, _Right, _Left) ? _Right : _Left);\012	}\012\012		// TEMPLATE FUNCTION minmax\012  #define _MINMAX_PAIR(ty)	pair<const ty, const ty>\012\012template<class _Ty> inline\012	_MINMAX_PAIR(_Ty)\012		minmax(const _Ty& _Left, const _Ty& _Right)\012	{	// return pair(leftmost/smaller, rightmost/larger) of _Left and _Right\012	return (_Right < _Left\012		? _MINMAX_PAIR(_Ty)(_Right, _Left)\012		: _MINMAX_PAIR(_Ty)(_Left, _Right));\012	}\012\012		// TEMPLATE FUNCTION minmax WITH PRED\012template<class _Ty,\012	class _Pr> inline\012	_MINMAX_PAIR(_Ty)\012		minmax(const _Ty& _Left, const _Ty& _Right, _Pr _Pred)\012	{	// return pair(leftmost/smaller, rightmost/larger) of _Left and _Right\012	return (_Pred(_Right, _Left)\012		? _MINMAX_PAIR(_Ty)(_Right, _Left)\012		: _MINMAX_PAIR(_Ty)(_Left, _Right));\012	}\012\012		// TEMPLATE FUNCTION iter_swap\012template<class _FwdIt1,\012	class _FwdIt2> inline\012	void iter_swap(_FwdIt1 _Left, _FwdIt2 _Right)\012	{	// swap *_Left and *_Right\012	swap(*_Left, *_Right);\012	}\012\012		// TEMPLATE FUNCTION copy\012template<class _InIt,\012	class _OutIt> inline\012	_OutIt _Copy_impl(_InIt _First, _InIt _Last,\012		_OutIt _Dest, _Nonscalar_ptr_iterator_tag)\012	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators\012	for (; _First != _Last; ++_Dest, ++_First)\012		*_Dest = *_First;\012	return (_Dest);\012	}\012\012template<class _InIt,\012	class _OutIt> inline\012	_OutIt _Copy_impl(_InIt _First, _InIt _Last,\012		_OutIt _Dest, _Scalar_ptr_iterator_tag)\012	{	// copy [_First, _Last) to [_Dest, ...), pointers to scalars\012	ptrdiff_t _Count = _Last - _First;\012	_CSTD memmove(&*_Dest, &*_First,\012		_Count * sizeof (*_First));\012	return (_Dest + _Count);\012	}\012\012template<class _InIt,\012	class _OutIt> inline\012	_OutIt _Copy_impl(_InIt _First, _InIt _Last,\012		_OutIt _Dest)\012	{	// copy [_First, _Last) to [_Dest, ...)\012	return (_Copy_impl(_First, _Last,\012		_Dest, _Ptr_cat(_First, _Dest)));\012	}\012\012 #if _ITERATOR_DEBUG_LEVEL == 0\012template<class _InIt,\012	class _OutIt> inline\012	_OutIt copy(_InIt _First, _InIt _Last,\012		_OutIt _Dest)\012	{	// copy [_First, _Last) to [_Dest, ...)\012	return (_Rechecked(_Dest,\012		_Copy_impl(_Unchecked(_First), _Unchecked(_Last),\012			_Unchecked(_Dest))));\012	}\012\012 #else /* _ITERATOR_DEBUG_LEVEL == 0 */\012template<class _InIt,\012	class _OutIt> inline\012	_OutIt _Copy_impl(_InIt _First, _InIt _Last,\012		_OutIt _Dest, input_iterator_tag, output_iterator_tag)\012	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators\012	return (_Copy_impl(_First, _Last,\012		_Dest));\012	}\012\012template<class _InIt,\012	class _OutIt> inline\012	_OutIt _Copy_impl(_InIt _First, _InIt _Last,\012		_OutIt _Dest, random_access_iterator_tag, random_access_iterator_tag)\012	{	// copy [_First, _Last) to [_Dest, ...), random-access iterators\012	_OutIt _Ans = _Dest + (_Last - _First);	// also checks range\012	_Copy_impl(_First, _Last,\012		_Unchecked(_Dest));\012	return (_Ans);\012	}\012\012template<class _InIt,\012	class _OutIt> inline\012	_OutIt _Copy_impl(_InIt _First, _InIt _Last,\012		_OutIt _Dest, _STD tr1::true_type)\012	{	// copy [_First, _Last) to [_Dest, ...), checked dest\012	return (_Copy_impl(_First, _Last,\012		_Dest, _Iter_cat(_First), _Iter_cat(_Dest)));\012	}\012\012template<class _InIt,\012	class _OutIt> inline\012_SCL_INSECURE_DEPRECATE\012	_OutIt _Copy_impl(_InIt _First, _InIt _Last,\012		_OutIt _Dest, _STD tr1::false_type)\012	{	// copy [_First, _Last) to [_Dest, ...), unchecked dest\012	return (_Copy_impl(_First, _Last,\012		_Dest, _Iter_cat(_First), _Iter_cat(_Dest)));\012	}\012\012template<class _InIt,\012	class _OutIt> inline\012	_OutIt copy(_InIt _First, _InIt _Last,\012		_OutIt _Dest)\012	{	// copy [_First, _Last) to [_Dest, ...)\012	_DEBUG_RANGE(_First, _Last);\012	_DEBUG_POINTER(_Dest);\012	return (_Copy_impl(_Unchecked(_First), _Unchecked(_Last),\012		_Dest, _Is_checked(_Dest)));\012	}\012\012template<class _InIt,\012	class _OutTy,\012	size_t _OutSize> inline\012	_OutTy *copy(_InIt _First, _InIt _Last,\012		_OutTy (&_Dest)[_OutSize])\012	{	// copy [_First, _Last) to [_Dest, ...)\012	return (_Unchecked(\012		_STD copy(_First, _Last,\012			_Array_iterator<_OutTy, _OutSize>(_Dest))));\012	}\012 #endif /* _ITERATOR_DEBUG_LEVEL == 0 */\012\012 #if _HAS_CPP0X\012		// TEMPLATE FUNCTION copy_n\012template<class _InIt,\012	class _Diff,\012	class _OutIt> inline\012	_OutIt _Copy_n(_InIt _First, _Diff _Count,\012		_OutIt _Dest, input_iterator_tag)\012	{	// copy [_First, _First + _Count) to [_Dest, ...), arbitrary input\012	*_Dest = *_First;	// 0 < _Count has been guaranteed\012	while (0 < --_Count)\012		*++_Dest = *++_First;\012	return (++_Dest);\012	}\012\012template<class _InIt,\012	class _Diff,\012	class _OutIt> inline\012	_OutIt _Copy_n(_InIt _First, _Diff _Count,\012		_OutIt _Dest, forward_iterator_tag)\012	{	// copy [_First, _First + _Count) to [_Dest, ...), forward input\012	for (; 0 < _Count; --_Count, ++_Dest, ++_First)\012		*_Dest = *_First;\012	return (_Dest);\012	}\012\012template<class _InIt,\012	class _Diff,\012	class _OutIt> inline\012	_OutIt _Copy_n(_InIt _First, _Diff _Count,\012		_OutIt _Dest, _Nonscalar_ptr_iterator_tag)\012	{	// copy [_First, _First + _Count) to [_Dest, ...), arbitrary iterators\012	return (_Copy_n(_First, _Count,\012		_Dest, _Iter_cat(_First)));\012	}\012\012template<class _InIt,\012	class _Diff,\012	class _OutIt> inline\012	_OutIt _Copy_n(_InIt _First, _Diff _Count,\012		_OutIt _Dest, _Scalar_ptr_iterator_tag)\012	{	// copy [_First, _First + _Count) to [_Dest, ...), pointers to scalars\012	_CSTD memmove(&*_Dest, &*_First,\012		_Count * sizeof (*_First));\012	return (_Dest + _Count);\012	}\012\012template<class _InIt,\012	class _Diff,\012	class _OutIt> inline\012	_OutIt _Copy_n(_InIt _First, _Diff _Count,\012		_OutIt _Dest)\012	{	// copy [_First, _First + _Count) to [_Dest, ...), unchecked\012	return (_Copy_n(_First, _Count,\012		_Dest, _Ptr_cat(_First, _Dest)));\012	}\012\012 #if _ITERATOR_DEBUG_LEVEL == 0\012template<class _InIt,\012	class _Diff,\012	class _OutIt> inline\012	_OutIt copy_n(_InIt _First, _Diff _Count,\012		_OutIt _Dest)\012	{	// copy [_First, _First + _Count) to [_Dest, ...)\012	if (_Count <= 0)\012		return (_Dest);\012	else\012		return (_Rechecked(_Dest,\012			_Copy_n(_Unchecked(_First), _Count,\012				_Unchecked(_Dest))));\012	}\012\012 #else /* _ITERATOR_DEBUG_LEVEL == 0 */\012template<class _InIt,\012	class _Diff,\012	class _OutIt> inline\012	_OutIt _Copy_n2(_InIt _First, _Diff _Count,\012		_OutIt _Dest, output_iterator_tag)\012	{	// copy [_First, _First + _Count) to [_Dest, ...), arbitrary dest\012	return (_Copy_n(_First, _Count,\012		_Dest));\012	}\012\012template<class _InIt,\012	class _Diff,\012	class _OutIt> inline\012	_OutIt _Copy_n2(_InIt _First, _Diff _Count,\012		_OutIt _Dest, random_access_iterator_tag)\012	{	// copy [_First, _First + _Count) to [_Dest, ...), random-access dest\012	_OutIt _Ans = _Dest + _Count;	// also checks range\012	_Copy_n(_First, _Count,\012		_Unchecked(_Dest));\012	return (_Ans);\012	}\012\012template<class _InIt,\012	class _Diff,\012	class _OutIt> inline\012	_OutIt _Copy_n1(_InIt _First, _Diff _Count,\012		_OutIt _Dest, input_iterator_tag)\012	{	// copy [_First, _First + _Count) to [_Dest, ...), arbitrary input\012	return (_Copy_n2(_First, _Count,\012		_Dest, _Iter_cat(_Dest)));\012	}\012\012template<class _InIt,\012	class _Diff,\012	class _OutIt> inline\012	_OutIt _Copy_n1(_InIt _First, _Diff _Count,\012		_OutIt _Dest, random_access_iterator_tag)\012	{	// copy [_First, _First + _Count) to [_Dest, ...), random-access input\012	_InIt _Last = _First + _Count;	// also checks range\012	_Last = _Last;	// to quiet diagnostics\012	return (_Copy_n2(_Unchecked(_First), _Count,\012		_Dest, _Iter_cat(_Dest)));\012	}\012\012template<class _InIt,\012	class _Diff,\012	class _OutIt> inline\012	_OutIt _Copy_n(_InIt _First, _Diff _Count,\012		_OutIt _Dest, _STD tr1::true_type)\012	{	// copy [_First, _First + _Count) to [_Dest, ...), checked dest\012	return (_Copy_n1(_First, _Count,\012		_Dest, _Iter_cat(_First)));\012	}\012\012template<class _InIt,\012	class _Diff,\012	class _OutIt> inline\012_SCL_INSECURE_DEPRECATE\012	_OutIt _Copy_n(_InIt _First, _Diff _Count,\012		_OutIt _Dest, _STD tr1::false_type)\012	{	// copy [_First, _First + _Count) to [_Dest, ...), unchecked dest\012	return (_Copy_n1(_First, _Count,\012		_Dest, _Iter_cat(_First)));\012	}\012\012template<class _InIt,\012	class _Diff,\012	class _OutIt> inline\012	_OutIt copy_n(_InIt _First, _Diff _Count,\012		_OutIt _Dest)\012	{	// copy [_First, _First + _Count) to [_Dest, ...)\012	_DEBUG_POINTER(_First);\012	_DEBUG_POINTER(_Dest);\012	if (_Count <= 0)\012		return (_Dest);\012	else\012		return (_Copy_n(_First, _Count,\012			_Dest, _Is_checked(_Dest)));\012	}\012\012template<class _InTy,\012	size_t _InSize,\012	class _Diff,\012	class _OutIt> inline\012	_OutIt copy_n(_InTy (&_First)[_InSize], _Diff _Count,\012		_OutIt _Dest)\012	{	// copy [_First, _First + _Count) to [_Dest, ...), array input\012	return (_STD copy_n(_Array_iterator<_InTy, _InSize>(_First), _Count,\012		_Dest));\012	}\012\012template<class _InIt,\012	class _Diff,\012	class _OutTy,\012	size_t _OutSize> inline\012	_OutTy *copy_n(_InIt _First, _Diff _Count,\012		_OutTy (&_Dest)[_OutSize])\012	{	// copy [_First, _First + _Count) to [_Dest, ...), array dest\012	return (_Unchecked(\012		_STD copy_n(_First, _Count,\012			_Array_iterator<_OutTy, _OutSize>(_Dest))));\012	}\012\012template<class _InTy,\012	size_t _InSize,\012	class _Diff,\012	class _OutTy,\012	size_t _OutSize> inline\012	_OutTy *copy_n(_InTy (&_First)[_InSize], _Diff _Count,\012		_OutTy (&_Dest)[_OutSize])\012	{	// copy [_First, _First + _Count) to [_Dest, ...), array input/dest\012	return (_Unchecked(\012		_STD copy_n(_Array_iterator<_InTy, _InSize>(_First), _Count,\012			_Array_iterator<_OutTy, _OutSize>(_Dest))));\012	}\012\012 #endif /* _ITERATOR_DEBUG_LEVEL == 0 */\012 #endif /* _HAS_CPP0X */\012\012		// TEMPLATE FUNCTION copy_backward\012template<class _BidIt1,\012	class _BidIt2> inline\012	_BidIt2 _Copy_backward(_BidIt1 _First, _BidIt1 _Last,\012		_BidIt2 _Dest, _Nonscalar_ptr_iterator_tag)\012	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators\012	while (_First != _Last)\012		*--_Dest = *--_Last;\012	return (_Dest);\012	}\012\012template<class _InIt,\012	class _OutIt> inline\012	_OutIt _Copy_backward(_InIt _First, _InIt _Last,\012		_OutIt _Dest, _Scalar_ptr_iterator_tag)\012	{	// copy [_First, _Last) backwards to [..., _Dest), pointers to scalars\012	ptrdiff_t _Count = _Last - _First;\012	_CSTD memmove(&*_Dest - _Count, &*_First,\012		_Count * sizeof (*_First));\012	return (_Dest - _Count);\012	}\012\012template<class _BidIt1,\012	class _BidIt2> inline\012	_BidIt2 _Copy_backward(_BidIt1 _First, _BidIt1 _Last,\012		_BidIt2 _Dest)\012	{	// copy [_First, _Last) backwards to [..., _Dest), unchecked\012	return (_Copy_backward(_First, _Last,\012		_Dest, _Ptr_cat(_First, _Dest)));\012	}\012\012 #if _ITERATOR_DEBUG_LEVEL == 0\012template<class _BidIt1,\012	class _BidIt2> inline\012	_BidIt2 copy_backward(_BidIt1 _First, _BidIt1 _Last,\012		_BidIt2 _Dest)\012	{	// copy [_First, _Last) backwards to [..., _Dest)\012	return (_Rechecked(_Dest,\012		_Copy_backward(_Unchecked(_First), _Unchecked(_Last),\012			_Unchecked(_Dest))));\012	}\012\012 #else /* _ITERATOR_DEBUG_LEVEL == 0 */\012template<class _BidIt1,\012	class _BidIt2> inline\012	_BidIt2 _Copy_backward(_BidIt1 _First, _BidIt1 _Last,\012		_BidIt2 _Dest, _STD tr1::true_type)\012	{	// copy [_First, _Last) backwards to [..., _Dest), checked dest\012	return (_Copy_backward(_Unchecked(_First), _Unchecked(_Last),\012		_Dest));\012	}\012\012template<class _BidIt1,\012	class _BidIt2> inline\012_SCL_INSECURE_DEPRECATE\012	_BidIt2 _Copy_backward(_BidIt1 _First, _BidIt1 _Last,\012		_BidIt2 _Dest, _STD tr1::false_type)\012	{	// copy [_First, _Last) backwards to [..., _Dest), unchecked dest\012	return (_Copy_backward(_Unchecked(_First), _Unchecked(_Last),\012		_Dest));\012	}\012\012template<class _BidIt1,\012	class _BidIt2> inline\012	_BidIt2 copy_backward(_BidIt1 _First, _BidIt1 _Last,\012		_BidIt2 _Dest)\012	{	// copy [_First, _Last) backwards to [..., _Dest)\012	_DEBUG_RANGE(_First, _Last);\012	_DEBUG_POINTER(_Dest);\012	return (_Copy_backward(_Unchecked(_First), _Unchecked(_Last),\012		_Dest, _Is_checked(_Dest)));\012	}\012 #endif /* _ITERATOR_DEBUG_LEVEL == 0 */\012\012		// TEMPLATE FUNCTION move\012template<class _InIt,\012	class _OutIt> inline\012	_OutIt _Move(_InIt _First, _InIt _Last,\012		_OutIt _Dest, _Nonscalar_ptr_iterator_tag)\012	{	// move [_First, _Last) to [_Dest, ...), arbitrary iterators\012	for (; _First != _Last; ++_Dest, ++_First)\012		*_Dest = _STD move(*_First);\012	return (_Dest);\012	}\012\012template<class _InIt,\012	class _OutIt> inline\012	_OutIt _Move(_InIt _First, _InIt _Last,\012		_OutIt _Dest, _Scalar_ptr_iterator_tag)\012	{	// move [_First, _Last) to [_Dest, ...), pointers to scalars\012	ptrdiff_t _Count = _Last - _First;\012	_CSTD memmove(&*_Dest, &*_First,\012		_Count * sizeof (*_First));\012	return (_Dest + _Count);\012	}\012\012template<class _InIt,\012	class _OutIt> inline\012	_OutIt _Move(_InIt _First, _InIt _Last,\012		_OutIt _Dest)\012	{	// move [_First, _Last) to [_Dest, ...), unchecked\012	return (_Move(_First, _Last,\012		_Dest, _Ptr_cat(_First, _Dest)));\012	}\012\012 #if _ITERATOR_DEBUG_LEVEL == 0\012template<class _InIt,\012	class _OutIt> inline\012	_OutIt move(_InIt _First, _InIt _Last,\012		_OutIt _Dest)\012	{	// move [_First, _Last) to [_Dest, ...)\012	return (_Rechecked(_Dest,\012		_Move(_Unchecked(_First), _Unchecked(_Last),\012			_Unchecked(_Dest))));\012	}\012\012 #else /* _ITERATOR_DEBUG_LEVEL == 0 */\012template<class _InIt,\012	class _OutIt> inline\012	_OutIt _Move(_InIt _First, _InIt _Last,\012		_OutIt _Dest, input_iterator_tag, output_iterator_tag)\012	{	// move [_First, _Last) to [_Dest, ...), arbitrary iterators\012	return (_Move(_First, _Last,\012		_Dest));\012	}\012\012template<class _InIt,\012	class _OutIt> inline\012	_OutIt _Move(_InIt _First, _InIt _Last,\012		_OutIt _Dest, random_access_iterator_tag, random_access_iterator_tag)\012	{	// move [_First, _Last) to [_Dest, ...), random-access iterators\012	_OutIt _Ans = _Dest + (_Last - _First);	// also checks range\012	_Move(_First, _Last,\012		_Unchecked(_Dest));\012	return (_Ans);\012	}\012\012template<class _InIt,\012	class _OutIt> inline\012	_OutIt _Move(_InIt _First, _InIt _Last,\012		_OutIt _Dest, _STD tr1::true_type)\012	{	// move [_First, _Last) to [_Dest, ...), checked dest\012	return (_Move(_First, _Last,\012		_Dest, _Iter_cat(_First), _Iter_cat(_Dest)));\012	}\012\012template<class _InIt,\012	class _OutIt> inline\012_SCL_INSECURE_DEPRECATE\012	_OutIt _Move(_InIt _First, _InIt _Last,\012		_OutIt _Dest, _STD tr1::false_type)\012	{	// move [_First, _Last) to [_Dest, ...), unchecked dest\012	return (_Move(_First, _Last,\012		_Dest, _Iter_cat(_First), _Iter_cat(_Dest)));\012	}\012\012template<class _InIt,\012	class _OutIt> inline\012	_OutIt move(_InIt _First, _InIt _Last,\012		_OutIt _Dest)\012	{	// move [_First, _Last) to [_Dest, ...)\012	_DEBUG_RANGE(_First, _Last);\012	_DEBUG_POINTER(_Dest);\012	return (_Move(_Unchecked(_First), _Unchecked(_Last),\012		_Dest, _Is_checked(_Dest)));\012	}\012\012template<class _InIt,\012	class _OutTy,\012	size_t _OutSize> inline\012	_OutTy *move(_InIt _First, _InIt _Last,\012		_OutTy (&_Dest)[_OutSize])\012	{	// move [_First, _Last) to [_Dest, ...)\012	return (_Unchecked(\012		_STD move(_First, _Last,\012			_Array_iterator<_OutTy, _OutSize>(_Dest))));\012	}\012 #endif /* _ITERATOR_DEBUG_LEVEL == 0 */\012\012		// TEMPLATE FUNCTION move_backward\012template<class _BidIt1,\012	class _BidIt2> inline\012	_BidIt2 _Move_backward(_BidIt1 _First, _BidIt1 _Last,\012		_BidIt2 _Dest, _Nonscalar_ptr_iterator_tag)\012	{	// move [_First, _Last) backwards to [..., _Dest), arbitrary iterators\012	while (_First != _Last)\012		*--_Dest = _STD move(*--_Last);\012	return (_Dest);\012	}\012\012template<class _InIt,\012	class _OutIt> inline\012	_OutIt _Move_backward(_InIt _First, _InIt _Last,\012		_OutIt _Dest, _Scalar_ptr_iterator_tag)\012	{	// move [_First, _Last) backwards to [..., _Dest), pointers to scalars\012	ptrdiff_t _Count = _Last - _First;\012	_CSTD memmove(&*_Dest - _Count, &*_First,\012		_Count * sizeof (*_First));\012	return (_Dest - _Count);\012	}\012\012template<class _BidIt1,\012	class _BidIt2> inline\012	_BidIt2 _Move_backward(_BidIt1 _First, _BidIt1 _Last,\012		_BidIt2 _Dest)\012	{	// move [_First, _Last) backwards to [..., _Dest), unchecked\012	return (_Move_backward(_First, _Last,\012		_Dest, _Ptr_cat(_First, _Dest)));\012	}\012\012 #if _ITERATOR_DEBUG_LEVEL == 0\012template<class _BidIt1,\012	class _BidIt2> inline\012	_BidIt2 move_backward(_BidIt1 _First, _BidIt1 _Last,\012		_BidIt2 _Dest)\012	{	// move [_First, _Last) backwards to [..., _Dest)\012	return (_Rechecked(_Dest,\012		_Move_backward(_Unchecked(_First), _Unchecked(_Last),\012			_Unchecked(_Dest))));\012	}\012\012 #else /* _ITERATOR_DEBUG_LEVEL == 0 */\012template<class _BidIt1,\012	class _BidIt2> inline\012	_BidIt2 _Move_backward(_BidIt1 _First, _BidIt1 _Last,\012		_BidIt2 _Dest, _STD tr1::true_type)\012	{	// move [_First, _Last) backwards to [..., _Dest), checked dest\012	return (_Move_backward(_Unchecked(_First), _Unchecked(_Last),\012		_Dest));\012	}\012\012template<class _BidIt1,\012	class _BidIt2> inline\012_SCL_INSECURE_DEPRECATE\012	_BidIt2 _Move_backward(_BidIt1 _First, _BidIt1 _Last,\012		_BidIt2 _Dest, _STD tr1::false_type)\012	{	// move [_First, _Last) backwards to [..., _Dest), unchecked dest\012	return (_Move_backward(_Unchecked(_First), _Unchecked(_Last),\012		_Dest));\012	}\012\012template<class _BidIt1,\012	class _BidIt2> inline\012	_BidIt2 move_backward(_BidIt1 _First, _BidIt1 _Last,\012		_BidIt2 _Dest)\012	{	// move [_First, _Last) backwards to [..., _Dest)\012	_DEBUG_RANGE(_First, _Last);\012	_DEBUG_POINTER(_Dest);\012	return (_Move_backward(_Unchecked(_First), _Unchecked(_Last),\012		_Dest, _Is_checked(_Dest)));\012	}\012 #endif /* _ITERATOR_DEBUG_LEVEL == 0 */\012\012		// TEMPLATE FUNCTION fill\012template<class _FwdIt,\012	class _Ty> inline\012	void _Fill(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)\012	{	// copy _Val through [_First, _Last)\012	for (; _First != _Last; ++_First)\012		*_First = _Val;\012	}\012\012inline void _Fill(char *_First, char *_Last, int _Val)\012	{	// copy char _Val through [_First, _Last)\012	_CSTD memset(_First, _Val, _Last - _First);\012	}\012\012inline void _Fill(signed char *_First, signed char *_Last, int _Val)\012	{	// copy signed char _Val through [_First, _Last)\012	_CSTD memset(_First, _Val, _Last - _First);\012	}\012\012inline void _Fill(unsigned char *_First, unsigned char *_Last, int _Val)\012	{	// copy unsigned char _Val through [_First, _Last)\012	_CSTD memset(_First, _Val, _Last - _First);\012	}\012\012template<class _FwdIt,\012	class _Ty> inline\012	void fill(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)\012	{	// copy _Val through [_First, _Last)\012	_DEBUG_RANGE(_First, _Last);\012	_Fill(_Unchecked(_First), _Unchecked(_Last), _Val);\012	}\012\012		// TEMPLATE FUNCTION fill_n\012template<class _OutIt,\012	class _Diff,\012	class _Ty> inline\012	void _Fill_n(_OutIt _Dest, _Diff _Count, const _Ty& _Val)\012	{	// copy _Val _Count times through [_Dest, ...)\012	for (; 0 < _Count; --_Count, ++_Dest)\012		*_Dest = _Val;\012	}\012\012inline void _Fill_n(char *_Dest, size_t _Count, int _Val)\012	{	// copy char _Val _Count times through [_Dest, ...)\012	_CSTD memset(_Dest, _Val, _Count);\012	}\012\012inline void _Fill_n(signed char *_Dest, size_t _Count, int _Val)\012	{	// copy signed char _Val _Count times through [_Dest, ...)\012	_CSTD memset(_Dest, _Val, _Count);\012	}\012\012inline void _Fill_n(unsigned char *_Dest, size_t _Count, int _Val)\012	{	// copy unsigned char _Val _Count times through [_Dest, ...)\012	_CSTD memset(_Dest, _Val, _Count);\012	}\012\012 #if _ITERATOR_DEBUG_LEVEL == 0\012template<class _OutIt,\012	class _Diff,\012	class _Ty> inline\012	void fill_n(_OutIt _Dest, _Diff _Count, const _Ty& _Val)\012	{	// copy _Val _Count times through [_Dest, ...)\012	_Fill_n(_Unchecked(_Dest), _Count, _Val);\012	}\012\012 #else /* _ITERATOR_DEBUG_LEVEL == 0 */\012template<class _OutIt,\012	class _Diff,\012	class _Ty> inline\012	void _Fill_n1(_OutIt _Dest, _Diff _Count, const _Ty& _Val,\012		output_iterator_tag)\012	{	// copy _Val _Count times through [_Dest, ...), arbitrary iterator\012	_Fill_n(_Dest, _Count, _Val);\012	}\012\012template<class _OutIt,\012	class _Diff,\012	class _Ty> inline\012	void _Fill_n1(_OutIt _Dest, _Diff _Count, const _Ty& _Val,\012		random_access_iterator_tag)\012	{	// copy _Val _Count times through [_Dest, ...), random-access iterator\012	_OutIt _Ans = _Dest + _Count;	// also checks range\012	_Ans = _Ans;	// to quiet diagnostics\012	_Fill_n(_Unchecked(_Dest), _Count, _Val);\012	}\012\012template<class _OutIt,\012	class _Diff,\012	class _Ty> inline\012	void _Fill_n(_OutIt _Dest, _Diff _Count, const _Ty& _Val,\012		_STD tr1::true_type)\012	{	// copy _Val _Count times through [_Dest, ...), checked dest\012	_Fill_n1(_Dest, _Count, _Val,\012		_Iter_cat(_Dest));\012	}\012\012template<class _OutIt,\012	class _Diff,\012	class _Ty> inline\012_SCL_INSECURE_DEPRECATE\012	void _Fill_n(_OutIt _Dest, _Diff _Count, const _Ty& _Val,\012		_STD tr1::false_type)\012	{	// copy _Val _Count times through [_Dest, ...), unchecked dest\012	_Fill_n1(_Dest, _Count, _Val,\012		_Iter_cat(_Dest));\012	}\012\012template<class _OutIt,\012	class _Diff,\012	class _Ty> inline\012	void fill_n(_OutIt _Dest, _Diff _Count, const _Ty& _Val)\012	{	// copy _Val _Count times through [_Dest, ...)\012	_DEBUG_POINTER(_Dest);\012	_Fill_n(_Dest, _Count, _Val,\012		_Is_checked(_Dest));\012	}\012\012template<class _OutTy,\012	size_t _OutSize,\012	class _Diff,\012	class _Ty> inline\012	void fill_n(_OutTy (&_Dest)[_OutSize], _Diff _Count, const _Ty& _Val)\012	{	// copy _Val _Count times through [_Dest, ...)\012	_STD fill_n(_Array_iterator<_OutTy, _OutSize>(_Dest), _Count, _Val);\012	}\012 #endif /* _ITERATOR_DEBUG_LEVEL == 0 */\012\012		// TEMPLATE FUNCTION mismatch\012template<class _InIt1,\012	class _InIt2> inline\012	pair<_InIt1, _InIt2>\012		_Mismatch(_InIt1 _First1, _InIt1 _Last1,\012			_InIt2 _First2)\012	{	// return [_First1, _Last1)/[_First2, ...) mismatch\012	for (; _First1 != _Last1 && *_First1 == *_First2; )\012		++_First1, ++_First2;\012	return (pair<_InIt1, _InIt2>(_First1, _First2));\012	}\012\012 #if _ITERATOR_DEBUG_LEVEL == 0\012template<class _InIt1,\012	class _InIt2> inline\012	pair<_InIt1, _InIt2>\012		mismatch(_InIt1 _First1, _InIt1 _Last1,\012			_InIt2 _First2)\012	{	// return [_First1, _Last1)/[_First2, ...) mismatch\012	_STD pair<_UNCHECKED_TYPE(_InIt1), _InIt2> _Ans(\012		_STD _Mismatch(_Unchecked(_First1), _Unchecked(_Last1),\012			_First2));\012	return (_STD pair<_InIt1, _InIt2>(\012		_Rechecked(_First1, _Ans.first),\012		_Ans.second));\012	}\012\012 #else /* _ITERATOR_DEBUG_LEVEL == 0 */\012template<class _InIt1,\012	class _InIt2> inline\012	pair<_InIt1, _InIt2>\012		_Mismatch1(_InIt1 _First1, _InIt1 _Last1,\012			_InIt2 _First2, _STD tr1::true_type)\012	{	// return [_First1, _Last1)/[_First2, ...) mismatch, checked input\012	return (_STD _Mismatch(_First1, _Last1,\012		_First2));\012	}\012\012template<class _InIt1,\012	class _InIt2> inline\012_SCL_INSECURE_DEPRECATE\012	pair<_InIt1, _InIt2>\012		_Mismatch1(_InIt1 _First1, _InIt1 _Last1,\012			_InIt2 _First2, _STD tr1::false_type)\012	{	// return [_First1, _Last1)/[_First2, ...) mismatch, unchecked input\012	return (_STD _Mismatch(_First1, _Last1,\012		_First2));\012	}\012\012template<class _InIt1,\012	class _InIt2> inline\012	pair<_InIt1, _InIt2>\012		mismatch(_InIt1 _First1, _InIt1 _Last1,\012			_InIt2 _First2)\012	{	// return [_First1, _Last1)/[_First2, ...) mismatch\012	_DEBUG_RANGE(_First1, _Last1);\012	_DEBUG_POINTER(_First2);\012	_STD pair<_UNCHECKED_TYPE(_InIt1), _InIt2> _Ans(\012		_STD _Mismatch1(_Unchecked(_First1), _Unchecked(_Last1),\012			_First2, _Is_checked(_First2)));\012	return (_STD pair<_InIt1, _InIt2>(\012		_Rechecked(_First1, _Ans.first),\012		_Ans.second));\012	}\012\012template<class _InIt1,\012	class _InTy,\012	size_t _InSize> inline\012	pair<_InIt1, _InTy *>\012		mismatch(_InIt1 _First1, _InIt1 _Last1,\012			_InTy (&_First2)[_InSize])\012	{	// return [_First1, _Last1)/[_First2, ...) mismatch, array input\012	_STD pair<_InIt1, _Array_iterator<_InTy, _InSize> > _Ans(\012		_STD mismatch(_First1, _Last1,\012			_Array_iterator<_InTy, _InSize>(_First2)));\012	return (_STD pair<_InIt1, _InTy *>(\012		_Ans.first,\012		_Unchecked(_Ans.second)));\012	}\012\012 #endif /* _ITERATOR_DEBUG_LEVEL == 0 */\012\012		// TEMPLATE FUNCTION mismatch WITH PRED\012template<class _InIt1,\012	class _InIt2,\012	class _Pr> inline\012	pair<_InIt1, _InIt2>\012		_Mismatch(_InIt1 _First1, _InIt1 _Last1,\012			_InIt2 _First2, _Pr _Pred)\012	{	// return [_First1, _Last1)/[_First2, ...) mismatch using _Pred\012	for (; _First1 != _Last1 && _Pred(*_First1, *_First2); )\012		++_First1, ++_First2;\012	return (pair<_InIt1, _InIt2>(_First1, _First2));\012	}\012\012 #if _ITERATOR_DEBUG_LEVEL == 0\012template<class _InIt1,\012	class _InIt2,\012	class _Pr> inline\012	pair<_InIt1, _InIt2>\012		mismatch(_InIt1 _First1, _InIt1 _Last1,\012			_InIt2 _First2, _Pr _Pred)\012	{	// return [_First1, _Last1)/[_First2, ...) mismatch using _Pred\012	_STD pair<_UNCHECKED_TYPE(_InIt1), _InIt2> _Ans(\012		_STD _Mismatch(_Unchecked(_First1), _Unchecked(_Last1),\012			_First2, _Pred));\012	return (_STD pair<_InIt1, _InIt2>(\012		_Rechecked(_First1, _Ans.first),\012		_Ans.second));\012	}\012\012 #else /* _ITERATOR_DEBUG_LEVEL == 0 */\012template<class _InIt1,\012	class _InIt2,\012	class _Pr> inline\012	pair<_InIt1, _InIt2>\012		_Mismatch2(_InIt1 _First1, _InIt1 _Last1,\012			_InIt2 _First2, _Pr _Pred, _STD tr1::true_type)\012	{	// return [_First1, _Last1)/[_First2, ...) mismatch, checked input\012	return (_STD _Mismatch(_First1, _Last1,\012		_First2, _Pred));\012	}\012\012template<class _InIt1,\012	class _InIt2,\012	class _Pr> inline\012_SCL_INSECURE_DEPRECATE\012	pair<_InIt1, _InIt2>\012		_Mismatch2(_InIt1 _First1, _InIt1 _Last1,\012			_InIt2 _First2, _Pr _Pred, _STD tr1::false_type)\012	{	// return [_First1, _Last1)/[_First2, ...) mismatch, unchecked input\012	return (_STD _Mismatch(_First1, _Last1,\012		_First2, _Pred));\012	}\012\012template<class _InIt1,\012	class _InIt2,\012	class _Pr> inline\012	pair<_InIt1, _InIt2>\012		mismatch(_InIt1 _First1, _InIt1 _Last1,\012			_InIt2 _First2, _Pr _Pred)\012	{	// return [_First1, _Last1)/[_First2, ...) mismatch using _Pred\012	_DEBUG_RANGE(_First1, _Last1);\012	_DEBUG_POINTER(_First2);\012	_DEBUG_POINTER(_Pred);\012	_STD pair<_UNCHECKED_TYPE(_InIt1), _InIt2> _Ans(\012		_STD _Mismatch2(_Unchecked(_First1), _Unchecked(_Last1),\012			_First2, _Pred, _Is_checked(_First2)));\012	return (_STD pair<_InIt1, _InIt2>(\012		_Rechecked(_First1, _Ans.first),\012		_Ans.second));\012	}\012\012template<class _InIt1,\012	class _InTy,\012	size_t _InSize,\012	class _Pr> inline\012	pair<_InIt1, _InTy *>\012		mismatch(_InIt1 _First1, _InIt1 _Last1,\012			_InTy (&_First2)[_InSize], _Pr _Pred)\012	{	// return [_First1, _Last1)/[_First2, ...) mismatch using _Pred\012	_STD pair<_InIt1, _Array_iterator<_InTy, _InSize> > _Ans(\012		_STD mismatch(_First1, _Last1,\012			_Array_iterator<_InTy, _InSize>(_First2), _Pred));\012	return (_STD pair<_InIt1, _InTy *>(\012		_Ans.first,\012		_Unchecked(_Ans.second)));\012	}\012 #endif /* _ITERATOR_DEBUG_LEVEL == 0 */\012\012		// TEMPLATE FUNCTION equal\012template<class _InIt1,\012	class _InIt2> inline\012	bool _Equal(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2)\012	{	// compare [_First1, _Last1) to [First2, ...)\012	for (; _First1 != _Last1; ++_First1, ++_First2)\012		if (!(*_First1 == *_First2))\012			return (false);\012	return (true);\012	}\012\012inline bool _Equal(const char *_First1, const char *_Last1,\012	const char *_First2)\012	{	// compare [_First1, _Last1) to [First2, ...), for chars\012	return (_CSTD memcmp(_First1, _First2, _Last1 - _First1) == 0);\012	}\012\012inline bool _Equal(const signed char *_First1, const signed char *_Last1,\012	const signed char *_First2)\012	{	// compare [_First1, _Last1) to [First2, ...), for signed chars\012	return (_CSTD memcmp(_First1, _First2, _Last1 - _First1) == 0);\012	}\012\012inline bool _Equal(const unsigned char *_First1, const unsigned char *_Last1,\012	const unsigned char *_First2)\012	{	// compare [_First1, _Last1) to [First2, ...), for unsigned chars\012	return (_CSTD memcmp(_First1, _First2, _Last1 - _First1) == 0);\012	}\012\012 #if _ITERATOR_DEBUG_LEVEL == 0\012template<class _InIt1,\012	class _InIt2> inline\012	bool equal(_InIt1 _First1, _InIt1 _Last1,\012		_InIt2 _First2)\012	{	// compare [_First1, _Last1) to [First2, ...)\012	return (_Equal(_Unchecked(_First1), _Unchecked(_Last1),\012		_Unchecked(_First2)));\012	}\012\012 #else /* _ITERATOR_DEBUG_LEVEL == 0 */\012template<class _InIt1,\012	class _InIt2> inline\012	bool _Equal1(_InIt1 _First1, _InIt1 _Last1,\012		_InIt2 _First2, _STD tr1::true_type)\012	{	// compare [_First1, _Last1) to [First2, ...), checked dest\012	return (_Equal(_First1, _Last1,\012		_First2));\012	}\012\012template<class _InIt1,\012	class _InIt2> inline\012_SCL_INSECURE_DEPRECATE\012	bool _Equal1(_InIt1 _First1, _InIt1 _Last1,\012		_InIt2 _First2, _STD tr1::false_type)\012	{	// compare [_First1, _Last1) to [First2, ...), unchecked dest\012	return (_Equal(_First1, _Last1,\012		_First2));\012	}\012\012template<class _InIt1,\012	class _InIt2> inline\012	bool equal(_InIt1 _First1, _InIt1 _Last1,\012		_InIt2 _First2)\012	{	// compare [_First1, _Last1) to [First2, ...)\012	_DEBUG_RANGE(_First1, _Last1);\012	_DEBUG_POINTER(_First2);\012	return (_Equal1(_Unchecked(_First1), _Unchecked(_Last1),\012		_First2, _Is_checked(_First2)));\012	}\012\012template<class _InIt1,\012	class _InTy,\012	size_t _InSize> inline\012	bool equal(_InIt1 _First1, _InIt1 _Last1,\012		_InTy (&_First2)[_InSize])\012	{	// compare [_First1, _Last1) to [First2, ...)\012	return (_STD equal(_First1, _Last1,\012		_Array_iterator<_InTy, _InSize>(_First2)));\012	}\012 #endif /* _ITERATOR_DEBUG_LEVEL == 0 */\012\012		// TEMPLATE FUNCTION equal WITH PRED\012template<class _InIt1,\012	class _InIt2,\012	class _Pr> inline\012	bool _Equal(_InIt1 _First1, _InIt1 _Last1,\012		_InIt2 _First2, _Pr _Pred)\012	{	// compare [_First1, _Last1) to [First2, ...) using _Pred\012	for (; _First1 != _Last1; ++_First1, ++_First2)\012		if (!_Pred(*_First1, *_First2))\012			return (false);\012	return (true);\012	}\012\012 #if _ITERATOR_DEBUG_LEVEL == 0\012template<class _InIt1,\012	class _InIt2,\012	class _Pr> inline\012	bool equal(_InIt1 _First1, _InIt1 _Last1,\012		_InIt2 _First2, _Pr _Pred)\012	{	// compare [_First1, _Last1) to [First2, ...)\012	return (_Equal(_Unchecked(_First1), _Unchecked(_Last1),\012		_Unchecked(_First2), _Pred));\012	}\012\012 #else /* _ITERATOR_DEBUG_LEVEL == 0 */\012template<class _InIt1,\012	class _InIt2,\012	class _Pr> inline\012	bool _Equal2(_InIt1 _First1, _InIt1 _Last1,\012		_InIt2 _First2, _Pr _Pred, _STD tr1::true_type)\012	{	// compare [_First1, _Last1) to [First2, ...), checked input\012	return (_Equal(_First1, _Last1,\012		_First2, _Pred));\012	}\012\012template<class _InIt1,\012	class _InIt2,\012	class _Pr> inline\012_SCL_INSECURE_DEPRECATE\012	bool _Equal2(_InIt1 _First1, _InIt1 _Last1,\012		_InIt2 _First2, _Pr _Pred, _STD tr1::false_type)\012	{	// compare [_First1, _Last1) to [First2, ...), unchecked input\012	return (_Equal(_First1, _Last1,\012		_First2, _Pred));\012	}\012\012template<class _InIt1,\012	class _InIt2,\012	class _Pr> inline\012	bool equal(_InIt1 _First1, _InIt1 _Last1,\012		_InIt2 _First2, _Pr _Pred)\012	{	// compare [_First1, _Last1) to [First2, ...)\012	_DEBUG_RANGE(_First1, _Last1);\012	_DEBUG_POINTER(_First2);\012	return (_Equal2(_Unchecked(_First1), _Unchecked(_Last1),\012		_First2, _Pred, _Is_checked(_First2)));\012	}\012\012template<class _InIt1,\012	class _InTy,\012	size_t _InSize,\012	class _Pr> inline\012	bool equal(_InIt1 _First1, _InIt1 _Last1,\012		_InTy (&_First2)[_InSize], _Pr _Pred)\012	{	// compare [_First1, _Last1) to [First2, ...)\012	return (_STD equal(_First1, _Last1,\012		_Array_iterator<_InTy, _InSize>(_First2), _Pred));\012	}\012 #endif /* _ITERATOR_DEBUG_LEVEL == 0 */\012\012		// TEMPLATE FUNCTION lexicographical_compare\012template<class _InIt1,\012	class _InIt2> inline\012	bool _Lexicographical_compare(_InIt1 _First1, _InIt1 _Last1,\012		_InIt2 _First2, _InIt2 _Last2)\012	{	// order [_First1, _Last1) vs. [First2, Last2)\012	for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, ++_First2)\012		if (_DEBUG_LT(*_First1, *_First2))\012			return (true);\012		else if (*_First2 < *_First1)\012			return (false);\012	return (_First1 == _Last1 && _First2 != _Last2);\012	}\012\012inline bool _Lexicographical_compare(\012	const unsigned char *_First1, const unsigned char *_Last1,\012	const unsigned char *_First2, const unsigned char *_Last2)\012	{	// order [_First1, _Last1) vs. [First2, Last2), for unsigned char\012	ptrdiff_t _Num1 = _Last1 - _First1;\012	ptrdiff_t _Num2 = _Last2 - _First2;\012	int _Ans = _CSTD memcmp(_First1, _First2, _Num1 < _Num2 ? _Num1 : _Num2);\012	return (_Ans < 0 || _Ans == 0 && _Num1 < _Num2);\012	}\012\012 #if CHAR_MAX == UCHAR_MAX\012inline bool _Lexicographical_compare(\012	const char *_First1, const char *_Last1,\012	const char *_First2, const char *_Last2)\012	{	// order [_First1, _Last1) vs. [First2, Last2), for nonnegative char\012	ptrdiff_t _Num1 = _Last1 - _First1;\012	ptrdiff_t _Num2 = _Last2 - _First2;\012	int _Ans = _CSTD memcmp(_First1, _First2, _Num1 < _Num2 ? _Num1 : _Num2);\012	return (_Ans < 0 || _Ans == 0 && _Num1 < _Num2);\012	}\012 #endif /* CHAR_MAX == UCHAR_MAX */\012\012template<class _InIt1,\012	class _InIt2> inline\012	bool lexicographical_compare(_InIt1 _First1, _InIt1 _Last1,\012		_InIt2 _First2, _InIt2 _Last2)\012	{	// order [_First1, _Last1) vs. [First2, Last2)\012	_DEBUG_RANGE(_First1, _Last1);\012	_DEBUG_RANGE(_First2, _Last2);\012	return (_Lexicographical_compare(_Unchecked(_First1), _Unchecked(_Last1),\012		_Unchecked(_First2), _Unchecked(_Last2)));\012	}\012\012		// TEMPLATE FUNCTION lexicographical_compare WITH PRED\012template<class _InIt1,\012	class _InIt2,\012	class _Pr> inline\012	bool _Lexicographical_compare(_InIt1 _First1, _InIt1 _Last1,\012		_InIt2 _First2, _InIt2 _Last2, _Pr _Pred)\012	{	// order [_First1, _Last1) vs. [First2, Last2) using _Pred\012	for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, ++_First2)\012		if (_DEBUG_LT_PRED(_Pred, *_First1, *_First2))\012			return (true);\012		else if (_Pred(*_First2, *_First1))\012			return (false);\012	return (_First1 == _Last1 && _First2 != _Last2);\012	}\012\012template<class _InIt1,\012	class _InIt2,\012	class _Pr> inline\012	bool lexicographical_compare(_InIt1 _First1, _InIt1 _Last1,\012		_InIt2 _First2, _InIt2 _Last2, _Pr _Pred)\012	{	// order [_First1, _Last1) vs. [First2, Last2) using _Pred\012	_DEBUG_RANGE(_First1, _Last1);\012	_DEBUG_RANGE(_First2, _Last2);\012	_DEBUG_POINTER(_Pred);\012	return (_Lexicographical_compare(_Unchecked(_First1), _Unchecked(_Last1),\012		_Unchecked(_First2), _Unchecked(_Last2), _Pred));\012	}\012\012		// TEMPLATE FUNCTION reverse\012template<class _BidIt> inline\012	void _Reverse(_BidIt _First, _BidIt _Last, bidirectional_iterator_tag)\012	{	// reverse elements in [_First, _Last), bidirectional iterators\012	for (; _First != _Last && _First != --_Last; ++_First)\012		_STD iter_swap(_First, _Last);\012	}\012\012template<class _BidIt> inline\012	void reverse(_BidIt _First, _BidIt _Last)\012	{	// reverse elements in [_First, _Last)\012	_DEBUG_RANGE(_First, _Last);\012	_Reverse(_Unchecked(_First), _Unchecked(_Last), _Iter_cat(_First));\012	}\012\012		// TEMPLATE FUNCTION rotate\012template<class _FwdIt> inline\012	void _Rotate(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last,\012		forward_iterator_tag)\012	{	// rotate [_First, _Last), forward iterators\012	for (_FwdIt _Next = _Mid; ; )\012		{	// swap [_First, ...) into place\012		_STD iter_swap(_First, _Next);\012		if (++_First == _Mid)\012			if (++_Next == _Last)\012				break;	// done, quit\012			else\012				_Mid = _Next;	// mark end of next interval\012		else if (++_Next == _Last)\012			_Next = _Mid;	// wrap to last end\012		}\012	}\012\012template<class _BidIt> inline\012	void _Rotate(_BidIt _First, _BidIt _Mid, _BidIt _Last,\012		bidirectional_iterator_tag)\012	{	// rotate [_First, _Last), bidirectional iterators\012	_STD reverse(_First, _Mid);\012	_STD reverse(_Mid, _Last);\012	_STD reverse(_First, _Last);\012	}\012\012template<class _RanIt,\012	class _Diff,\012	class _Ty> inline\012	void _Rotate(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Diff *, _Ty *)\012	{	// rotate [_First, _Last), random-access iterators\012	_Diff _Shift = _Mid - _First;\012	_Diff _Count = _Last - _First;\012\012	for (_Diff _Factor = _Shift; _Factor != 0; )\012		{	// find subcycle count as GCD of shift count and length\012		_Diff _Tmp = _Count % _Factor;\012		_Count = _Factor;\012		_Factor = _Tmp;\012		}\012\012	if (_Count < _Last - _First)\012		for (; 0 < _Count; --_Count)\012			{	// rotate each subcycle\012			_RanIt _Hole = _First + _Count;\012			_RanIt _Next = _Hole;\012			_RanIt _Next1 = _Next + _Shift == _Last ? _First : _Next + _Shift;\012			for (; ; )\012				{	// percolate elements back around subcycle\012				iter_swap(_Next, _Next1);\012				_Next = _Next1;\012				_Next1 = _Shift < _Last - _Next1 ? _Next1 + _Shift\012					: _First + (_Shift - (_Last - _Next1));\012				if (_Next1 == _Hole)\012					break;\012				}\012			}\012	}\012\012template<class _RanIt> inline\012	void _Rotate(_RanIt _First, _RanIt _Mid, _RanIt _Last,\012		random_access_iterator_tag)\012	{	// rotate [_First, _Last), random-access iterators\012	_Rotate(_First, _Mid, _Last, _Dist_type(_First), _Val_type(_First));\012	}\012\012template<class _FwdIt> inline\012	_FwdIt rotate(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last)\012	{	// rotate [_First, _Last)\012	_DEBUG_RANGE(_First, _Mid);\012	_DEBUG_RANGE(_Mid, _Last);\012	if (_First != _Mid && _Mid != _Last)\012		{	// rotate and compute new first iterator\012		_Rotate(_Unchecked(_First), _Unchecked(_Mid), _Unchecked(_Last),\012			_Iter_cat(_First));\012		_STD advance(_First, _STD distance(_Mid, _Last));\012		}\012	return (_First);\012	}\012\012		// TEMPLATE CLASS _Yarn\012template<class _Elem>\012	class _CRTIMP2_PURE _Yarn\012	{	// wrap a NTBS\012public:\012	typedef _Yarn<_Elem> _Myt;\012\012	__CLR_OR_THIS_CALL _Yarn()\012		: _Myptr(0), _Nul(0)\012		{	// default construct\012		}\012\012	__CLR_OR_THIS_CALL _Yarn(const _Myt& _Right)\012		: _Myptr(0), _Nul(0)\012		{	// construct from _Yarn\012		*this = _Right;\012		}\012\012	__CLR_OR_THIS_CALL _Yarn(const _Elem *_Right)\012		: _Myptr(0), _Nul(0)\012		{	// construct from NTBS\012		*this = _Right;\012		}\012\012	_Myt& __CLR_OR_THIS_CALL operator=(const _Myt& _Right)\012		{	// assign from _Yarn\012		return (*this = _Right._Myptr);\012		}\012\012	_Myt& __CLR_OR_THIS_CALL operator=(const _Elem *_Right)\012		{	// assign from NTBS\012		if (_Myptr != _Right)\012			{	// new value, discard old and copy new\012			_Tidy();\012\012			if (_Right != 0)\012				{	// new is not empty, copy it\012				const _Elem *_Ptr = _Right;\012				while (*_Ptr != (_Elem)0)\012					++_Ptr;\012				size_t _Count = ((const char *)++_Ptr - (const char *)_Right)\012					* sizeof (_Elem);\012\012 #ifdef _DEBUG\012				_Myptr = (_Elem *)_malloc_dbg(_Count, _CRT_BLOCK,\012					__FILE__, __LINE__);\012\012 #else /* _DEBUG */\012				_Myptr = (_Elem *)_CSTD malloc(_Count);\012 #endif /* _DEBUG */\012\012				if (_Myptr != 0)\012					_CSTD memcpy(_Myptr, _Right, _Count);\012				}\012			}\012		return (*this);\012		}\012\012	__CLR_OR_THIS_CALL ~_Yarn()\012		{	// destroy the object\012		_Tidy();\012		}\012\012	bool __CLR_OR_THIS_CALL empty() const\012		{	// test if empty string\012		return (_Myptr == 0);\012		}\012\012	const _Elem *__CLR_OR_THIS_CALL c_str() const\012		{	// return NTBS\012		return (_Myptr != 0 ? _Myptr : &_Nul);\012		}\012\012	bool __CLR_OR_THIS_CALL _Empty() const\012		{	// test if empty string\012		return (_Myptr == 0);\012		}\012\012	const _Elem *__CLR_OR_THIS_CALL _C_str() const\012		{	// return NTBS\012		return (_Myptr != 0 ? _Myptr : &_Nul);\012		}\012\012private:\012	void __CLR_OR_THIS_CALL _Tidy()\012		{	// discard any string\012		if (_Myptr != 0)\012\012 #ifdef _DEBUG\012			_free_dbg(_Myptr, _CRT_BLOCK);\012\012 #else /* _DEBUG */\012			_CSTD free(_Myptr);\012 #endif /* _DEBUG */\012\012		_Myptr = 0;\012		}\012\012	_Elem *_Myptr;	// pointer to allocated string\012	_Elem _Nul;		// nul terminator for unallocated string\012	};\012\012_CRTIMP2_PURE __declspec(noreturn) void __CLRCALL_PURE_OR_CDECL _Xinvalid_argument(_In_z_ const char *);\012_CRTIMP2_PURE __declspec(noreturn) void __CLRCALL_PURE_OR_CDECL _Xlength_error(_In_z_ const char *);\012_CRTIMP2_PURE __declspec(noreturn) void __CLRCALL_PURE_OR_CDECL _Xout_of_range(_In_z_ const char *);\012_CRTIMP2_PURE __declspec(noreturn) void __CLRCALL_PURE_OR_CDECL _Xoverflow_error(_In_z_ const char *);\012_CRTIMP2_PURE __declspec(noreturn) void __CLRCALL_PURE_OR_CDECL _Xruntime_error(_In_z_ const char *);\012_STD_END\012 #pragma warning(pop)\012 #pragma pack(pop)\012\012#endif /* RC_INVOKED */\012#endif /* _XUTILITY_ */\012\012/*\012 * This file is derived from software bearing the following\012 * restrictions:\012 *\012 * Copyright (c) 1994\012 * Hewlett-Packard Company\012 *\012 * Permission to use, copy, modify, distribute and sell this\012 * software and its documentation for any purpose is hereby\012 * granted without fee, provided that the above copyright notice\012 * appear in all copies and that both that copyright notice and\012 * this permission notice appear in supporting documentation.\012 * Hewlett-Packard Company makes no representations about the\012 * suitability of this software for any purpose. It is provided\012 * \"as is\" without express or implied warranty.\012 */\012\012/*\012 * Copyright (c) 1992-2009 by P.J. Plauger.  ALL RIGHTS RESERVED.\012 * Consult your license regarding permissions and restrictions.\012V5.20:0009 */\012"}];