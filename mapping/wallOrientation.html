<!DOCTYPE html>
<html>
<head>
  <title>Maze Drawing</title>
  <style>
    body {
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      margin: 0;
      background: #f1f1f1;
    }
    canvas {
      border: 1px solid #ccc;
    }
  </style>
</head>
<body>
    <script>
        var grid_dimensions = [73, 48]; 
        var grid_resolution = 5;
        // var grid_dimensions = [181, 120]; 
        // var grid_resolution = 2;
        var allNeighbours = {}; // to memoise neighbour lists instead of always calling getNeighbours()
        var prevPrevPrevPrevCell = [0, 0];
        var prevPrevPrevCell = [0, 0];
        var prevPrevCell = [0, 0];
        var prevCell = [0, 0];
        var currCell = [0, 0];
        var createdDiagonals = [];
        var wallOrientation = "left";
        var currPath = [];
        var currWall = null;
        // rover class
        class Rover {
            constructor() {
                this.x = 0;
                this.y = 0;
                this.grid_x = 0;
                this.grid_y = 0;
                this.bearing = 0;
            }
        }

        // maze class
        class Maze {
            constructor() {
                this.grid = [];
                this.visitedGrid = [];
                this.pseudoVisited = [];
            }

            createGrid() {
                for (let x = 0; x < grid_dimensions[0]; x++) {
                    let row = [];
                    for (let y = 0; y < grid_dimensions[1]; y++) {
                        row.push([false, false, false, false, false]);
                    }
                    this.grid.push(row);
                }
            }
        }
        let mazeMap = new Maze()
        let rover = new Rover()
        mazeMap.createGrid()
        
        function updatePosition(rover, x, y, bearing, leftWall, rightWall) {
            // update the rover's position based on the distance and bearing
            rover.x = x;
            rover.y = y;
            rover.bearing = bearing;

            // rounding
            rover.grid_x = Math.round(rover.x / grid_resolution);
            rover.grid_y = Math.round(rover.y / grid_resolution);
            
        }

        function updateBorder(maze, x, y, border, neighbourBorder, delta) {
            // mark border as wall
            maze.grid[x][y][border] = true

            let limitCheck;
            if ([1, 3].includes(border)) {
                ni = x + delta;
                limitCheck = grid_dimensions[0];
            } else {
                ni = y + delta;
                limitCheck = grid_dimensions[1];
            }

            if (0 <= ni && ni < limitCheck) {
                if ([1, 3].includes(border)) {
                    maze.grid[ni][y][neighbourBorder] = true;
                } else {
                    maze.grid[x][ni][neighbourBorder] = true;
                }
            }    
        }

        function leftWallFollowing(maze, prevCell, currCell){
            let dx = currCell[0] - prevCell[0];
            let dy = currCell[1] - prevCell[1];
            let x = currCell[0];
            let y = currCell[1];
            let prevX = prevCell[0];
            let prevY = prevCell[1];
            if (dy === 1 && dx === 0) {  // moving right
                        // mark top wall of curr cell
                        border = 1;
                        neighbourBorder = 3;
                        delta = -1;
                        updateBorder(maze, currCell[0], currCell[1], border, neighbourBorder, delta); 
            } else if (dy === -1 && dx === 0) {  // moving left
                // mark bottom wall of curr cell
                border = 3;
                neighbourBorder = 1;
                delta = 1;
                updateBorder(maze, currCell[0], currCell[1], border, neighbourBorder, delta); 
            } else if (dx === 1 && dy === 0) {  // moving down
                // mark right wall of curr cell
                border = 2;
                neighbourBorder = 4;
                delta = 1;
                updateBorder(maze, currCell[0], currCell[1], border, neighbourBorder, delta);
            } else if (dx === -1 && dy === 0) {  // moving up
                // mark left wall of curr cell
                border = 4;
                neighbourBorder = 2;
                delta = -1;
                updateBorder(maze, currCell[0], currCell[1], border, neighbourBorder, delta); 
            } else if (dx === -1 && dy === -1){ // moving up-left
                // mark left wall of prev cell
                border = 4;
                neighbourBorder = 2;
                delta = -1;
                updateBorder(maze, prevCell[0], prevCell[1], border, neighbourBorder, delta);  
                // mark bottom wall of curr cell
                border = 3;
                neighbourBorder = 1;
                delta = 1;
                updateBorder(maze, currCell[0], currCell[1], border, neighbourBorder, delta);
            } else if (dx === -1 && dy === 1){ // moving up-right
                // mark top wall of prev cell
                border = 1;
                neighbourBorder = 3;
                delta = -1;
                updateBorder(maze, prevCell[0], prevCell[1], border, neighbourBorder, delta); 
                // mark left wall of curr cell
                border = 4;
                neighbourBorder = 2;
                delta = -1;
                updateBorder(maze, currCell[0], currCell[1], border, neighbourBorder, delta);  
                if(maze.grid[prevX][prevY][1] && maze.grid[prevX][prevY][3]){
                    border = 4;
                    neighbourBorder = 2;
                    delta = -1;
                    updateBorder(maze, prevCell[0], prevCell[1], border, neighbourBorder, delta);  
                    // maze.grid[prevX][prevY][4] = true;
                }
            } else if (dx === 1 && dy === -1){ // moving down-left
                // mark bottom wall of prev cell
                border = 3;
                neighbourBorder = 1;
                delta = 1;
                updateBorder(maze, prevCell[0], prevCell[1], border, neighbourBorder, delta); 
                // mark right wall of curr cell
                border = 2;
                neighbourBorder = 4;
                delta = 1;
                updateBorder(maze, currCell[0], currCell[1], border, neighbourBorder, delta); 
            } else if (dx === 1 && dy === 1){ // moving down-right
                // mark right wall of prev cell
                border = 2;
                neighbourBorder = 4;
                delta = 1;
                updateBorder(maze, prevCell[0], prevCell[1], border, neighbourBorder, delta); 
                // mark top wall of curr cell
                border = 1;
                neighbourBorder = 3;
                delta = -1;
                updateBorder(maze, currCell[0], currCell[1], border, neighbourBorder, delta); 
            }  
        }
        
        function cleanPath(maze, path, following){
            let pathLength = path.length;
            console.log(pathLength);
            let prevCell;
            let currCell;
            let dx;
            let dy;
            for(let j = 1; j < pathLength; j++){
                prevCell = path[j-1];
                currCell = path[j];
                x = currCell[0];
                y = currCell[1];
                prevX = prevCell[0];
                prevY = prevCell[1];
                dx = currCell[0] - prevCell[0];
                dy = currCell[1] - prevCell[1];
                if (dy === 1 && dx === 0) {  // moving right
                    maze.grid[prevX][prevY][2] = false;
                    maze.grid[x][y][4] = false;
                    maze.grid[x][y][3] = false;
                    if(x+1 < grid_dimensions[0]){
                        maze.grid[x+1][y][1] = false;
                    }
                } else if (dy === -1 && dx === 0) {  // moving left
                    maze.grid[prevX][prevY][4] = false;
                    maze.grid[x][y][2] = false;
                    maze.grid[x][y][1] = false;
                    if(x-1>=0){
                        maze.grid[x-1][y][3] = false;
                    }
                } else if (dx === 1 && dy === 0) {  // moving down
                    maze.grid[prevX][prevY][3] = false;
                    maze.grid[x][y][1] = false;
                    maze.grid[x][y][4] = false;
                    if(y-1>=0){
                        maze.grid[x][y-1][2] = false;
                    }
                } else if (dx === -1 && dy === 0) {  // moving up
                    maze.grid[prevX][prevY][1] = false;
                    maze.grid[x][y][3] = false;
                    maze.grid[x][y][2] = false;
                    if(y+1 < grid_dimensions[1]){
                        maze.grid[x][y+1][4] = false;
                    }
                }
            }
        }

        // case a
        function caseA(maze, rover, xcoord, ycoord, degree, leftWall, rightWall){
            let x = xcoord;
            let y = ycoord;
            let bearing = degree;
            let left_wall = leftWall;
            let right_wall = rightWall;
            let rightleft = leftWall ? "left" : "right";
            updatePosition(rover, x, y, bearing, leftWall, rightWall);
            x = rover.grid_x;
            y = rover.grid_y;
            if(x !== currCell[0] || y !== currCell[1]){
                prevPrevPrevPrevCell = [...prevPrevPrevCell];
                prevPrevPrevCell = [...prevPrevCell];
                prevPrevCell = [...prevCell];
                prevCell = [...currCell];
                currCell = [x, y];
            }
            if(currWall !== null){
                if (rightleft === currWall){
                    currPath.push(currCell);
                } else {
                    cleanPath(maze, currPath, currWall);
                    currWall = rightleft;
                    currPath = [];
                    currPath.push(currCell);
                }
            } else {
                currWall = rightleft;
                currPath.push(currCell)
            }

            let border;
            let neighbourBorder;
            let delta;

            let prevX = prevCell[0];
            let prevY = prevCell[1];
            let dx = currCell[0] - prevCell[0];
            let dy = currCell[1] - prevCell[1];
            if(!maze.grid[x][y][0]){
                maze.grid[x][y][0] = true
            }
            prevNEcurr = prevCell[0] !== currCell[0] && prevCell[1] !== currCell[1]
            prevPrevNEcurr = prevPrevCell[0] !== currCell[0] && prevPrevCell[1] !== currCell[1]
            if (currCell !== [0, 0] || prevNEcurr || prevPrevNEcurr){
                if (leftWall){
                    leftWallFollowing(maze, prevCell, currCell);
                    let ddx = currCell[0] - prevPrevCell[0];
                    let ddy = currCell[1] - prevPrevCell[1];
                    let pddx = prevCell[0] - prevPrevPrevCell[0];
                    let pddy = prevCell[1] - prevPrevPrevCell[1];
                    ddRange = [[-1, -1], [-1, 1], [1, -1], [1, 1]];
                    diagonal = (ddx === 1 && (ddy === 1 || ddy === -1)) || (ddx === -1 && (ddy === 1 || ddy === -1))
                    prevDiagonal = (pddx === 1 && (pddy === 1 || pddy === -1)) || (pddx === -1 && (pddy === 1 || pddy === -1))
                    if (diagonal){
                        // console.log(createdDiagonals.some(arr => JSON.stringify(arr) === JSON.stringify([prevCell, prevPrevPrevCell])));
                        if (!createdDiagonals.some(arr => JSON.stringify(arr) === JSON.stringify([prevCell, prevPrevPrevCell]))) {
                            for (let i = 1; i <= 4; i++){
                                maze.grid[prevX][prevY][i] = false;
                                if (i === 1 && prevX-1 >= 0){
                                    maze.grid[prevX-1][prevY][3] = false;
                                } else if (i === 2 && prevY+1 < grid_dimensions[1]){
                                    maze.grid[prevX][prevY+1][4] = false;
                                } else if (i === 3 && prevX+1 < grid_dimensions[0]){
                                    maze.grid[prevX+1][prevY][1] = false;
                                } else if (i === 4 && prevY-1 >= 0){
                                    maze.grid[prevX][prevY-1][2] = false;
                                }
                            }
                            leftWallFollowing(maze, prevPrevCell, currCell);
                            createdDiagonals.push([currCell, prevPrevCell]);
                        }
                    } 
                    if (!(createdDiagonals.some(arr => JSON.stringify(arr) === JSON.stringify([currCell, prevPrevCell])) && createdDiagonals.some(arr => JSON.stringify(arr) === JSON.stringify([prevCell, prevPrevPrevCell])))) {
                        let prevGrid = [4, 1, 2, 3];
                        let pPx = prevPrevCell[0];
                        let pPy = prevPrevCell[1];
                        let pPPx = prevPrevPrevCell[0];
                        let pPPy = prevPrevPrevCell[1];
                        for (let i = 1; i <= 4; i++){
                            // console.log(`"Previous border for ${i}: "`)
                            if (maze.grid[prevX][prevY][i] && maze.grid[pPx][pPy][prevGrid[i-1]]){
                                maze.grid[pPx][pPy][i] = true;
                                if (i === 1 && pPx-1 >= 0){
                                    maze.grid[pPx-1][pPy][3] = true;
                                } else if (i === 2 && pPy+1 < grid_dimensions[1]){
                                    maze.grid[pPx][pPy+1][4] = true;
                                } else if (i === 3 && pPx+1 < grid_dimensions[0]){
                                    maze.grid[pPx+1][pPy][1] = true;
                                } else if (i === 4 && pPy-1 >= 0){
                                    maze.grid[pPx][pPy-1][2] = true;
                                }
                            }
                        }
                    }
                } else if (rightWall) {
                    if (dy === 1 && dx === 0) {  // moving right
                        // mark bottom wall of curr cell
                        border = 3;
                        neighbourBorder = 1;
                        delta = 1;
                        updateBorder(maze, currCell[0], currCell[1], border, neighbourBorder, delta); 
                    } else if (dy === -1 && dx === 0) {  // moving left
                        // mark top wall of curr cell
                        border = 1;
                        neighbourBorder = 3;
                        delta = -1;
                        updateBorder(maze, currCell[0], currCell[1], border, neighbourBorder, delta); 
                    } else if (dx === 1 && dy === 0) {  // moving down
                        // mark left wall of curr cell
                        border = 4;
                        neighbourBorder = 2;
                        delta = -1;
                        updateBorder(maze, currCell[0], currCell[1], border, neighbourBorder, delta); 
                    } else if (dx === -1 && dy === 0) {  // moving up
                        // mark right wall of curr cell
                        border = 2;
                        neighbourBorder = 4;
                        delta = 1;
                        updateBorder(maze, currCell[0], currCell[1], border, neighbourBorder, delta);   
                    } else if (dx === -1 && dy === -1){ // moving up-left
                        // mark top wall of prev cell
                        border = 1;
                        neighbourBorder = 3;
                        delta = -1;
                        updateBorder(maze, prevCell[0], prevCell[1], border, neighbourBorder, delta); 
                        // mark right wall of curr cell
                        border = 2;
                        neighbourBorder = 4;
                        delta = 1;
                        updateBorder(maze, currCell[0], currCell[1], border, neighbourBorder, delta);  
                    } else if (dx === -1 && dy === 1){ // moving up-right
                        // mark right wall of prev cell
                        border = 2;
                        neighbourBorder = 4;
                        delta = 1;
                        updateBorder(maze, prevCell[0], prevCell[1], border, neighbourBorder, delta); 
                        // mark bottom wall of curr cell
                        border = 3;
                        neighbourBorder = 1;
                        delta = 1;
                        updateBorder(maze, currCell[0], currCell[1], border, neighbourBorder, delta); 
                    } else if (dx === 1 && dy === -1){ // moving down-left
                        // mark left wall of prev cell
                        border = 4;
                        neighbourBorder = 2;
                        delta = -1;
                        updateBorder(maze, prevCell[0], prevCell[1], border, neighbourBorder, delta); 
                        // mark top wall of curr cell
                        border = 1;
                        neighbourBorder = 3;
                        delta = -1;
                        updateBorder(maze, currCell[0], currCell[1], border, neighbourBorder, delta); 
                    } else if (dx === 1 && dy === 1){ // moving down-right
                        // mark bottom wall of prev cell
                        border = 3;
                        neighbourBorder = 1;
                        delta = 1;
                        updateBorder(maze, prevCell[0], prevCell[1], border, neighbourBorder, delta); 
                        // mark left wall of curr cell
                        border = 4;
                        neighbourBorder = 2;
                        delta = -1;
                        updateBorder(maze, currCell[0], currCell[1], border, neighbourBorder, delta); 
                    }  
                }
            }
        }


        function drawMaze(maze) {
            const canvas = document.createElement("canvas");
            const context = canvas.getContext("2d");

            const cellSize = 10; // adjust the cell size as needed
            // const cellSize = 4; // adjust the cell size as needed
            const wallColor = "blue";
            const pathColor = "white";
            const visitedColor = "#E0E0E0"; // Lighter shade of gray

            canvas.width = maze[0].length * cellSize;
            canvas.height = maze.length * cellSize;

            // iterate over each cell in the maze
            for (let row = 0; row < maze.length; row++) {
                for (let col = 0; col < maze[row].length; col++) {
                const cell = maze[row][col];

                const x = col * cellSize;
                const y = row * cellSize;

                // clear the cell
                if (cell[0]) {
                    context.fillStyle = visitedColor;
                } else {
                    context.fillStyle = pathColor;
                }
                context.fillRect(x, y, cellSize, cellSize);

                // draw walls
                context.fillStyle = wallColor;
                if (cell[1]) {
                    context.fillRect(x, y, cellSize, 1); // top wall
                }
                if (cell[2]) {
                    context.fillRect(x + cellSize - 1, y, 1, cellSize); // right wall
                }
                if (cell[3]) {
                    context.fillRect(x, y + cellSize - 1, cellSize, 1); // bottom wall
                }
                if (cell[4]) {
                    context.fillRect(x, y, 1, cellSize); // left wall
                }
                }
            }
            document.body.appendChild(canvas);
        }



    drawMaze(mazeMap.grid);
  </script>
</body>
</html>
